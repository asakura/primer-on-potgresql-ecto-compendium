#+TITLE: Конспект PostgreSQL Основы языка SQL (и Elixir's Ecto)
#+AUTHOR: Mikalai Seva
#+EMAIL: mikalai.seva@gmail.com
#+DESCRIPTION:
#+KEYWORDS: PostgreSQL SQL Primer Ecto Elixir
#+LANGUAGE: ru, en
#+OPTIONS: H:3 toc:2 p:t
#+OPTIONS: ^:{}
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* Введение в базы данных и SQL
** Что такое базы данных
Одним из основных понятий в теории баз данных является *модель данных*. Можно
сказать, что она характеризует способ организации данных и основные методы
доступа к ним. В ходе эволюции теорий и идей была разработана реляционная модель
данных, которая сейчас и является доминирующей. Характерной чертой реляционных
баз данных является тот факт, что данные воспринимаются пользователем как
таблицы.

Одним из достоинств реляционной базы данных является ее способность поддерживать
связи между элементами данных, избавляя программиста от необходимости заниматься
этой рутинной и очень трудоемкой работой. Работая с реляционными базами данных,
программист избавлен от программирования на «атомарном» уровне, потому что
современные языки для «общения» с этими базами данных являются декларативными.

Система баз данных — это компьютеризированная система, предназначенная для
хранения, переработки и выдачи информации по запросу пользователей. Такая
система включает в себя программное и аппаратное обеспечение, сами данные, а
также пользователей.

Современные системы баз данных являются, как правило, многопользовательскими. В
таких системах одновременный доступ к базе данных могут получить сразу несколько
пользователей.

Основным программным обеспечением является система управления базами данных.
По-английски она называется /database management system/ (DBMS). Кроме СУБД в
систему баз данных могут входить утилиты, средства для разработки приложений
(программ), средства проектирования базы данных, генераторы отчетов и др.

Пользователи систем с базами данных подразделяются на ряд категорий. Первая
категория — это прикладные программисты. Вторая категория — это конечные
пользователи, ради которых и выполняется вся работа. Они могут получить доступ к
базе данных, используя прикладные программы или универсальные приложения,
которые входят в программное обеспечение самой СУБД. Третья категория
пользователей — это администраторы базы данных. В их обязанности входят:
создание базы данных, выбор оптимальных режимов доступа к ней, разграничение
полномочий различных пользователей на доступ к той или иной информации в базе
данных, выполнение резервного копирования базы данных и т.д.

Систему баз данных можно разделить на два главных компонента: сервер и набор
клиентов (или внешних интерфейсов). Сервер — это и есть СУБД. Один сервер может
обслуживать много клиентов.

Современные СУБД включают в себя словарь данных. Это часть базы данных, которая
описывает сами данные, хранящиеся в ней. Словарь данных помогает СУБД выполнять
свои функции.
** Основные понятия реляционной модели
В эпоху, предшествующую рождению реляционной теории, базы данных традиционно
рассматривались как набор *файлов*, состоящих из *записей*, а записи, в свою
очередь, подразделялись на отдельные *поля*. Поле являлось элементарной единицей
данных.

В реляционных базах данных пользователь воспринимает данные в виде таблиц.
Поэтому термину «файл» соответствует термин *«таблица»*, вместо термина «запись»
используется термин *«строка»*, а вместо термина «поле» — термин *«столбец»*
(или *«колонка»*).

В формальной теории реляционных баз данных эти таблицы называют *отношениями*
(*relations*) — поэтому и базы данных называются реляционными. Отношение — это
математический термин. При определении свойств таких отношений используется
теория множеств. В терминах данной теории строки таблицы будут называться
*кортежами* (*tuples*), а колонки — *атрибутами*. Отношение имеет заголовок,
который состоит из атрибутов, и тело, состоящее из кортежей. Количество
атрибутов называется *степенью отношения*, а количество кортежей — *кардинальным
числом*. Кроме теории множеств, одним из оснований реляционной теории является
такой раздел математической логики, как исчисление предикатов.

При работе с базами данных часто приходится следовать *различным ограничениям*,
которые могут быть обусловлены спецификой конкретной предметной области.

Для идентификации строк в таблицах и для связи таблиц между собой используются
так называемые ключи. *Потенциальный ключ* — это комбинация атрибутов таблицы,
позволяющая уникальным образом идентифицировать строки в ней. Ключ может
состоять только лишь из одного атрибута таблицы. Потенциальный ключ должен быть
*неизбыточным*, т.е. никакое подмножество атрибутов, входящих в него, не должно
обладать свойством уникальности. Ключ, состоящий из нескольких атрибутов
называется *составным*.

Ключи нужны для адресации на уровне строк (записей). При наличии в таблице более
одного потенциального ключа один из них выбирается в качестве так называемого
*первичного ключа*, а остальные будут являться *альтернативными ключами*.

*Внешним ключ* - это ключ, используемый для объединения двух таблиц. Таблица,
содержащая внешний ключ, называется *ссылающейся* таблицей (*referencing
table*). Таблица, содержащая соответствующий потенциальный ключ, называется
*ссылочной* (*целевой*) таблицей (*referenced table*). В таких случаях говорят,
что внешний ключ ссылается на потенциальный ключ в ссылочной таблице. Внешний
ключ может быть составным, т.е. может включать более одного атрибута. Внешний
ключ не обязан быть уникальным.

Проблема обеспечения того, чтобы база данных не содержала неверных значений
внешних ключей, известна как проблема *ссылочной целостности*. Ограничение,
согласно которому значения внешних ключей должны соответствовать значениям
потенциальных ключей, называется *ограничением ссылочной целостности*
(*ссылочным ограничением*).

Обеспечением выполнения ограничений ссылочной целостности занимается СУБД, а от
разработчика требуется лишь указать атрибуты, служащие в качестве внешних
ключей. При проектировании баз данных часто предусматривается, что при удалении
строки из ссылочной таблицы соответствующие строки из ссылающейся таблицы должны
быть также удалены, а при изменении значения столбца, на который ссылается
внешний ключ, должны быть изменены значения внешнего ключа в ссылающейся
таблице. Этот подход называется *каскадным удалением* (*обновлением*).

Иногда применяются и другие подходы. Например, вместо удаления строк из
ссылающейся таблицы в этих строках просто заменяют значения атрибутов, входящих
во внешний ключ, так называемыми *NULL*-значениями. Первичные ключи не могут
содержать NULL-значений.

*Транзакция* — одно из важнейших понятий теории баз данных. Она означает набор
операций над базой данных, рассматриваемых как единая и неделимая единица
работы, выполняемая полностью или не выполняемая вовсе, если произошел какойто
сбой в процессе выполнения транзакции. Таким образом, транзакции являются
*средством обеспечения согласованности данных*.
** Что такое язык SQL
Язык SQL — это непроцедурный язык, который является стандартным средством работы
с данными во всех реляционных СУБД. *Операторы* (*команды*), написанные на этом
языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают
процедуру получения этого результата. СУБД сама определяет способ выполнения
команды пользователя. В языке SQL традиционно выделяются группа операторов
определения данных (*Data Definition Language* — *DDL*), группа операторов
манипулирования данными (*Data Manipulation Language* — *DML*) и группа
операторов, управляющих привилегиями доступа к объектам базы данных (*Data
Control Language* — *DCL*).
* Основные операции с таблицами
Для создания таблиц в языке SQL служит команда ~CREATE TABLE~. Итак, команда для
создания нашей первой таблицы ~aircrafts~ такова:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  CREATE TABLE aircrafts(
    aircraft_code char(3) NOT NULL,
    model text NOT NULL,
    range integer NOT NULL,
    CHECK (range > 0),
    PRIMARY KEY (aircraft_code)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Значения всех атрибутов каждой строки данной таблицы должны быть определенными,
поэтому на них накладывается ограничение ~NOT NULL~. В принципе в таблицах базы
данных могут содержаться неопределенные значения некоторых атрибутов. Говоря
другими словами, их значения могут отсутствовать. В таких случаях в этих полях
содержится специальное значение ~NULL~.

К томуже атрибут ~range~ не должен принимать отрицательных значений и нулевого
значения, поэтому приходится добавить еще одно ограничение: ~range > 0~.

В качестве первичного ключа выбран атрибут ~aircraft_code~. Таким образом,
первичный ключ будет, как говорят, *естественным*. Это означает, что и в
реальной предметной области существует такое понятие, как код самолета, и это
понятие используется на практике. В отличие от естественных ключей иногда
используются и так называемые *суррогатные ключи*.

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d aircrafts
#+END_SRC

#+RESULTS:
#+begin_example
                   Table "public.aircrafts"
    Column     |     Type     | Collation | Nullable | Default
---------------+--------------+-----------+----------+---------
 aircraft_code | character(3) |           | not null |
 model         | text         |           | not null |
 range         | integer      |           | not null |
Indexes:
    "aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
Check constraints:
    "aircrafts_range_check" CHECK (range > 0)
Referenced by:
    TABLE "flights" CONSTRAINT "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    TABLE "seats" CONSTRAINT "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Для в вода данных в таблицу служит команда ~INSERT~. Давайте добавим одну строку
в таблицу ~aircrafts~.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range) VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC elixir :eval no :exports both
  %Aircraft{
    aircraft_code: "SU9",
    model: "Sukhoi SuperJet-100",
    range: 3000
  }
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:40:54.810 [debug] QUERY OK db=13.8ms decode=0.5ms queue=0.3ms idle=1.5ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3) ["SU9", "Sukhoi SuperJet-100", 3000]
: >>> :
: {:ok,
:  %AirDB.Aircraft{
:    __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:    aircraft_code: "SU9",
:    model: "Sukhoi SuperJet-100",
:    range: 3000,
:    seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:  }}

Давайте добавим еще несколько строк в таблицу ~aircrafts~. Команда ~INSERT~
позволяет сделать это за один раз.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range)
    VALUES ('773', 'Boeing 777-300', 11100),
           ('763', 'Boeing 767-300', 7900),
           ('733', 'Boeing 737-300', 4200),
           ('320', 'Airbus A320-200', 5700),
           ('321', 'Airbus A321-200', 5600),
           ('319', 'Airbus A319-100', 6700),
           ('CN1', 'Cessna 208 Caravan', 1200),
           ('CR2', 'Bombardier CRJ-200', 2700);
#+END_SRC

#+RESULTS:
: INSERT 0 8

#+BEGIN_SRC elixir :exports both :eval no
  Repo.insert_all(Aircraft, [
    %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
    %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
    %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
    %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
    %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
    %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
    %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
    %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
  ])
#+END_SRC

#+RESULTS:
: 13:37:23.199 [debug] QUERY OK db=3.4ms queue=0.5ms idle=28.0ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18),($19,$20,$21),($22,$23,$24) ["773", "Boeing 777-300", 11100, "763", "Boeing 767-300", 7900, "733", "Boeing 737-300", 4200, "320", "Airbus A320-200", 5700, "321", "Airbus A321-200", 5600, "319", "Airbus A319-100", 6700, "CN1", "Cessna 208 Caravan", 1200, "CR2", "Bombardier CRJ-200", 2700]
: >>> : {8, nil}

Давайте посмотрим, что содержится в таблице ~aircrafts~. Для этого служит
команда ~SELECT~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           733 | Boeing 737-300      |  4200 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           319 | Airbus A319-100     |  6700 |
|           CN1 | Cessna 208 Caravan  |  1200 |
|           CR2 | Bombardier CRJ-200  |  2700 |

#+BEGIN_SRC elixir :exports both :eval no
  select(Aircraft, [a], map(a, ^Aircraft.__schema__(:fields)))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 15:10:47.010 [debug] QUERY OK source="aircrafts" db=0.2ms decode=0.5ms queue=0.3ms idle=7.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 []
: >>> :
: [
:   %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3000},
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
: ]

Давайте упорядочим строки по значению атрибута ~model~, а заодно изменим порядок
расположения столбцов в выводе информации.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range FROM aircrafts ORDER BY model;
#+END_SRC

#+RESULTS:
| model               | aircraft_code | range |
|---------------------+---------------+-------|
| Airbus A319-100     |           319 |  6700 |
| Airbus A320-200     |           320 |  5700 |
| Airbus A321-200     |           321 |  5600 |
| Boeing 737-300      |           733 |  4200 |
| Boeing 767-300      |           763 |  7900 |
| Boeing 777-300      |           773 | 11100 |
| Bombardier CRJ-200  |           CR2 |  2700 |
| Cessna 208 Caravan  |           CN1 |  1200 |
| Sukhoi SuperJet-100 |           SU9 |  3000 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    order_by: a.model,
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> order_by([a], asc: a.model)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.211 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.8ms idle=16.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."model" []
: >>> :
: [
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3000}
: ]

Множество выбираемых строк можно ограничить с помощью предложения ~WHERE~
команды ~SELECT~. Давайте выберем модели самолетов, у которых максимальная
дальность полета находитсяв пределах от 4 до 6 тыс. км включительно. Условие
выбора строк может быть составным. В данном случае нужно скомбинировать два
ограничения с помощью логической операции ~AND~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range
    FROM aircrafts
   WHERE range >= 4000 AND range <= 6000;
#+END_SRC

#+RESULTS:
| model           | aircraft_code | range |
|-----------------+---------------+-------|
| Boeing 737-300  |           733 |  4200 |
| Airbus A320-200 |           320 |  5700 |
| Airbus A321-200 |           321 |  5600 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.range >= 4000 and a.range <= 6000,
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], a.range >= 4000 and a.range <= 6000)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.212 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.4ms idle=18.1ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE ((a0."range" >= 4000) AND (a0."range" <= 6000)) []
: >>> :
: [
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600}
: ]

Команда ~UPDATE~ предназначенна для обновления данных в таблицах. Условие,
указываемое в команде, должно ограничить диапазон обновляемых строк. Если это
условие не задать, то будут обновлены все строки в таблице.

Давайте предположим, что российские инженеры немного улучшили летные
характеристики самолета /Sukhoi SuperJet/, и теперь дальность его полета стала
на 500 км больше.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = 3500 WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "SU9"

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "SU9")
  |> Repo.update_all(set: [range: 3500])
#+END_SRC

#+RESULTS:
: 13:42:28.219 [debug] QUERY OK source="aircrafts" db=5.5ms queue=0.5ms idle=19.7ms
: UPDATE "aircrafts" AS a0 SET "range" = $1 WHERE (a0."aircraft_code" = 'SU9') [3500]
: >>> : {1, nil}

Давайте проверим, что получилось в результате обновления данных.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi SuperJet-100 |  3500 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "SU9",
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "SU9")
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.one()
#+END_SRC

#+RESULTS:
: 13:42:28.221 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.6ms idle=26.8ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'SU9') []
: >>> : %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3500}

Для удаления строк из таблиц используется команда ~DELETE~, которая похожа на
команду ~SELECT~. Удалим какую-нибудь одну строку из таблицы ~aircrafts~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
: DELETE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "CN1"

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "CN1")
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 13:42:28.226 [debug] QUERY OK source="aircrafts" db=4.2ms queue=0.4ms idle=28.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'CN1') []
: >>> : {1, nil}

Вы можете указать и какое-нибудь более сложное условие. Давайте, например,
удалим информацию о самолетах с дальностью полета более 10000 км, а также с
дальностью полета менее 3000 км:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE range > 10000 OR range < 3000;
#+END_SRC

#+RESULTS:
: DELETE 2

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.range > 10000 or a.range < 3000

  # macro example
  Aircraft
  |> where([a], a.range > 10000 or a.range < 3000)
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 14:03:41.612 [debug] QUERY OK source="aircrafts" db=4.5ms queue=0.5ms idle=39.0ms
: DELETE FROM "aircrafts" AS a0 WHERE ((a0."range" > 10000) OR (a0."range" < 3000)) []
: >>> : {2, nil}

При необходимости удаления всех строк из таблицы команда будет совсем простой:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts;
#+END_SRC

#+RESULTS:
: DELETE 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.delete_all(Aircraft)
#+END_SRC

#+RESULTS:
: 13:42:28.233 [debug] QUERY OK source="aircrafts" db=5.4ms queue=0.5ms idle=33.6ms
: DELETE FROM "aircrafts" AS a0 []
: >>> : {6, nil}

Теперь в таблице ~aircrafts~ нет ни одной строки.

Для таблицы ~aircrafts~ ближайшей «родственницей» является таблица ~seats~.

Значения атрибута ~fare_conditions~ могут выбираться из ограниченного списка
значений. Проверка на соответствие вводимых значений этому списку будет
обеспечиваться с помощью ограничения ~CHECK~.

В этой таблице используется *внешний ключ*. Предложение ~FOREIGN KEY~ создает
ограничение ссылочной целостности. В качестве внешнего ключа служит атрибут
~aircraft_code~. Он ссылается на одноименный атрибут в таблице ~aircrafts~.
Таблица ~seats~ называется *ссылающейся* (*referencing*), а таблица ~aircrafts~
— *ссылочной* (*referenced*).

Поскольку номера мест привязаны к модели самолета, то в случае удаления из
таблицы ~aircrafts~ какой-либо строки с конкретным кодом самолета необходимо
удалить также и из таблицы ~seats~ все строки, в которых значение атрибута
~aircraft_code~ такое же. Поэтому в предложении для определения внешнего ключа
появляется важное дополнение: ~ON DELETE CASCADE~. Это означает, что при
удалении какой-либо строки из таблицы ~aircrafts~ удаление строк из таблицы
~seats~, связанных с этой строкой по внешнему ключу, берет на себя СУБД,
избавляя программиста от этой заботы. Подобные действия, которые выполняет сама
СУБД, называются *каскадным удалением*. Таким образом, внешний ключ служит для
связи таблиц между собой.

Итак, команда для создания нашей второй таблицы ~seats~ такова:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  CREATE TABLE seats(
    aircraft_code char(3) NOT NULL,
    seat_no varchar(4) NOT NULL,
    fare_conditions varchar(10) NOT NULL,
    CHECK (fare_conditions IN ('Economy', 'Comfort', 'Business')),
    PRIMARY KEY (aircraft_code, seat_no),
    FOREIGN KEY (aircraft_code) REFERENCES aircrafts (aircraft_code) ON DELETE CASCADE
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d seats
#+END_SRC

#+RESULTS:
#+begin_example
                           Table "public.seats"
     Column      |         Type          | Collation | Nullable | Default
-----------------+-----------------------+-----------+----------+---------
 aircraft_code   | character(3)          |           | not null |
 seat_no         | character varying(4)  |           | not null |
 fare_conditions | character varying(10) |           | not null |
Indexes:
    "seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
Check constraints:
    "seats_fare_conditions_check" CHECK (fare_conditions::text = ANY (ARRAY['Economy'::text, 'Comfort'::text, 'Business'::text]))
Foreign-key constraints:
    "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Принципиально новым по сравнению с рассмотренной выше таблицей ~aircrafts~
является наличие ограничения внешнего ключа. Это ограничение имеет имя
~seats_aircraft_code_fkey~, сгенерированное самой СУБД. Давайте сразу же
проделаем эксперимент, позволяющий показать работу внешнего ключа. Выполните
следующую команду для ввода данных в таблицу ~seats~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES ('123', '1A', 'Business');
#+END_SRC

#+RESULTS:
: ERROR:  insert or update on table "seats" violates foreign key constraint "seats_aircraft_code_fkey"
: DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts".

#+BEGIN_SRC elixir :eval no :exports both
  Seat.changeset(%Seat{}, %{
    aircraft_code: "123",
    seat_no: "1A",
    fare_conditions: "Business"
  })
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:28:52.511 [debug] QUERY ERROR db=2.7ms queue=9.1ms idle=0.0ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3) ["123", "Business", "1A"]
: >>> :
: {:error,
:  #Ecto.Changeset<
:    action: :insert,
:    changes: %{aircraft_code: "123", fare_conditions: "Business", seat_no: "1A"},
:    errors: [
:      aircraft_code: {"does not exist",
:       [constraint: :foreign, constraint_name: "seats_aircraft_code_fkey"]}
:    ],
:    data: #AirDB.Seat<>,
:    valid?: false
:  >}

Теперь нужно заполнить данными таблицу ~seats~.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES
    ('SU9', '1A', 'Business'),
    ('SU9', '1B', 'Business'),
    ('SU9', '10A', 'Economy'),
    ('SU9', '10B', 'Economy'),
    ('SU9', '10F', 'Economy'),
    ('SU9', '20F', 'Economy');

  INSERT INTO seats VALUES
    ('773', '1A', 'Business'),
    ('773', '1B', 'Business'),
    ('773', '10A', 'Economy'),
    ('773', '10B', 'Economy'),
    ('773', '10F', 'Economy'),
    ('773', '20F', 'Economy');
#+END_SRC

#+RESULTS:
: INSERT 0 6
: INSERT 0 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "SU9", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.521 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["SU9", "Business", "1A", "SU9", "Business", "2B", "SU9", "Economy", "10A", "SU9", "Economy", "10B", "SU9", "Economy", "10F", "SU9", "Economy", "20F"]
: >>> : {6, nil}

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "773", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.601 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["773", "Business", "1A", "773", "Business", "2B", "773", "Economy", "10A", "773", "Economy", "10B", "773", "Economy", "10F", "773", "Economy", "20F"]
: >>> : {6, nil}

Теперь решим еще одну задачу. Предположим, что нам нужно получить информацию о
количестве мест в салонах для всех типов самолетов. Конечно, для решения задачи,
поставленной выше, в принципе можно воспользоваться такими командами:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    where: s.aircraft_code == "SU9"

  # macro example
  Seat
  |> where([s], s.aircraft_code == "SU9")
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 14:33:18.421 [debug] QUERY OK source="seats" db=0.3ms decode=0.4ms queue=0.5ms idle=3.0ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'SU9') []
: >>> : 6

И похожими для всех остальных самолетов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    where: s.aircraft_code == "CN1"

  # macro example
  Seat
  |> where([s], s.aircraft_code == "CN1")
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 14:33:18.427 [debug] QUERY OK source="seats" db=0.5ms queue=0.7ms idle=13.5ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'CN1') []
: >>> : 0

Очевидно, что это нерациональный подход. Язык SQL позволяет упростить решение
такой задачи за счет применения операции группирования строк на основе
некоторого критерия. В модифицированной команде вместо предложения ~WHERE~ будет
добавлено предложение ~GROUP BY~, которое отвечает за группировку строк с
одинаковыми значениями атрибута ~aircraft_code~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |
| 773           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: s.aircraft_code,
    select: %{aircraft_code: s.aircraft_code, count: count()}

  # macro example
  Seat
  |> group_by([s], s.aircraft_code)
  |> select([s], %{aircraft_code: s.aircraft_code, count: count()})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.428 [debug] QUERY OK source="seats" db=0.4ms queue=0.5ms idle=14.9ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" []
: >>> : [%{aircraft_code: "SU9", count: 6}]

Если мы захотим отсортировать выборку по числу мест в самолетах, то нужно будет
дополнить команду предложением ~ORDER BY~, которое обеспечит сортировку
результирующих строк по значениям второго столбца.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code
   ORDER BY count;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: s.aircraft_code,
    order_by: selected_as(:count),
    select: %{aircraft_code: s.aircraft_code, count: selected_as(count(), :count)}

  # macro example
  Seat
  |> group_by([s], s.aircraft_code)
  |> order_by(selected_as(:count))
  |> select([s], %{aircraft_code: s.aircraft_code, count: selected_as(count(), :count)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.429 [debug] QUERY OK source="seats" db=0.4ms queue=0.6ms idle=16.1ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" ORDER BY count []
: >>> : [%{aircraft_code: "SU9", count: 6}]

Теперь поставим более сложную задачу: подсчитать количество мест в салонах для
всех моделей самолетов, но теперь уже с учетом класса обслуживания (бизнес-класс
и экономический класс). В этом случае группировка выполняется уже по двум
атрибутам: ~aircraft_code~ и ~fare_conditions~. Отсортируем выборку по тем же
столбцам, по которым выполняли группировку.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         fare_conditions,
         count(*)
    FROM seats
   GROUP BY aircraft_code, fare_conditions
   ORDER BY aircraft_code, fare_conditions;
#+END_SRC

#+RESULTS:
| aircraft_code | fare_conditions | count |
|---------------+-----------------+-------|
| SU9           | Business        |     2 |
| SU9           | Economy         |     4 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: [s.aircraft_code, s.fare_conditions],
    order_by: [s.aircraft_code, s.fare_conditions],
    select: %{aircraft_code: s.aircraft_code, fare_condition: s.fare_conditions, count: count()}

  # macro example
  Seat
  |> group_by([s], [s.aircraft_code, s.fare_conditions])
  |> order_by([s], [s.aircraft_code, s.fare_conditions])
  |> select([s], %{
    aircraft_code: s.aircraft_code,
    fare_condition: s.fare_conditions,
    count: count()
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.431 [debug] QUERY OK source="seats" db=0.4ms queue=0.8ms idle=17.5ms
: SELECT s0."aircraft_code", s0."fare_conditions", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code", s0."fare_conditions" ORDER BY s0."aircraft_code", s0."fare_conditions" []
: >>> :
: [
:   %{aircraft_code: "SU9", count: 2, fare_condition: "Business"},
:   %{aircraft_code: "SU9", count: 4, fare_condiiton: "Economy"}
: ]
** Контрольные вопросы и задания
*** Вопрос 1
Попробуйте ввести в таблицу ~aircrafts~ строку с таким значением атрибута «Код
самолета» (~aircraft_code~), которое вы уже вводили, например:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO aircrafts VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

Вы получите сообщение об ошибке:

#+RESULTS:
: ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
: DETAIL:  Key (aircraft_code)=(SU9) already exists.

Обратите внимание, что в этой команде мы не привели список атрибутов, что вполне
допустимо при задании значений атрибутов в том же порядке, в котором атрибуты
следуют в определении таблицы. Но в ваших прикладных программах так поступать
все же не следует, поскольку в случае возможной реструктуризации таблицы и
изменения порядка следования атрибутов в ней ваши команды ~INSERT~ могут
перестать работать корректно.

Подумайте, почему появилось сообщение. Если вы забыли структуру таблицы
~aircrafts~, то можно вывести ее определение на экран с помощью команды ~\d
aircrafts~.

*ОТВЕТ*: Нарушен констрейнт - ~Key (aircraft_code)=(SU9) already exists~.
*** Вопрос 2
Предложение ~ORDER BY~ команды ~SELECT~ позволяет отсортировать данные при
выводе. По умолчанию сортировка выполняется по возрастанию значений атрибута,
указанного в этом предложении. Но можно упорядочить строки и по убыванию
значения атрибута. Для этого нужно после имени атрибута в предложении ~ORDER BY~
добавить ключевое слово ~DESC~ (это сокращение от слова /descendant/ — убывающий
порядок). Самостоятельно напишите команду для выборки всех строк из таблицы
~aircrafts~, чтобы строки были упорядочены по убыванию значения атрибута
«Максимальная дальность полета, км» (~range~).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts ORDER BY range DESC;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           319 | Airbus A319-100     |  6700 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           733 | Boeing 737-300      |  4200 |
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           CR2 | Bombardier CRJ-200  |  2700 |
|           CN1 | Cessna 208 Caravan  |  1200 |

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      order_by: [desc: a.range],
      select: map(a, [:aircraft_code, :model, :range])

  Repo.all(query)
#+END_SRC

#+RESULTS:
: 16:37:27.091 [debug] QUERY OK source="aircrafts" db=0.3ms queue=0.4ms idle=1772.2ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."range" DESC []
: >>> :
: [
  : %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
  : %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
  : %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
  : %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
  : %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
  : %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
  : %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
  : %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
  : %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200}
: ]
*** Вопрос 3
Команда ~UPDATE~ позволяет в процессе обновления выполнять арифметические
действия над значениями, находящимися в строках таблицы. Представим себе, что
двигатели самолета /Sukhoi SuperJet/ стали в два раза экономичнее, вследствие
чего дальность полета этого лайнера возросла ровно в два раза. Команда ~UPDATE~
позволяет увеличить значение атрибута ~range~ в строке, хранящей информацию об
этом самолете, даже не выполняя предварительно выборку с целью выяснения
текущего значения этого атрибута. При присваивании нового значения атрибуту
~range~ можно справа от знака ~=~ написать не только числовую константу, но и
целое выражение. В нашем случае оно будет простым: ~range = range * 2~.
Самостоятельно напишите команду ~UPDATE~ полностью, при этом не забудьте, что
увеличить дальность полета нужно только у одной модели — /Sukhoi SuperJet/,
поэтому необходимо использовать условие ~WHERE~. Затем с помощью команды
~SELECT~ проверьте полученный результат.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = range * 2 WHERE aircraft_code = 'SU9';
  SELECT range FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1
: range
: 6000

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      where: a.aircraft_code == "SU9",
      update: [set: [range: fragment("range * 2")]]

  Repo.update_all(query, [])
#+END_SRC

#+RESULTS:
: 16:41:34.417 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.2ms idle=1098.1ms
: UPDATE "aircrafts" AS a0 SET "range" = range * 2 WHERE (a0."aircraft_code" = 'SU9') []
: >>> : {0, nil}
*** Вопрос 4
Если в предложении ~WHERE~ команды ~DELETE~ вы укажете логически и синтаксически
корректное условие, но строк, удовлетворяющих этому условию, в таблице не
окажется, то в ответ СУБД выведет сообщение ~DELETE 0~.

Такая ситуация не является ошибкой или сбоем в работе СУБД. Например, если после
удаления какой-то строки вы повторно попытаетесь удалить ее же, то получите
именно такое сообщение. Самостоятельно смоделируйте описанную ситуацию, подобрав
условие, которому гарантированно не соответствует ни одна строка в таблице
«Самолеты» (~aircrafts~).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'XXX';
#+END_SRC

#+RESULTS:
: DELETE 0

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      where: a.aircraft_code == "XXX"

  Repo.delete_all(query)
#+END_SRC

#+RESULTS:
: 16:49:32.082 [debug] QUERY OK source="aircrafts" db=0.4ms idle=1764.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'XXX') []
: >>> : {0, nil}
* Типы данных СУБД PostgreSQL
** Числовые типы
Группа числовых типов данных включает в себя целый ряд разновидностей:
целочисленные типы, числа фиксированной точности, типы данных с плавающей
точкой, последовательные типы (~serial~).

В составе целочисленных типов находятся следующие представители: ~smallint~,
~integer~, ~bigint~. Если атрибут таблицы имеет один из этих типов, то он
позволяет хранить только целочисленные данные. При этом перечисленные типы
различаются по количеству байтов, выделяемых для хранения данных. В PostgreSQL
существуют псевдонимы для этих стандартизированных имен типов, а именно: ~int2~,
~int4~ и ~int8~. Число байтов отражается в имени типа.

Числа фиксированной точности представлены двумя типами — ~numeric~ и ~decimal~.
Однако они являются идентичными по своим возможностям. Числа типа ~numeric~
могут хранить очень большое количество цифр: 131072 цифры — до десятичной точки
(запятой), 16383 — после точки. Его главное достоинство — это обеспечение
/точных/ результатов при выполнении вычислений, когда это, конечно, возможно в
принципе. Для задания значения этого типа используются два базовых понятия:
*масштаб* (*scale*) и *точность* (*precision*). Масштаб показывает число
значащих цифр, стоящих справа от десятичной точки (запятой). Точность указывает
общее число цифр как до десятичной точки, так и после нее. Параметры этого типа
данных указываются в круглых скобках после имени типа: ~numeric(точность,
масштаб)~.

Представителями типов данных с плавающей точкой являются типы ~real~ и ~double
precision~. Они представляют собой реализацию стандарта IEEE «Standard 754 for
Binary Floating-Point Arithmetic». Тип данных ~real~ может представить числа в
диапазоне, как минимум, от 1E−37 до 1E+37 с точностью не меньше 6 десятичных
цифр. Тип ~double precision~ имеет диапазон значений примерно от 1E−307 до
1E+308 с точностью не меньше 15 десятичных цифр.

При попытке записать в такой столбец слишком большое или слишком маленькое
значение будет генерироваться ошибка. Если точность вводимого числа выше
допустимой, то будет иметь место округление значения. А вот при вводе очень
маленьких чисел, которые невозможно представить значениями, отличными от нуля,
будет генерироваться *ошибка потери значимости*, или исчезновения значащих
разрядов (*an underflow error*).

При работе с числами таких типов нужно помнить, что сравнение двух чисел с
плавающей точкой на предмет равенства их значений может привести к неожиданным
результатам:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 0.1::real * 10 = 1.0::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| f        |

В дополнение к обычным числам эти типы данных поддерживают и специальные
значения ~Infinity~ (бесконечность), ~−Infinity~ (отрицательная бесконечность) и
~NaN~ (нечисло).

PostgreSQL поддерживает также тип данных ~float~, определенный в стандарте SQL.
В объявлении типа может использоваться параметр: ~float(p)~. Если его значение
лежит в диапазоне от 1 до 24, то это будет равносильно использованию типа
~real~, а если же значение лежит в диапазоне от 25 до 53, то это будет
равносильно использованию типа ~double precision~. Если же при объявлении типа
параметр не используется, то это также будет равносильно использованию типа
~double precision~.

Последним из числовых типов является тип ~serial~. Однако он фактически
реализован не как настоящий тип, а просто как удобная замена целой группы
SQL-команд. Тип ~serial~ удобен в тех случаях, когда требуется в какой-либо
столбец вставлять уникальные целые значения, например, значения суррогатного
первичного ключа. Кроме типа ~serial~ существуют еще два аналогичных типа:
~bigserial~ и ~smallserial~. Им фактически, за кадром, соответствуют типы
~bigint~ и ~smallint~.
** Символьные (строковые) типы
Стандартные представители строковых типов — это типы ~character varying(n)~ и
~character(n)~, где параметр указывает максимальное число символов в строке,
которую можно сохранить в столбце такого типа. При работе с многобайтовыми
кодировками символов, например UTF-8, нужно учитывать, что речь идет о символах,
а не о байтах. Если сохраняемая строка символов будет короче, чем указано в
определении типа, то значение типа ~character~ будет дополнено пробелами до
требуемой длины, а значение типа ~character varying~ будет сохранено так, как
есть. Типы ~character varying(n)~ и ~character(n)~ имеют псевдонимы ~varchar(n)~
и ~char(n)~ соответственно.

PostgreSQL дополнительно предлагает еще один символьный тип — ~text~. В столбец
этого типа можно ввести сколь угодно большое значение, конечно, в пределах,
установленных при компиляции исходных текстов СУБД.

Константы символьных типов в SQL-командах заключаются в одинарные кавычки. В том
случае, когда в константе содержится символ одинарной кавычки или обратной косой
черты, их необходимо удваивать.

В том случае, когда таких символов в константе много, все выражение становится
трудно воспринимать. На помощь может прийти использование удвоенного символа
«$». Эти символы выполняют ту же роль, что и одинарные кавычки, когда в них
заключается строковая константа. При использовании символов «$» в качестве
ограничителей уже не нужно удваивать никакие символы, содержащиеся в самой
константе: ни одинарные кавычки, ни символы обратной косой черты.

PostgreSQL предлагает еще одно расширение стандарта SQL — строковые константы в
стиле языка C. Чтобы иметь возможность их использовать, нужно перед начальной
одинарной кавычкой написать символ «E». При использовании C-стиля необходимо
удваивать обратную косую черту, если требуется поместить ее в константу
буквально. А для включения в содержимое константы символа обратной кавычки можно
либо удвоить ее, либо спрятать за обратной косой чертой.
** Типы «дата/время»
Даты обрабатываются в соответствии с григорианским календарем, причем это
делается даже в тех случаях, когда дата относится к тому моменту времени, когда
этот календарь в данной стране еще не был принят.

Начнем рассмотрение с типа ~date~. Рекомендуемый стандартом ISO 8601 формат
ввода дат таков: ~yyyy-mm-dd~, где символы ~y~, ~m~ и ~d~ обозначают цифру года,
месяца и дня соответственно. При выводе значений PostgreSQL использует формат по
умолчанию, если не предписан другой формат. По умолчанию используется формат,
рекомендуемый стандартом ISO 8601: ~yyyy-mm-dd~.

Для получения значения текущей даты служит функция ~current_date~. Ее
особенностью является то, что при ее вызове круглые скобки не используются.
Текущее время выводится с высокой точностью и дополняется числовым значением,
соответствующим локальному часовому поясу, который установлен в конфигурационном
файле сервера.

Если нам требуется вывести дату в другом формате, то для разового преобразования
формата можно использовать функцию ~to_char(date, 'dd-mm-yyyy');~

Для хранения времени суток служат два типа данных: ~time~ и ~time with time
zone~. Первый из них хранит только время суток, а второй — дополнительно — еще и
часовой пояс. Однако документация на PostgreSQL не рекомендует использовать тип
~time with time zone~, поскольку *смещение* (*offset*), соответствующее
конкретному часовому поясу, может зависеть от даты перехода на летнее время и
обратно, но в этом типе дата отсутствует. Время можно вводить не только в
24-часовом формате, но и в 12-часовом, при этом нужно использовать
дополнительные суффиксы ~am~ и ~pm~.

Для получения значения текущего времени служит функция ~current_time~. Она также
вызывается без указания круглых скобок.

В результате объединения типов даты и времени получается интегральный тип —
временная отметка. Этот тип существует в двух вариантах: с учетом часового пояса
— ~timestamp with time zone~, либо без учета часового пояса — ~timestamp~. Для
первого варианта существует сокращенное наименование — ~timestamptz~. Оба типа
занимают один и тот же объем 8 байтов, но значения типа ~timestamptz~ хранятся,
будучи приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся
к часовому поясу пользователя.

Для получения значения текущей временной отметки (т.е. даты и времени в одном
значении) служит функция ~current_timestamp~. Она также вызывается без указания
круглых скобок.

Последним типом является ~interval~, который представляет продолжительность
отрезка времени между двумя моментами времени. Его формат ввода таков: ~quantity
unit [quantity unit ...] direction~. Можно использовать альтернативный формат,
предлагаемый стандартом ISO 8601: ~P [ years-months-days ] [ T hours:minutes:seconds ]~

Здесь ~unit~ означает единицу измерения, а ~quantity~ — количество таких единиц.
В качестве единиц измерения можно использовать следующие: ~microsecond~,
~millisecond~, ~second~, ~minute~, ~hour~, ~day~, ~week~, ~month~, ~year~,
~decade~, ~century~, ~millennium~. Параметр ~direction~ может принимать значение
~ago~ (т.е. «тому назад») либо быть пустым.

Поскольку интервал — это отрезок времени между двумя временными отметками, то
значение этого типа можно получить при вычитании одной временной отметки из
другой.

Значения временных отметок можно усекать с той или иной точностью с помощью
функции ~date_trunc(точность, время)~.

Из значений временных отметок можно с помощью функции ~extract(поле FROM время)~
извлекать отдельные поля, т.е. год, месяц, день, число часов, минут или секунд и
т.д
** Логический тип
Логический (~boolean~) тип может принимать три состояния: истина и ложь, а также
неопределенное состояние, которое можно представить значением ~NULL~. Таким
образом, тип ~boolean~ реализует трехзначную логику.

В качестве истинного состояния могут служить следующие значения: ~TRUE~, ~'t'~,
~'true'~, ~'y'~, ~'yes'~, ~'on'~, ~'1'~.

В качестве ложного состояния могут служить следующие значения: ~FALSE~, ~'f'~,
~'false'~, ~'n'~, ~'no'~, ~'off'~, ~'0'~.
** Массивы
*TODO* продублировать запросы используя Ecto

Массивы могут быть многомерными и могут содержать значения любого из встроенных
типов, а также типов данных, определенных пользователем. Массив в команде
вставки представленв виде строкового литерала с указанием типа данных и
квадратных скобок, означающих массив.

Предположим, что нам необходимо сформировать и сохранить в базе данных в удобной
форме графики работы пилотов авиакомпании, т.е. номера дней недели, когда они
совершают полеты.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE pilots (pilot_name text, schedule integer[]);
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots
         VALUES ('Ivan',  '{1, 3, 5, 6, 7}'::integer[]),
                ('Petr',  '{1, 2, 5, 7}'::integer[]),
                ('Pavel', '{2, 5}'::integer[]),
                ('Boris', '{3, 5, 6}'::integer[]);
#+END_SRC

#+RESULTS:
: INSERT 0 4

Предположим, что руководство компании решило, что каждый пилот должен летать 4
раза в неделю. Значит, нам придется обновить значения в таблице. Пилоту по имени
Boris добавим один день с помощью операции конкатенации ~||~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = schedule || 7
   WHERE pilot_name ='Boris';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {2,5,6}     |
| Petr       | {1,2,5,7}   |

Пилоту по имени Pavel добавим один день в конец списка (массива) с помощью
функции ~array_append~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_append(schedule, 6)
   WHERE pilot_name ='Pavel';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {2,5,6}     |
| Petr       | {1,2,5,7}   |

Ему же добавим один день в начало списка с помощью функции ~array_prepend~
(обратите внимание, что параметры функции поменялись местами):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_prepend(1, schedule)
   WHERE pilot_name = 'Pavel';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {1,2,5,6}   |
| Petr       | {1,2,5,7}   |

У пилота по имени Ivan имеется лишний день в графике. С помощью функции
~array_remove~ удалим из графика пятницу (второй параметр функции указывает
значение элемента массива, а не индекс):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_remove(schedule, 5)
   WHERE pilot_name = 'Ivan';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {1,2,5,7} |

У пилота по имени Petr изменим дни полетов, не изменяя их общего количества.
Воспользуемся индексами для работы на уровне отдельных элементов массива. По
умолчанию нумерация индексов начинается *с единицы*, а не с нуля. При
необходимости ее можно изменить. К элементам одного и того же массива можно
обращаться в предложении ~SET~ по отдельности, как будто это разные столбцы.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule[1] = 2,
         schedule[2] = 3
   WHERE pilot_name = 'Petr';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

А можно было бы, используя *срез* (*slice*) массива, сделать и так:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule[1:2] = ARRAY[2, 3]
   WHERE pilot_name = 'Petr';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

Теперь продемонстрируем основные операции, которые можно применять к массивам,
выполняя выборки из таблиц.

Функция ~array_position~ возвращает индекс первого вхождения элемента с
указанным значением в массив. Если же такого элемента нет, она возвратит ~NULL~.
Получим список пилотов, летающих по средам:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE array_position(schedule, 3) IS NOT NULL;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Petr       | {2,3,5,7} |

Оператор ~@>~ означает проверку того факта, что в левом массиве содержатся все
элементы правого массива. Конечно, при этом в левом массиве могут находиться и
другие элементы. Выберем пилотов, летающих по понедельникам и воскресеньям:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE schedule @> '{1, 7}'::integer[];
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Ivan       | {1,3,6,7} |

Еще аналогичный вопрос: кто летает по вторникам и/или по пятницам? Для получения
ответа воспользуемся оператором ~&&~, который проверяет наличие общих элементов
у массивов, т.е. пересекаются ли их множества значений.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE schedule && ARRAY[2, 5];
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

Сформулируем вопрос в форме отрицания: кто не летает ни во вторник, ни в
пятницу?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE NOT (schedule && ARRAY[2, 5]);
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Ivan       | {1,3,6,7} |

Иногда требуется развернуть массив в виде столбца таблицы. В таком случае
поможет функция ~unnest~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT unnest(schedule) AS days_of_week
    FROM pilots
   WHERE pilot_name = 'Ivan';
#+END_SRC

#+RESULTS:
| days_of_week |
|--------------|
|            1 |
|            3 |
|            6 |
|            7 |
** Типы JSON
*TODO* продублировать запросы используя Ecto

Типы JSON предназначены для сохранения в столбцах таблиц базы данных таких
значений, которые представлены в формате /JSON/ (JavaScript Object Notation).
Существует два типа: ~json~ и ~jsonb~. Основное различие между ними заключается
в быстродействии. Если столбец имеет тип ~json~, тогда сохранение значений
происходит быстрее, потому что они записываются в том виде, в котором были
введены. Но при последующем использовании этих значений в качестве операндов или
параметров функций будет каждый раз выполняться их разбор, что замедляет работу.
При использовании типа ~jsonb~ разбор производится однократно, при записи
значения в таблицу. Это несколько замедляет операции вставки строк, в которых
содержатся значения данного типа. Но все последующие обращения к сохраненным
значениям выполняются быстрее, т.к. выполнять их разбор уже не требуется.

Есть еще ряд отличий, в частности, тип ~json~ сохраняет порядок следования
ключей в объектах и повторяющиеся значения ключей, а тип ~jsonb~ этого не
делает. Рекомендуется в приложениях использовать тип ~jsonb~, если только нет
какихто особых аргументов в пользу выбора типа ~json~.

Для иллюстрации использования типов JSON обратимся к тематике авиаперевозок.
Разработчики базы данных авиакомпании получили задание создать специальную
таблицу, в которую будут заноситься сведения о тех видах спорта, которыми
занимается пилот, будет отмечаться наличие у него домашней библиотеки, а также
фиксироваться количество стран, которые он посетил в ходе туристических поездок.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE pilot_hobbies(pilot_name text, hobbies jsonb);
  INSERT INTO pilot_hobbies
    VALUES ('Ivan',  '{"sports": ["футбол", "плавание"], "home_lib": true, "trips": 3}'::jsonb),
           ('Petr',  '{"sports": ["теннис", "плавание"],"home_lib": true, "trips": 2}'::jsonb),
           ('Pavel', '{"sports": ["плавание"], "home_lib": false, "trips": 4}'::jsonb),
           ('Boris', '{"sports": ["футбол", "плавание", "теннис"],"home_lib": true, "trips": 0}'::jsonb);
#+END_SRC

#+RESULTS:
: CREATE TABLE
: INSERT 0 4

Предположим, что нужно сформировать футбольную сборную команду нашей
авиакомпании для участия в турнире. Мы можем выбрать всех футболистов таким
способом:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilot_hobbies
   WHERE hobbies @> '{"sports": ["футбол"]}'::jsonb;
#+END_SRC

#+RESULTS:
| pilot_name | hobbies                                                                    |
|------------+----------------------------------------------------------------------------|
| Ivan       | {"trips": 3, "sports": ["футбол", "плавание"], "home_lib": true}           |
| Boris      | {"trips": 0, "sports": ["футбол", "плавание", "теннис"], "home_lib": true} |

Можно было эту задачу решить и таким способом. Операция ~->~ служит для
обращения к конкретному ключу JSON-объекта. В этом решении мы выводим только
информацию о спортивных предпочтениях пилотов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies -> 'sports' AS sports
    FROM pilot_hobbies
   WHERE hobbies->'sports' @> '["футбол"]'::jsonb;
#+END_SRC

#+RESULTS:
| pilot_name | sports                           |
|------------+----------------------------------|
| Ivan       | ["футбол", "плавание"]           |
| Boris      | ["футбол", "плавание", "теннис"] |

Как можно проверить наличие ключа? Продемонстрируем это:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM pilot_hobbies
   WHERE hobbies ? 'sport';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

А вот ключ ~sports~ присутствует. Выполним ту же проверку:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM pilot_hobbies
   WHERE hobbies ? 'sports';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     4 |

А как выполнять обновление JSON-объектов в строках таблицы? Предположим, что
пилот по имени Boris решил посвятить себя только хоккею. Тогда в базе данных мы
выполним такую операцию:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = hobbies || '{"sports": ["хоккей"]}'
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports results :eval no
  SELECT pilot_name, hobbies
    FROM pilot_hobbies
   WHERE pilot_name = 'Boris';
#+END_SRC

Проверим, что получилось:

#+RESULTS:
| pilot_name | hobbies                                              |
|------------+------------------------------------------------------|
| Boris      | {"trips": 0, "sports": ["хоккей"], "home_lib": true} |

Если впоследствии Boris захочет возобновить занятия футболом, то с помощью
функции ~jsonb_set~ можно будет обновить сведения о нем в таблице:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"')
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
: UPDATE 1

Второй параметр функции указывает путь в пределах JSON-объекта, куда нужно
добавить новое значение. В данном случае этот путь состоит из имени ключа
(~sports~) и номера добавляемого элемента в массиве видов спорта (номер 1).
Нумерация элементов начинается с нуля. Третий параметр имеет тип ~jsonb~,
поэтому его литерал заключается в одинарные кавычки, а само добавляемое значение
берется в двойные кавычки. В результате получается — ~'"футбол"'~.

Проверим успешность выполнения этой операции:

#+BEGIN_SRC sql :engine postgres :exports results :eval no
  SELECT pilot_name, hobbies
    FROM pilot_hobbies
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
| pilot_name | hobbies                                                        |
|------------+----------------------------------------------------------------|
| Boris      | {"trips": 0, "sports": ["хоккей", "футбол"], "home_lib": true} |
** Контрольные вопросы и задания
*** Вопрос 1
Создайте таблицу, содержащую атрибут типа ~numeric(precision, scale)~. Пусть это
будет таблица, содержащая результаты каких-то измерений. Команда может быть,
например, такой:

src_sql[:exports code]{CREATE TABLE test_numeric(measurement numeric(5, 2),
description text);}

Попробуйте с помощью команды ~INSERT~ продемонстрировать округление вводимого
числа до той точности, которая задана при создании таблицы. Подумайте, какая из
следующих команд вызовет ошибку и почему? Проверьтесвои предположения, выполнив
эти команды.
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9999,
  'Какое-то измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9009, 'Еще
  одно измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.1111, 'И еще
  измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (998.9999, 'И еще
  одно');}

Продемонстрируйте генерирование ошибки при попытке ввода числа, количество цифр
в котором слева от десятичной точки (запятой) превышает допустимое.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP table test_numeric;
  CREATE TABLE test_numeric(measurement numeric(5, 2), description text);
  -- INSERT INTO test_numeric VALUES (999.9999, 'Какое-то измерение');
  INSERT INTO test_numeric VALUES (999.9009, 'Еще одно измерение');
  INSERT INTO test_numeric VALUES (999.1111, 'И еще измерение');
  INSERT INTO test_numeric VALUES (998.9999, 'И еще одно');
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_numeric;
#+END_SRC

#+RESULTS:
| measurement | description        |
|-------------+--------------------|
|      999.90 | Еще одно измерение |
|      999.11 | И еще измерение    |
|      999.00 | И еще одно         |

src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9999, 'Какое-то
 измерение');} вызывает переполнение типа:

: ERROR:  numeric field overflow
: DETAIL:  A field with precision 5, scale 2 must round to an absolute value less than 10^3.
*** Вопрос 2
Предположим, что возникла необходимость хранить в одном столбце таблицы данные,
представленные с различной точностью. Это могут быть, например, результаты
физических измерений разнородных показателей или различные медицинские
показатели здоровья пациентов (результаты анализов). В таком случае можно
использовать тип ~numeric~ без указания масштаба и точности.

Команда для создания таблицы может быть, например, такой:

src_sql[:exports code]{CREATE TABLE test_numeric(measurement numeric,
description text);}

Если у вас в базе данных уже есть таблица с таким же именем, то можно
предварительно ее удалить с помощью команды:

src_sql[:exports code]{DROP TABLE test_numeric;}

Вставьте в таблицу несколько строк:
- src_sql[:exports code]{INSERT INTO test_numeric VALUES
  (1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (1.5, 'Точность 2
  знака, масштаб 1 знак');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES
  (0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (1234567890,
  'Точность 10 знаков, масштаб 0 знаков (целое число)');}

Теперь сделайте выборку из таблицы и посмотрите, что все эти
разнообразныезначения сохранены именно в том виде, как вы их вводили.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP table test_numeric;
  CREATE TABLE test_numeric(measurement numeric, description text);
  INSERT INTO test_numeric VALUES (1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков');
  INSERT INTO test_numeric VALUES (1.5, 'Точность 2 знака, масштаб 1 знак');
  INSERT INTO test_numeric VALUES (0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков');
  INSERT INTO test_numeric VALUES (1234567890, 'Точность 10 знаков, масштаб 0 знаков (целое число)');
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_numeric;
#+END_SRC

#+RESULTS:
|            measurement | description                                        |
|------------------------+----------------------------------------------------|
|  1234567890.0987654321 | Точность 20 знаков, масштаб 10 знаков              |
|                    1.5 | Точность 2 знака, масштаб 1 знак                   |
| 0.12345678901234567890 | Точность 21 знак, масштаб 20 знаков                |
|             1234567890 | Точность 10 знаков, масштаб 0 знаков (целое число) |
*** Вопрос 3
Тип данных ~numeric~ поддерживает специальное значение ~NaN~, которое означает
/not a number/. В документации утверждается, что значение ~NaN~ считается равным
другому значению ~NaN~, а также что значение ~NaN~ считается большим любого
другого «нормального» значения, т.е. ~не-NaN~. Проверьте эти утверждения с
помощью SQL-команды ~SELECT~. В качестве примера приведем команду:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric > 10000;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric = 'NaN'::numeric;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric > 10^99999::numeric;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

   #+BEGIN_SRC sql :engine postgres :exports both :eval no
     SELECT 0.1::real * 10 = 1.0::real;
   #+END_SRC
* Схема базы
** Миграции
#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Repo.Migrations.AddsAircraftsTable do
    use Ecto.Migration

    def change do
      create table(:aircrafts, primary_key: false, comment: "Aircrafts") do
        add :aircraft_code, :char, size: 3, primary_key: true, comment: "Aircraft code, IATA"
        add :model, :text, null: false, comment: "Aircraft model"
        add :range, :integer, null: false, comment: "Maximal flying distance, km"
      end

      create constraint(:aircrafts, "aircrafts_range_check", check: "range > 0", comment: "range should be greater than 0")
    end
  end

  defmodule AirDB.Repo.Migrations.AddsAirportsTable do
    use Ecto.Migration

    def change do
      create table(:airports, primary_key: false, comment: "Airports") do
        add :airport_code, :char, size: 3, primary_key: true, comment: "Airport code"
        add :airport_name, :text, null: false, comment: "Airport name"
        add :city, :text, null: false, comment: "City"
        add :coordinates, :point, null: false, comment: "Airport coordinates (longitude and latitude)"
        add :timezone, :text, null: false, comment: "Airport time zone"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsBookingsTable do
    use Ecto.Migration

    def change do
      create table(:bookings, primary_key: false, comment: "Bookings") do
        add :book_ref, :char, size: 6, primary_key: true, comment: "Booking number"
        add :book_date, :timestamptz, null: false, comment: "Booking date"
        add :total_amount, :numeric, null: false, precision: 10, scale: 2, comment: "Total booking cost"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsFlightsTable do
    use Ecto.Migration

    def up do
      create table(:flights, primary_key: false, comment: "Flights") do
        add :flight_id, :integer, primary_key: true, comment: "Flight ID"
        add :flight_no, :char, size: 6, null: false, comment: "Flight number"
        add :scheduled_departure, :timestamptz, null: false, comment: "Scheduled departure time"
        add :scheduled_arrival, :timestamptz, null: false, comment: "Scheduled arrival time"

        add :departure_airport_code,
          references(:airports, column: :airport_code, type: :char),
          size: 3,
          null: false,
          comment: "Airport of departure"

        add :arrival_airport_code,
          references(:airports, column: :airport_code, type: :char),
          size: 3,
          null: false,
          comment: "Airport of arrival"

        add :status, :varchar, size: 20, null: false, comment: "Flight status"

        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char),
          size: 3,
          null: false,
          comment: "Aircraft code, IATA"

        add :actual_departure, :timestamptz, comment: "Actual departure time"
        add :actual_arrival, :timestamptz, comment: "Actual arrival time"
      end

      create constraint(
        :flights,
        "flights_arrival_time_check",
        check: "scheduled_arrival > scheduled_departure"
      )

      create constraint(
        :flights,
        "flights_actual_arrival_time_check",
        check: "actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure"
      )

      create constraint(
        :flights,
        "flights_status_check",
        check: "status = ANY(ARRAY['On Time', 'Delayed', 'Departed', 'Arrived', 'Scheduled', 'Cancelled'])"
      )

      create unique_index(:flights, [:flight_no, :scheduled_departure])

      execute ~S"""
      ALTER TABLE flights
        ADD CONSTRAINT "flights_flight_no_scheduled_departure_index"
          UNIQUE USING INDEX "flights_flight_no_scheduled_departure_index"
      """
    end

    def down do
      drop table(:flights)
    end
  end

  defmodule AirDB.Repo.Migrations.AddsFlightsView do
    use Ecto.Migration

    def up do
      execute """
      CREATE VIEW flights_v AS
       SELECT f.flight_id,
              f.flight_no,
              f.scheduled_departure,
              timezone(dep.timezone, f.scheduled_departure) AS scheduled_departure_local,
              f.scheduled_arrival,
              timezone(arr.timezone, f.scheduled_arrival) AS scheduled_arrival_local,
              (f.scheduled_arrival - f.scheduled_departure) AS scheduled_duration,
              f.departure_airport_code,
              dep.airport_name AS departure_airport_name,
              dep.city AS departure_city,
              f.arrival_airport_code,
              arr.airport_name AS arrival_airport_name,
              arr.city AS arrival_city,
              f.status,
              f.aircraft_code,
              f.actual_departure,
              timezone(dep.timezone, f.actual_departure) AS actual_departure_local,
              f.actual_arrival,
              timezone(arr.timezone, f.actual_arrival) AS actual_arrival_local,
              (f.actual_arrival - f.actual_departure) AS actual_duration
         FROM flights f,
              airports dep,
              airports arr
        WHERE f.departure_airport_code = dep.airport_code
          AND f.arrival_airport_code = arr.airport_code
      """

      execute "COMMENT ON VIEW flights_v IS 'Flights (extended)'"
      execute "COMMENT ON COLUMN flights_v.flight_id IS 'Flight ID'"
      execute "COMMENT ON COLUMN flights_v.flight_no IS 'Flight number'"
      execute "COMMENT ON COLUMN flights_v.scheduled_departure IS 'Scheduled departure time'"
      execute "COMMENT ON COLUMN flights_v.scheduled_departure_local IS 'Scheduled departure time, local time at the point of departure'"
      execute "COMMENT ON COLUMN flights_v.scheduled_arrival IS 'Scheduled arrival time'"
      execute "COMMENT ON COLUMN flights_v.scheduled_arrival_local IS 'Scheduled arrival time, local time at the point of destionation'"
      execute "COMMENT ON COLUMN flights_v.scheduled_duration IS 'Scheduled flight duration'"
      execute "COMMENT ON COLUMN flights_v.departure_airport_code IS 'Departure airport code'"
      execute "COMMENT ON COLUMN flights_v.departure_airport_name IS 'Departure airport name'"
      execute "COMMENT ON COLUMN flights_v.departure_city IS 'City of departure'"
      execute "COMMENT ON COLUMN flights_v.arrival_airport_code IS 'Arrival airport code'"
      execute "COMMENT ON COLUMN flights_v.arrival_airport_name IS 'Arrival airport name'"
      execute "COMMENT ON COLUMN flights_v.arrival_city IS 'City of arrival'"
      execute "COMMENT ON COLUMN flights_v.status IS 'Flight status'"
      execute "COMMENT ON COLUMN flights_v.aircraft_code IS 'Aircraft code, IATA'"
      execute "COMMENT ON COLUMN flights_v.actual_departure IS 'Actual departure time'"
      execute "COMMENT ON COLUMN flights_v.actual_departure_local IS 'Actual departure time, local time at the point of departure'"
      execute "COMMENT ON COLUMN flights_v.actual_arrival IS 'Actual arrival time'"
      execute "COMMENT ON COLUMN flights_v.actual_arrival_local IS 'Actual arrival time, local time at the point of destination'"
      execute "COMMENT ON COLUMN flights_v.actual_duration IS 'Actual flight duration'"
    end

    def down do
      execute "DROP VIEW flights_v"
    end
  end

  defmodule AirDB.Repo.Migrations.AddsSeatsTable do
    use Ecto.Migration

    def change do
      create table(:seats, primary_key: false, comment: "Seats") do
        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char, on_delete: :delete_all),
          size: 3,
          primary_key: true,
          comment: "Aircraft code, IATA"

        add :seat_no, :varchar, size: 4, primary_key: true, comment: "Seat number"
        add :fare_conditions, :varchar, size: 10, null: false, comment: "Travel class"
      end

      create constraint(
        :seats,
        "seats_fare_conditions_check",
        check: "fare_conditions = ANY(ARRAY['Economy', 'Comfort', 'Business'])"
      )
    end
  end

#+END_SRC

