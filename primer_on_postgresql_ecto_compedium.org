#+TITLE: Конспект PostgreSQL Основы языка SQL и Ecto
#+AUTHOR: Mikalai Seva
#+EMAIL: mikalai.seva@gmail.com
#+DESCRIPTION:
#+KEYWORDS: PostgreSQL SQL Primer Ecto Elixir
#+LANGUAGE: ru, en
#+OPTIONS: H:3 toc:2 p:t
#+OPTIONS: ^:{}
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* Введение в базы данных и SQL
** Что такое базы данных
Одним из основных понятий в теории баз данных является *модель данных*. Можно
сказать, что она характеризует способ организации данных и основные методы
доступа к ним. В ходе эволюции теорий и идей была разработана реляционная модель
данных, которая сейчас и является доминирующей. Характерной чертой реляционных
баз данных является тот факт, что данные воспринимаются пользователем как
таблицы.

Одним из достоинств реляционной базы данных является ее способность поддерживать
связи между элементами данных, избавляя программиста от необходимости заниматься
этой рутинной и очень трудоемкой работой. Работая с реляционными базами данных,
программист избавлен от программирования на «атомарном» уровне, потому что
современные языки для «общения» с этими базами данных являются декларативными.

Система баз данных — это компьютеризированная система, предназначенная для
хранения, переработки и выдачи информации по запросу пользователей. Такая
система включает в себя программное и аппаратное обеспечение, сами данные, а
также пользователей.

Современные системы баз данных являются, как правило, многопользовательскими. В
таких системах одновременный доступ к базе данных могут получить сразу несколько
пользователей.

Основным программным обеспечением является система управления базами данных.
По-английски она называется /database management system/ (DBMS). Кроме СУБД в
систему баз данных могут входить утилиты, средства для разработки приложений
(программ), средства проектирования базы данных, генераторы отчетов и др.

Пользователи систем с базами данных подразделяются на ряд категорий. Первая
категория — это прикладные программисты. Вторая категория — это конечные
пользователи, ради которых и выполняется вся работа. Они могут получить доступ к
базе данных, используя прикладные программы или универсальные приложения,
которые входят в программное обеспечение самой СУБД. Третья категория
пользователей — это администраторы базы данных. В их обязанности входят:
создание базы данных, выбор оптимальных режимов доступа к ней, разграничение
полномочий различных пользователей на доступ к той или иной информации в базе
данных, выполнение резервного копирования базы данных и т.д.

Систему баз данных можно разделить на два главных компонента: сервер и набор
клиентов (или внешних интерфейсов). Сервер — это и есть СУБД. Один сервер может
обслуживать много клиентов.

Современные СУБД включают в себя словарь данных. Это часть базы данных, которая
описывает сами данные, хранящиеся в ней. Словарь данных помогает СУБД выполнять
свои функции.
** Основные понятия реляционной модели
В эпоху, предшествующую рождению реляционной теории, базы данных традиционно
рассматривались как набор *файлов*, состоящих из *записей*, а записи, в свою
очередь, подразделялись на отдельные *поля*. Поле являлось элементарной единицей
данных.

В реляционных базах данных пользователь воспринимает данные в виде таблиц.
Поэтому термину «файл» соответствует термин *«таблица»*, вместо термина «запись»
используется термин *«строка»*, а вместо термина «поле» — термин *«столбец»*
(или *«колонка»*).

В формальной теории реляционных баз данных эти таблицы называют *отношениями*
(*relations*) — поэтому и базы данных называются реляционными. Отношение — это
математический термин. При определении свойств таких отношений используется
теория множеств. В терминах данной теории строки таблицы будут называться
*кортежами* (*tuples*), а колонки — *атрибутами*. Отношение имеет заголовок,
который состоит из атрибутов, и тело, состоящее из кортежей. Количество
атрибутов называется *степенью отношения*, а количество кортежей — *кардинальным
числом*. Кроме теории множеств, одним из оснований реляционной теории является
такой раздел математической логики, как исчисление предикатов.

При работе с базами данных часто приходится следовать *различным ограничениям*,
которые могут быть обусловлены спецификой конкретной предметной области.

Для идентификации строк в таблицах и для связи таблиц между собой используются
так называемые ключи. *Потенциальный ключ* — это комбинация атрибутов таблицы,
позволяющая уникальным образом идентифицировать строки в ней. Ключ может
состоять только лишь из одного атрибута таблицы. Потенциальный ключ должен быть
*неизбыточным*, т.е. никакое подмножество атрибутов, входящих в него, не должно
обладать свойством уникальности. Ключ, состоящий из нескольких атрибутов
называется *составным*.

Ключи нужны для адресации на уровне строк (записей). При наличии в таблице более
одного потенциального ключа один из них выбирается в качестве так называемого
*первичного ключа*, а остальные будут являться *альтернативными ключами*.

*Внешним ключ* - это ключ, используемый для объединения двух таблиц. Таблица,
содержащая внешний ключ, называется *ссылающейся* таблицей (*referencing
table*). Таблица, содержащая соответствующий потенциальный ключ, называется
*ссылочной* (*целевой*) таблицей (*referenced table*). В таких случаях говорят,
что внешний ключ ссылается на потенциальный ключ в ссылочной таблице. Внешний
ключ может быть составным, т.е. может включать более одного атрибута. Внешний
ключ не обязан быть уникальным.

Проблема обеспечения того, чтобы база данных не содержала неверных значений
внешних ключей, известна как проблема *ссылочной целостности*. Ограничение,
согласно которому значения внешних ключей должны соответствовать значениям
потенциальных ключей, называется *ограничением ссылочной целостности*
(*ссылочным ограничением*).

Обеспечением выполнения ограничений ссылочной целостности занимается СУБД, а от
разработчика требуется лишь указать атрибуты, служащие в качестве внешних
ключей. При проектировании баз данных часто предусматривается, что при удалении
строки из ссылочной таблицы соответствующие строки из ссылающейся таблицы должны
быть также удалены, а при изменении значения столбца, на который ссылается
внешний ключ, должны быть изменены значения внешнего ключа в ссылающейся
таблице. Этот подход называется *каскадным удалением* (*обновлением*).

Иногда применяются и другие подходы. Например, вместо удаления строк из
ссылающейся таблицы в этих строках просто заменяют значения атрибутов, входящих
во внешний ключ, так называемыми *NULL*-значениями. Первичные ключи не могут
содержать NULL-значений.

*Транзакция* — одно из важнейших понятий теории баз данных. Она означает набор
операций над базой данных, рассматриваемых как единая и неделимая единица
работы, выполняемая полностью или не выполняемая вовсе, если произошел какойто
сбой в процессе выполнения транзакции. Таким образом, транзакции являются
*средством обеспечения согласованности данных*.
** Что такое язык SQL
Язык SQL — это непроцедурный язык, который является стандартным средством работы
с данными во всех реляционных СУБД. *Операторы* (*команды*), написанные на этом
языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают
процедуру получения этого результата. СУБД сама определяет способ выполнения
команды пользователя. В языке SQL традиционно выделяются группа операторов
определения данных (*Data Definition Language* — *DDL*), группа операторов
манипулирования данными (*Data Manipulation Language* — *DML*) и группа
операторов, управляющих привилегиями доступа к объектам базы данных (*Data
Control Language* — *DCL*).
* Основные операции с таблицами
Для создания таблиц в языке SQL служит команда ~CREATE TABLE~. Итак, команда для
создания нашей первой таблицы ~aircrafts~ такова:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  CREATE TABLE aircrafts(
    aircraft_code char(3) NOT NULL,
    model text NOT NULL,
    range integer NOT NULL,
    CHECK (range > 0),
    PRIMARY KEY (aircraft_code)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Repo.Migrations.AddsAircraftsTable do
    use Ecto.Migration

    def change do
      create table(:aircrafts, primary_key: false, comment: "Aircrafts") do
        add :aircraft_code, :char, size: 3, primary_key: true, comment: "Aircraft code, IATA"
        add :model, :text, null: false, comment: "Aircraft model"
        add :range, :integer, null: false, comment: "Maximal flying distance, km"
      end

      create constraint(:aircrafts, "aircrafts_range_check", check: "range > 0", comment: "range should be greater than 0")
    end
  end

  defmodule AirDB.Aircraft do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Seat

    @primary_key false
    schema "aircrafts" do
      field :aircraft_code, :string, primary_key: true
      field :model, :string
      field :range, :integer

      has_many :seats, Seat,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        on_replace: :mark_as_invalid
    end
  end
#+END_SRC

Значения всех атрибутов каждой строки данной таблицы должны быть определенными,
поэтому на них накладывается ограничение ~NOT NULL~. В принципе в таблицах базы
данных могут содержаться неопределенные значения некоторых атрибутов. Говоря
другими словами, их значения могут отсутствовать. В таких случаях в этих полях
содержится специальное значение ~NULL~.

К томуже атрибут ~range~ не должен принимать отрицательных значений и нулевого
значения, поэтому приходится добавить еще одно ограничение: ~range > 0~.

В качестве первичного ключа выбран атрибут ~aircraft_code~. Таким образом,
первичный ключ будет, как говорят, *естественным*. Это означает, что и в
реальной предметной области существует такое понятие, как код самолета, и это
понятие используется на практике. В отличие от естественных ключей иногда
используются и так называемые *суррогатные ключи*.

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d aircrafts
#+END_SRC

#+RESULTS:
#+begin_example
                   Table "public.aircrafts"
    Column     |     Type     | Collation | Nullable | Default
---------------+--------------+-----------+----------+---------
 aircraft_code | character(3) |           | not null |
 model         | text         |           | not null |
 range         | integer      |           | not null |
Indexes:
    "aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
Check constraints:
    "aircrafts_range_check" CHECK (range > 0)
Referenced by:
    TABLE "flights" CONSTRAINT "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    TABLE "seats" CONSTRAINT "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Для в вода данных в таблицу служит команда ~INSERT~. Давайте добавим одну строку
в таблицу ~aircrafts~.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range) VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC elixir :eval no :exports both
  %Aircraft{}
  |> Aircraft.changeset(%{
    aircraft_code: "SU9",
    model: "Sukhoi SuperJet-100",
    range: 3000
  })
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 13:37:23.184 [debug] QUERY OK db=10.7ms decode=0.6ms queue=8.0ms idle=0.0ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3) ["SU9", "Sukhoi SuperJet-100", 3000]
:
: {:ok,
:  %AirDB.Aircraft{
:    __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:    aircraft_code: "SU9",
:    model: "Sukhoi SuperJet-100",
:    range: 3000,
:    seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:  }}

Давайте добавим еще несколько строк в таблицу ~aircrafts~. Команда ~INSERT~
позволяет сделать это за один раз.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range)
    VALUES ('773', 'Boeing 777-300', 11100),
           ('763', 'Boeing 767-300', 7900),
           ('733', 'Boeing 737-300', 4200),
           ('320', 'Airbus A320-200', 5700),
           ('321', 'Airbus A321-200', 5600),
           ('319', 'Airbus A319-100', 6700),
           ('CN1', 'Cessna 208 Caravan', 1200),
           ('CR2', 'Bombardier CRJ-200', 2700);
#+END_SRC

#+RESULTS:
: INSERT 0 8

#+BEGIN_SRC elixir :exports both :eval no
  Repo.insert_all(Aircraft, [
    %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
    %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
    %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
    %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
    %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
    %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
    %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
    %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
  ])
#+END_SRC

#+RESULTS:
: 13:37:23.199 [debug] QUERY OK db=3.4ms queue=0.5ms idle=28.0ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18),($19,$20,$21),($22,$23,$24) ["773", "Boeing 777-300", 11100, "763", "Boeing 767-300", 7900, "733", "Boeing 737-300", 4200, "320", "Airbus A320-200", 5700, "321", "Airbus A321-200", 5600, "319", "Airbus A319-100", 6700, "CN1", "Cessna 208 Caravan", 1200, "CR2", "Bombardier CRJ-200", 2700]
:
: {8, nil}

Давайте посмотрим, что содержится в таблице ~aircrafts~. Для этого служит
команда ~SELECT~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           733 | Boeing 737-300      |  4200 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           319 | Airbus A319-100     |  6700 |
|           CN1 | Cessna 208 Caravan  |  1200 |
|           CR2 | Bombardier CRJ-200  |  2700 |

#+BEGIN_SRC elixir :exports both :eval no
  Repo.all(Aircraft)
#+END_SRC

#+RESULTS:
: 13:42:28.202 [debug] QUERY OK source="aircrafts" db=0.3ms decode=0.5ms queue=0.6ms idle=2.3ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 []
:
: [
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "SU9",
:     model: "Sukhoi SuperJet-100",
:     range: 3000,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "773",
:     model: "Boeing 777-300",
:     range: 11100,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "763",
:     model: "Boeing 767-300",
:     range: 7900,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "733",
:     model: "Boeing 737-300",
:     range: 4200,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "320",
:     model: "Airbus A320-200",
:     range: 5700,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "321",
:     model: "Airbus A321-200",
:     range: 5600,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "319",
:     model: "Airbus A319-100",
:     range: 6700,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "CN1",
:     model: "Cessna 208 Caravan",
:     range: 1200,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   },
:   %AirDB.Aircraft{
:     __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:     aircraft_code: "CR2",
:     model: "Bombardier CRJ-200",
:     range: 2700,
:     seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:   }
: ]

Давайте упорядочим строки по значению атрибута ~model~, а заодно изменим порядок
расположения столбцов в выводе информации.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range FROM aircrafts ORDER BY model;
#+END_SRC

#+RESULTS:
| model               | aircraft_code | range |
|---------------------+---------------+-------|
| Airbus A319-100     |           319 |  6700 |
| Airbus A320-200     |           320 |  5700 |
| Airbus A321-200     |           321 |  5600 |
| Boeing 737-300      |           733 |  4200 |
| Boeing 767-300      |           763 |  7900 |
| Boeing 777-300      |           773 | 11100 |
| Bombardier CRJ-200  |           CR2 |  2700 |
| Cessna 208 Caravan  |           CN1 |  1200 |
| Sukhoi SuperJet-100 |           SU9 |  3000 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from a in "aircrafts",
      order_by: [asc: a.model],
      select: [a.aircraft_code, a.model, a.range]

  query
  |> Repo.all()

  # macro example
  "aircrafts"
  |> order_by([a], asc: a.model)
  |> select([a], [a.aircraft_code, a.model, a.range])
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.211 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.8ms idle=16.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."model" []
:
: [
:   ["319", "Airbus A319-100", 6700],
:   ["320", "Airbus A320-200", 5700],
:   ["321", "Airbus A321-200", 5600],
:   ["733", "Boeing 737-300", 4200],
:   ["763", "Boeing 767-300", 7900],
:   ["773", "Boeing 777-300", 11100],
:   ["CR2", "Bombardier CRJ-200", 2700],
:   ["CN1", "Cessna 208 Caravan", 1200],
:   ["SU9", "Sukhoi SuperJet-100", 3000]
: ]

Множество выбираемых строк можно ограничить с помощью предложения ~WHERE~
команды ~SELECT~. Давайте выберем модели самолетов, у которых максимальная
дальность полета находитсяв пределах от 4 до 6 тыс. км включительно. Условие
выбора строк может быть составным. В данном случае нужно скомбинировать два
ограничения с помощью логической операции ~AND~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range
    FROM aircrafts
   WHERE range >= 4000 AND range <= 6000;
#+END_SRC

#+RESULTS:
| model           | aircraft_code | range |
|-----------------+---------------+-------|
| Boeing 737-300  |           733 |  4200 |
| Airbus A320-200 |           320 |  5700 |
| Airbus A321-200 |           321 |  5600 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from a in "aircrafts",
      where: a.range >= 4000 and a.range <= 6000,
      select: [a.aircraft_code, a.model, a.range]

  query
  |> Repo.all()

  # macro example
  "aircrafts"
  |> where([a], a.range >= 4000 and a.range <= 6000)
  |> select([a], [a.aircraft_code, a.model, a.range])
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.212 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.4ms idle=18.1ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE ((a0."range" >= 4000) AND (a0."range" <= 6000)) []
:
: [
:   ["733", "Boeing 737-300", 4200],
:   ["320", "Airbus A320-200", 5700],
:   ["321", "Airbus A321-200", 5600]
: ]

Команда ~UPDATE~ предназначенна для обновления данных в таблицах. Условие,
указываемое в команде, должно ограничить диапазон обновляемых строк. Если это
условие не задать, то будут обновлены все строки в таблице.

Давайте предположим, что российские инженеры немного улучшили летные
характеристики самолета /Sukhoi SuperJet/, и теперь дальность его полета стала
на 500 км больше.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = 3500 WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from a in "aircrafts",
      where: a.aircraft_code == "SU9"

  query
  |> Repo.update_all(set: [range: 3500])

  # macro example
  "aircrafts"
  |> where([a], a.aircraft_code == "SU9")
  |> Repo.update_all(set: [range: 3500])
#+END_SRC

#+RESULTS:
: 13:42:28.219 [debug] QUERY OK source="aircrafts" db=5.5ms queue=0.5ms idle=19.7ms
: UPDATE "aircrafts" AS a0 SET "range" = $1 WHERE (a0."aircraft_code" = 'SU9') [3500]
:
: {1, nil}

Давайте проверим, что получилось в результате обновления данных.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi SuperJet-100 |  3500 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from a in "aircrafts",
      where: a.aircraft_code == "SU9",
      select: [a.aircraft_code, a.model, a.range]

  query
  |> Repo.all()

  # macro example
  "aircrafts"
  |> where([a], a.aircraft_code == "SU9")
  |> select([a], [a.aircraft_code, a.model, a.range])
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.221 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.6ms idle=26.8ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'SU9') []
:
: [["SU9", "Sukhoi SuperJet-100", 3500]]

Для удаления строк из таблиц используется команда ~DELETE~, которая похожа на
команду ~SELECT~. Удалим какую-нибудь одну строку из таблицы ~aircrafts~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
: DELETE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from a in "aircrafts",
      where: a.aircraft_code == "CN1"

  query
  |> Repo.delete_all()

  # macro example
  "aircrafts"
  |> where([a], a.aircraft_code == "CN1")
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 13:42:28.226 [debug] QUERY OK source="aircrafts" db=4.2ms queue=0.4ms idle=28.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'CN1') []
:
: {1, nil}

Вы можете указать и какое-нибудь более сложное условие. Давайте, например,
удалим информацию о самолетах с дальностью полета более 10000 км, а также с
дальностью полета менее 3000 км:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE range > 10000 OR range < 3000;
#+END_SRC

#+RESULTS:
: DELETE 2

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from a in "aircrafts",
    where: a.range > 10000 or a.range < 3000

  query
  |> Repo.delete_all()

  # macro example
  "aircrafts"
  |> where([a], a.range > 10000 or a.range < 3000)
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 14:03:41.612 [debug] QUERY OK source="aircrafts" db=4.5ms queue=0.5ms idle=39.0ms
: DELETE FROM "aircrafts" AS a0 WHERE ((a0."range" > 10000) OR (a0."range" < 3000)) []
:
: {2, nil}

При необходимости удаления всех строк из таблицы команда будет совсем простой:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts;
#+END_SRC

#+RESULTS:
: DELETE 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.delete_all("aircrafts")
#+END_SRC

#+RESULTS:
: 13:42:28.233 [debug] QUERY OK source="aircrafts" db=5.4ms queue=0.5ms idle=33.6ms
: DELETE FROM "aircrafts" AS a0 []

Теперь в таблице ~aircrafts~ нет ни одной строки.

Для таблицы ~aircrafts~ ближайшей «родственницей» является таблица ~seats~.

Значения атрибута ~fare_conditions~ могут выбираться из ограниченного списка
значений. Проверка на соответствие вводимых значений этому списку будет
обеспечиваться с помощью ограничения ~CHECK~.

В этой таблице используется *внешний ключ*. Предложение ~FOREIGN KEY~ создает
ограничение ссылочной целостности. В качестве внешнего ключа служит атрибут
~aircraft_code~. Он ссылается на одноименный атрибут в таблице ~aircrafts~.
Таблица ~seats~ называется *ссылающейся* (*referencing*), а таблица ~aircrafts~
— *ссылочной* (*referenced*).

Поскольку номера мест привязаны к модели самолета, то в случае удаления из
таблицы ~aircrafts~ какой-либо строки с конкретным кодом самолета необходимо
удалить также и из таблицы ~seats~ все строки, в которых значение атрибута
~aircraft_code~ такое же. Поэтому в предложении для определения внешнего ключа
появляется важное дополнение: ~ON DELETE CASCADE~. Это означает, что при
удалении какой-либо строки из таблицы ~aircrafts~ удаление строк из таблицы
~seats~, связанных с этой строкой по внешнему ключу, берет на себя СУБД,
избавляя программиста от этой заботы. Подобные действия, которые выполняет сама
СУБД, называются *каскадным удалением*. Таким образом, внешний ключ служит для
связи таблиц между собой.

Итак, команда для создания нашей второй таблицы ~seats~ такова:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  CREATE TABLE seats(
    aircraft_code char(3) NOT NULL,
    seat_no varchar(4) NOT NULL,
    fare_conditions varchar(10) NOT NULL,
    CHECK (fare_conditions IN ('Economy', 'Comfort', 'Business')),
    PRIMARY KEY (aircraft_code, seat_no),
    FOREIGN KEY (aircraft_code) REFERENCES aircrafts (aircraft_code) ON DELETE CASCADE
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Repo.Migrations.AddsSeatsTable do
    use Ecto.Migration

    def change do
      create table(:seats, primary_key: false, comment: "Seats") do
        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char, on_delete: :delete_all),
          size: 3,
          primary_key: true,
          comment: "Aircraft code, IATA"

        add :seat_no, :varchar, size: 4, primary_key: true, comment: "Seat number"
        add :fare_conditions, :varchar, size: 10, null: false, comment: "Travel class"
      end

      create constraint(
        :seats,
        "seats_fare_conditions_check",
        check: "fare_conditions = ANY(ARRAY['Economy', 'Comfort', 'Business'])"
      )
    end
  end

  defmodule AirDB.Seat do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Aircraft

    @primary_key false
    schema "seats" do
      belongs_to :aircraft, Aircraft,
        primary_key: true,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string

      field :seat_no, :string, primary_key: true
      field :fare_conditions, :string
    end
  end
#+END_SRC

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d seats
#+END_SRC

#+RESULTS:
#+begin_example
                           Table "public.seats"
     Column      |         Type          | Collation | Nullable | Default
-----------------+-----------------------+-----------+----------+---------
 aircraft_code   | character(3)          |           | not null |
 seat_no         | character varying(4)  |           | not null |
 fare_conditions | character varying(10) |           | not null |
Indexes:
    "seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
Check constraints:
    "seats_fare_conditions_check" CHECK (fare_conditions::text = ANY (ARRAY['Economy'::text, 'Comfort'::text, 'Business'::text]))
Foreign-key constraints:
    "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Принципиально новым по сравнению с рассмотренной выше таблицей ~aircrafts~
является наличие ограничения внешнего ключа. Это ограничение имеет имя
~seats_aircraft_code_fkey~, сгенерированное самой СУБД. Давайте сразу же
проделаем эксперимент, позволяющий показать работу внешнего ключа. Выполните
следующую команду для ввода данных в таблицу ~seats~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES ('123', '1A', 'Business');
#+END_SRC

#+RESULTS:
: ERROR:  insert or update on table "seats" violates foreign key constraint "seats_aircraft_code_fkey"
: DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts".

#+BEGIN_SRC elixir :eval no :exports both
  %Seat{}
  |> Seat.changeset(%{
    aircraft_code: "123",
    seat_no: "1A",
    fare_conditions: "Business"
  })
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:28:52.511 [debug] QUERY ERROR db=2.7ms queue=9.1ms idle=0.0ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3) ["123", "Business", "1A"]
:
: {:error,
:  #Ecto.Changeset<
:    action: :insert,
:    changes: %{aircraft_code: "123", fare_conditions: "Business", seat_no: "1A"},
:    errors: [
:      aircraft_code: {"does not exist",
:       [constraint: :foreign, constraint_name: "seats_aircraft_code_fkey"]}
:    ],
:    data: #AirDB.Seat<>,
:    valid?: false
:  >}

Теперь нужно заполнить данными таблицу ~seats~.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES
    ('SU9', '1A', 'Business'),
    ('SU9', '1B', 'Business'),
    ('SU9', '10A', 'Economy'),
    ('SU9', '10B', 'Economy'),
    ('SU9', '10F', 'Economy'),
    ('SU9', '20F', 'Economy');

  INSERT INTO seats VALUES
    ('773', '1A', 'Business'),
    ('773', '1B', 'Business'),
    ('773', '10A', 'Economy'),
    ('773', '10B', 'Economy'),
    ('773', '10F', 'Economy'),
    ('773', '20F', 'Economy');
#+END_SRC

#+RESULTS:
: INSERT 0 6
: INSERT 0 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "SU9", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "20F", fare_conditions: "Economy"}
  ])

  Repo.insert_all(Seat, [
    %{aircraft_code: "773", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.521 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["SU9", "Business", "1A", "SU9", "Business", "2B", "SU9", "Economy", "10A", "SU9", "Economy", "10B", "SU9", "Economy", "10F", "SU9", "Economy", "20F"]
:
: {6, nil}
:
: 14:28:52.601 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["773", "Business", "1A", "773", "Business", "2B", "773", "Economy", "10A", "773", "Economy", "10B", "773", "Economy", "10F", "773", "Economy", "20F"]
:
: {6, nil}

Теперь решим еще одну задачу. Предположим, что нам нужно получить информацию о
количестве мест в салонах для всех типов самолетов. Конечно, для решения задачи,
поставленной выше, в принципе можно воспользоваться такими командами:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from s in "seats",
      where: s.aircraft_code == "SU9",
      select: count()

  query
  |> Repo.all()

  # macro example
  "seats"
  |> where([s], s.aircraft_code == "SU9")
  |> select(count())
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.421 [debug] QUERY OK source="seats" db=0.3ms decode=0.4ms queue=0.5ms idle=3.0ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'SU9') []
:
: [6]

И похожими для всех остальных самолетов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from s in "seats",
      where: s.aircraft_code == "CN1",
      select: count()

  query
  |> Repo.all()

  # macro example
  "seats"
  |> where([s], s.aircraft_code == "CN1")
  |> select(count())
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.427 [debug] QUERY OK source="seats" db=0.5ms queue=0.7ms idle=13.5ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'CN1') []
:
: [0]

Очевидно, что это нерациональный подход. Язык SQL позволяет упростить решение
такой задачи за счет применения операции группирования строк на основе
некоторого критерия. В модифицированной команде вместо предложения ~WHERE~ будет
добавлено предложение ~GROUP BY~, которое отвечает за группировку строк с
одинаковыми значениями атрибута ~aircraft_code~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |
| 773           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from s in "seats",
      group_by: s.aircraft_code,
      select: [s.aircraft_code, count()]

  query
  |> Repo.all()

  # macro example
  "seats"
  |> group_by([s], s.aircraft_code)
  |> select([s], [s.aircraft_code, count()])
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.428 [debug] QUERY OK source="seats" db=0.4ms queue=0.5ms idle=14.9ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" []
:
: [["SU9", 6]]

Если мы захотим отсортировать выборку по числу мест в самолетах, то нужно будет
дополнить команду предложением ~ORDER BY~, которое обеспечит сортировку
результирующих строк по значениям второго столбца.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code
   ORDER BY count;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # TODO select_as
  # keyword example
  query =
    from s in "seats",
      group_by: s.aircraft_code,
      order_by: fragment("count"),
      select: [s.aircraft_code, count()]

  query
  |> Repo.all()

  # macro example
  "seats"
  |> group_by([s], s.aircraft_code)
  |> order_by(fragment("count"))
  |> select([s], [s.aircraft_code, count()])
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.429 [debug] QUERY OK source="seats" db=0.4ms queue=0.6ms idle=16.1ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" ORDER BY count []
:
: [["SU9", 6]]

Теперь поставим более сложную задачу: подсчитать количество мест в салонах для
всех моделей самолетов, но теперь уже с учетом класса обслуживания (бизнес-класс
и экономический класс). В этом случае группировка выполняется уже по двум
атрибутам: ~aircraft_code~ и ~fare_conditions~. Отсортируем выборку по тем же
столбцам, по которым выполняли группировку.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         fare_conditions,
         count(*)
    FROM seats
   GROUP BY aircraft_code, fare_conditions
   ORDER BY aircraft_code, fare_conditions;
#+END_SRC

#+RESULTS:
| aircraft_code | fare_conditions | count |
|---------------+-----------------+-------|
| SU9           | Business        |     2 |
| SU9           | Economy         |     4 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  query =
    from s in "seats",
      group_by: [s.aircraft_code, s.fare_conditions],
      order_by: [s.aircraft_code, s.fare_conditions],
      select: [s.aircraft_code, s.fare_conditions, count()]

  query
  |> Repo.all()

  # macro example
  "seats"
  |> group_by([s], [s.aircraft_code, s.fare_conditions])
  |> order_by([s], [s.aircraft_code, s.fare_conditions])
  |> select([s], [s.aircraft_code, s.fare_conditions, count()])
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.431 [debug] QUERY OK source="seats" db=0.4ms queue=0.8ms idle=17.5ms
: SELECT s0."aircraft_code", s0."fare_conditions", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code", s0."fare_conditions" ORDER BY s0."aircraft_code", s0."fare_conditions" []
:
: [["SU9", "Business", 2], ["SU9", "Economy", 4]]
** Контрольные вопросы и задания
*** Вопрос 1
Попробуйте ввести в таблицу ~aircrafts~ строку с таким значением атрибута «Код
самолета» (~aircraft_code~), которое вы уже вводили, например:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO aircrafts VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

#+RESULTS:
: ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
: DETAIL:  Key (aircraft_code)=(SU9) already exists.

Обратите внимание, что в этой команде мы не привели список атрибутов, что вполне
допустимо при задании значений атрибутов в том же порядке, в котором атрибуты
следуют в определении таблицы. Но в ваших прикладных программах так поступать
все же не следует, поскольку в случае возможной реструктуризации таблицы и
изменения порядка следования атрибутов в ней ваши команды ~INSERT~ могут
перестать работать корректно. Вы получите сообщение об ошибке.

: ОШИБКА: повторяющееся значение ключа нарушает ограничение уникальности "aircrafts_pkey"
: ПОДРОБНОСТИ: Ключ "(aircraft_code)=(SU9)" уже существует.

Подумайте, почему появилось сообщение. Если вы забыли структуру таблицы
~aircrafts~, то можно вывести ее определение на экран с помощью команды ~\d
aircrafts~.
*** Вопрос 2
Предложение ~ORDER BY~ команды ~SELECT~ позволяет отсортировать данные при
выводе. По умолчанию сортировка выполняется по возрастанию значений атрибута,
указанного в этом предложении. Но можно упорядочить строки и по убыванию
значения атрибута. Для этого нужно после имени атрибута в предложении ~ORDER BY~
добавить ключевое слово ~DESC~ (это сокращение от слова /descendant/ — убывающий
порядок). Самостоятельно напишите команду для выборки всех строк из таблицы
~aircrafts~, чтобы строки были упорядочены по убыванию значения атрибута
«Максимальная дальность полета, км» (~range~).

Ответ:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts ORDER BY range DESC;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           319 | Airbus A319-100     |  6700 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           733 | Boeing 737-300      |  4200 |
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           CR2 | Bombardier CRJ-200  |  2700 |
|           CN1 | Cessna 208 Caravan  |  1200 |
*** Вопрос 3
Команда ~UPDATE~ позволяет в процессе обновления выполнять арифметические
действия над значениями, находящимися в строках таблицы. Представим себе, что
двигатели самолета /Sukhoi SuperJet/ стали в два раза экономичнее, вследствие
чего дальность полета этого лайнера возросла ровно в два раза. Команда ~UPDATE~
позволяет увеличить значение атрибута ~range~ в строке, хранящей информацию об
этом самолете, даже не выполняя предварительно выборку с целью выяснения
текущего значения этого атрибута. При присваивании нового значения атрибуту
~range~ можно справа от знака ~=~ написать не только числовую константу, но и
целое выражение. В нашем случае оно будет простым: ~range = range * 2~.
Самостоятельно напишите команду ~UPDATE~ полностью, при этом не забудьте, что
увеличить дальность полета нужно только у одной модели — /Sukhoi SuperJet/,
поэтому необходимо использовать условие ~WHERE~. Затем с помощью команды
~SELECT~ проверьте полученный результат.

Ответ:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = range * 2 WHERE aircraft_code = 'SU9';
  SELECT range FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1
: range
: 6000
*** Вопрос 4
Если в предложении ~WHERE~ команды ~DELETE~ вы укажете логически и синтаксически
корректное условие, но строк, удовлетворяющих этому условию, в таблице не
окажется, то в ответ СУБД выведет сообщение ~DELETE 0~.

Такая ситуация не является ошибкой или сбоем в работе СУБД. Например, если после
удаления какой-то строки вы повторно попытаетесь удалить ее же, то получите
именно такое сообщение. Самостоятельно смоделируйте описанную ситуацию, подобрав
условие, которому гарантированно не соответствует ни одна строка в таблице
«Самолеты» (~aircrafts~).

Ответ:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'XXX';
#+END_SRC

#+RESULTS:
: DELETE 0
* Типы данных СУБД PostgreSQL
** Числовые типы
   Группа числовых типов данных включает в себя целый ряд разновидностей:
   целочисленные типы, числа фиксированной точности, типы данных с плавающей
   точкой, последовательные типы (~serial~).

   В составе целочисленных типов находятся следующие представители: ~smallint~,
   ~integer~, ~bigint~. Если атрибут таблицы имеет один из этих типов, то он
   позволяет хранить только целочисленные данные. При этом перечисленные типы
   различаются по количеству байтов, выделяемых для хранения данных. В
   PostgreSQL существуют псевдонимы для этих стандартизированных имен типов, а
   именно: ~int2~, ~int4~ и ~int8~. Число байтов отражается в имени типа.

   Числа фиксированной точности представлены двумя типами — ~numeric~ и
   ~decimal~. Однако они являются идентичными по своим возможностям. Числа типа
   ~numeric~ могут хранить очень большое количество цифр: 131072 цифры — до
   десятичной точки (запятой), 16383 — после точки. Его главное достоинство —
   это обеспечение /точных/ результатов при выполнении вычислений, когда это,
   конечно, возможно в принципе. Для задания значения этого типа используются
   два базовых понятия: *масштаб* (*scale*) и *точность* (*precision*). Масштаб
   показывает число значащих цифр, стоящих справа от десятичной точки (запятой).
   Точность указывает общее число цифр как до десятичной точки, так и после нее.
   Параметры этого типа данных указываются в круглых скобках после имени типа:
   ~numeric(точность, масштаб)~.

   Представителями типов данных с плавающей точкой являются типы ~real~ и
   ~double precision~. Они представляют собой реализацию стандарта IEEE
   «Standard 754 forBinary Floating-Point Arithmetic». Тип данных ~real~ может
   представить числа в диапазоне, как минимум, от 1E−37 до 1E+37 с точностью не
   меньше 6 десятичных цифр. Тип ~double precision~ имеет диапазон значений
   примерно от 1E−307 до 1E+308 с точностью не меньше 15 десятичных цифр.

   При попытке записать в такой столбец слишком большое или слишком
   маленькое значение будет генерироваться ошибка. Если точность вводимого числа
   выше допустимой, то будет иметь место округление значения. А вот при вводе
   очень маленьких чисел, которые невозможно представить значениями, отличными от
   нуля, будет генерироваться ошибка потери значимости, или исчезновения
   значащих разрядов (an underflow error).

   При работе с числами таких типов нужно помнить, что сравнение двух чисел с
   плавающей точкой на предмет равенства их значений может привести к
   неожиданным результатам:

   #+BEGIN_SRC sql :engine postgres :exports both :eval no
     SELECT 0.1::real * 10 = 1.0::real;
   #+END_SRC

   #+RESULTS:
   | ?column? |
   |----------|
   | f        |

