#+TITLE: Конспект PostgreSQL Основы языка SQL (и Elixir's Ecto)
#+AUTHOR: Mikalai Seva
#+EMAIL: mikalai.seva@gmail.com
#+DESCRIPTION:
#+KEYWORDS: PostgreSQL SQL Primer Ecto Elixir
#+LANGUAGE: ru, en
#+OPTIONS: H:3 toc:2 p:t
#+OPTIONS: ^:{}
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* Введение в базы данных и SQL
** Что такое базы данных
Одним из основных понятий в теории баз данных является *модель данных*. Можно
сказать, что она характеризует способ организации данных и основные методы
доступа к ним. В ходе эволюции теорий и идей была разработана реляционная модель
данных, которая сейчас и является доминирующей. Характерной чертой реляционных
баз данных является тот факт, что данные воспринимаются пользователем как
таблицы.

Одним из достоинств реляционной базы данных является ее способность поддерживать
связи между элементами данных, избавляя программиста от необходимости заниматься
этой рутинной и очень трудоемкой работой. Работая с реляционными базами данных,
программист избавлен от программирования на «атомарном» уровне, потому что
современные языки для «общения» с этими базами данных являются декларативными.

Система баз данных — это компьютеризированная система, предназначенная для
хранения, переработки и выдачи информации по запросу пользователей. Такая
система включает в себя программное и аппаратное обеспечение, сами данные, а
также пользователей.

Современные системы баз данных являются, как правило, многопользовательскими. В
таких системах одновременный доступ к базе данных могут получить сразу несколько
пользователей.

Основным программным обеспечением является система управления базами данных.
По-английски она называется /database management system/ (DBMS). Кроме СУБД в
систему баз данных могут входить утилиты, средства для разработки приложений
(программ), средства проектирования базы данных, генераторы отчетов и др.

Пользователи систем с базами данных подразделяются на ряд категорий. Первая
категория — это прикладные программисты. Вторая категория — это конечные
пользователи, ради которых и выполняется вся работа. Они могут получить доступ к
базе данных, используя прикладные программы или универсальные приложения,
которые входят в программное обеспечение самой СУБД. Третья категория
пользователей — это администраторы базы данных. В их обязанности входят:
создание базы данных, выбор оптимальных режимов доступа к ней, разграничение
полномочий различных пользователей на доступ к той или иной информации в базе
данных, выполнение резервного копирования базы данных и т.д.

Систему баз данных можно разделить на два главных компонента: сервер и набор
клиентов (или внешних интерфейсов). Сервер — это и есть СУБД. Один сервер может
обслуживать много клиентов.

Современные СУБД включают в себя словарь данных. Это часть базы данных, которая
описывает сами данные, хранящиеся в ней. Словарь данных помогает СУБД выполнять
свои функции.
** Основные понятия реляционной модели
В эпоху, предшествующую рождению реляционной теории, базы данных традиционно
рассматривались как набор *файлов*, состоящих из *записей*, а записи, в свою
очередь, подразделялись на отдельные *поля*. Поле являлось элементарной единицей
данных.

В реляционных базах данных пользователь воспринимает данные в виде таблиц.
Поэтому термину «файл» соответствует термин *«таблица»*, вместо термина «запись»
используется термин *«строка»*, а вместо термина «поле» — термин *«столбец»*
(или *«колонка»*).

В формальной теории реляционных баз данных эти таблицы называют *отношениями*
(*relations*) — поэтому и базы данных называются реляционными. Отношение — это
математический термин. При определении свойств таких отношений используется
теория множеств. В терминах данной теории строки таблицы будут называться
*кортежами* (*tuples*), а колонки — *атрибутами*. Отношение имеет заголовок,
который состоит из атрибутов, и тело, состоящее из кортежей. Количество
атрибутов называется *степенью отношения*, а количество кортежей — *кардинальным
числом*. Кроме теории множеств, одним из оснований реляционной теории является
такой раздел математической логики, как исчисление предикатов.

При работе с базами данных часто приходится следовать *различным ограничениям*,
которые могут быть обусловлены спецификой конкретной предметной области.

Для идентификации строк в таблицах и для связи таблиц между собой используются
так называемые ключи. *Потенциальный ключ* — это комбинация атрибутов таблицы,
позволяющая уникальным образом идентифицировать строки в ней. Ключ может
состоять только лишь из одного атрибута таблицы. Потенциальный ключ должен быть
*неизбыточным*, т.е. никакое подмножество атрибутов, входящих в него, не должно
обладать свойством уникальности. Ключ, состоящий из нескольких атрибутов
называется *составным*.

Ключи нужны для адресации на уровне строк (записей). При наличии в таблице более
одного потенциального ключа один из них выбирается в качестве так называемого
*первичного ключа*, а остальные будут являться *альтернативными ключами*.

*Внешним ключ* - это ключ, используемый для объединения двух таблиц. Таблица,
содержащая внешний ключ, называется *ссылающейся* таблицей (*referencing
table*). Таблица, содержащая соответствующий потенциальный ключ, называется
*ссылочной* (*целевой*) таблицей (*referenced table*). В таких случаях говорят,
что внешний ключ ссылается на потенциальный ключ в ссылочной таблице. Внешний
ключ может быть составным, т.е. может включать более одного атрибута. Внешний
ключ не обязан быть уникальным.

Проблема обеспечения того, чтобы база данных не содержала неверных значений
внешних ключей, известна как проблема *ссылочной целостности*. Ограничение,
согласно которому значения внешних ключей должны соответствовать значениям
потенциальных ключей, называется *ограничением ссылочной целостности*
(*ссылочным ограничением*).

Обеспечением выполнения ограничений ссылочной целостности занимается СУБД, а от
разработчика требуется лишь указать атрибуты, служащие в качестве внешних
ключей. При проектировании баз данных часто предусматривается, что при удалении
строки из ссылочной таблицы соответствующие строки из ссылающейся таблицы должны
быть также удалены, а при изменении значения столбца, на который ссылается
внешний ключ, должны быть изменены значения внешнего ключа в ссылающейся
таблице. Этот подход называется *каскадным удалением* (*обновлением*).

Иногда применяются и другие подходы. Например, вместо удаления строк из
ссылающейся таблицы в этих строках просто заменяют значения атрибутов, входящих
во внешний ключ, так называемыми *NULL*-значениями. Первичные ключи не могут
содержать NULL-значений.

*Транзакция* — одно из важнейших понятий теории баз данных. Она означает набор
операций над базой данных, рассматриваемых как единая и неделимая единица
работы, выполняемая полностью или не выполняемая вовсе, если произошел какойто
сбой в процессе выполнения транзакции. Таким образом, транзакции являются
*средством обеспечения согласованности данных*.
** Что такое язык SQL
Язык SQL — это непроцедурный язык, который является стандартным средством работы
с данными во всех реляционных СУБД. *Операторы* (*команды*), написанные на этом
языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают
процедуру получения этого результата. СУБД сама определяет способ выполнения
команды пользователя. В языке SQL традиционно выделяются группа операторов
определения данных (*Data Definition Language* — *DDL*), группа операторов
манипулирования данными (*Data Manipulation Language* — *DML*) и группа
операторов, управляющих привилегиями доступа к объектам базы данных (*Data
Control Language* — *DCL*).
* Основные операции с таблицами
Для создания таблиц в языке SQL служит команда ~CREATE TABLE~. Итак, команда для
создания нашей первой таблицы ~aircrafts~ такова:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  CREATE TABLE aircrafts(
    aircraft_code char(3) NOT NULL,
    model text NOT NULL,
    range integer NOT NULL,
    CHECK (range > 0),
    PRIMARY KEY (aircraft_code)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Значения всех атрибутов каждой строки данной таблицы должны быть определенными,
поэтому на них накладывается ограничение ~NOT NULL~. В принципе в таблицах базы
данных могут содержаться неопределенные значения некоторых атрибутов. Говоря
другими словами, их значения могут отсутствовать. В таких случаях в этих полях
содержится специальное значение ~NULL~.

К томуже атрибут ~range~ не должен принимать отрицательных значений и нулевого
значения, поэтому приходится добавить еще одно ограничение: ~range > 0~.

В качестве первичного ключа выбран атрибут ~aircraft_code~. Таким образом,
первичный ключ будет, как говорят, *естественным*. Это означает, что и в
реальной предметной области существует такое понятие, как код самолета, и это
понятие используется на практике. В отличие от естественных ключей иногда
используются и так называемые *суррогатные ключи*.

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d aircrafts
#+END_SRC

#+RESULTS:
#+begin_example
                   Table "public.aircrafts"
    Column     |     Type     | Collation | Nullable | Default
---------------+--------------+-----------+----------+---------
 aircraft_code | character(3) |           | not null |
 model         | text         |           | not null |
 range         | integer      |           | not null |
Indexes:
    "aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
Check constraints:
    "aircrafts_range_check" CHECK (range > 0)
Referenced by:
    TABLE "flights" CONSTRAINT "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    TABLE "seats" CONSTRAINT "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Для в вода данных в таблицу служит команда ~INSERT~. Давайте добавим одну строку
в таблицу ~aircrafts~.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range) VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC elixir :eval no :exports both
  %Aircraft{
    aircraft_code: "SU9",
    model: "Sukhoi SuperJet-100",
    range: 3000
  }
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:40:54.810 [debug] QUERY OK db=13.8ms decode=0.5ms queue=0.3ms idle=1.5ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3) ["SU9", "Sukhoi SuperJet-100", 3000]
: >>> :
: {:ok,
:  %AirDB.Aircraft{
:    __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:    aircraft_code: "SU9",
:    model: "Sukhoi SuperJet-100",
:    range: 3000,
:    seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:  }}

Давайте добавим еще несколько строк в таблицу ~aircrafts~. Команда ~INSERT~
позволяет сделать это за один раз.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range)
    VALUES ('773', 'Boeing 777-300', 11100),
           ('763', 'Boeing 767-300', 7900),
           ('733', 'Boeing 737-300', 4200),
           ('320', 'Airbus A320-200', 5700),
           ('321', 'Airbus A321-200', 5600),
           ('319', 'Airbus A319-100', 6700),
           ('CN1', 'Cessna 208 Caravan', 1200),
           ('CR2', 'Bombardier CRJ-200', 2700);
#+END_SRC

#+RESULTS:
: INSERT 0 8

#+BEGIN_SRC elixir :exports both :eval no
  Repo.insert_all(Aircraft, [
    %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
    %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
    %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
    %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
    %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
    %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
    %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
    %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
  ])
#+END_SRC

#+RESULTS:
: 13:37:23.199 [debug] QUERY OK db=3.4ms queue=0.5ms idle=28.0ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18),($19,$20,$21),($22,$23,$24) ["773", "Boeing 777-300", 11100, "763", "Boeing 767-300", 7900, "733", "Boeing 737-300", 4200, "320", "Airbus A320-200", 5700, "321", "Airbus A321-200", 5600, "319", "Airbus A319-100", 6700, "CN1", "Cessna 208 Caravan", 1200, "CR2", "Bombardier CRJ-200", 2700]
: >>> : {8, nil}

Давайте посмотрим, что содержится в таблице ~aircrafts~. Для этого служит
команда ~SELECT~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           733 | Boeing 737-300      |  4200 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           319 | Airbus A319-100     |  6700 |
|           CN1 | Cessna 208 Caravan  |  1200 |
|           CR2 | Bombardier CRJ-200  |  2700 |

#+BEGIN_SRC elixir :exports both :eval no
  select(Aircraft, [a], map(a, ^Aircraft.__schema__(:fields)))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 15:10:47.010 [debug] QUERY OK source="aircrafts" db=0.2ms decode=0.5ms queue=0.3ms idle=7.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 []
: >>> :
: [
:   %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3000},
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
: ]

Давайте упорядочим строки по значению атрибута ~model~, а заодно изменим порядок
расположения столбцов в выводе информации.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range FROM aircrafts ORDER BY model;
#+END_SRC

#+RESULTS:
| model               | aircraft_code | range |
|---------------------+---------------+-------|
| Airbus A319-100     |           319 |  6700 |
| Airbus A320-200     |           320 |  5700 |
| Airbus A321-200     |           321 |  5600 |
| Boeing 737-300      |           733 |  4200 |
| Boeing 767-300      |           763 |  7900 |
| Boeing 777-300      |           773 | 11100 |
| Bombardier CRJ-200  |           CR2 |  2700 |
| Cessna 208 Caravan  |           CN1 |  1200 |
| Sukhoi SuperJet-100 |           SU9 |  3000 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    order_by: a.model,
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> order_by([a], asc: a.model)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.211 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.8ms idle=16.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."model" []
: >>> :
: [
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3000}
: ]

Множество выбираемых строк можно ограничить с помощью предложения ~WHERE~
команды ~SELECT~. Давайте выберем модели самолетов, у которых максимальная
дальность полета находитсяв пределах от 4 до 6 тыс. км включительно. Условие
выбора строк может быть составным. В данном случае нужно скомбинировать два
ограничения с помощью логической операции ~AND~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range
    FROM aircrafts
   WHERE range >= 4000 AND range <= 6000;
#+END_SRC

#+RESULTS:
| model           | aircraft_code | range |
|-----------------+---------------+-------|
| Boeing 737-300  |           733 |  4200 |
| Airbus A320-200 |           320 |  5700 |
| Airbus A321-200 |           321 |  5600 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.range >= 4000 and a.range <= 6000,
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], a.range >= 4000 and a.range <= 6000)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.212 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.4ms idle=18.1ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE ((a0."range" >= 4000) AND (a0."range" <= 6000)) []
: >>> :
: [
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600}
: ]

Команда ~UPDATE~ предназначенна для обновления данных в таблицах. Условие,
указываемое в команде, должно ограничить диапазон обновляемых строк. Если это
условие не задать, то будут обновлены все строки в таблице.

Давайте предположим, что российские инженеры немного улучшили летные
характеристики самолета /Sukhoi SuperJet/, и теперь дальность его полета стала
на 500 км больше.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = 3500 WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "SU9"

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "SU9")
  |> Repo.update_all(set: [range: 3500])
#+END_SRC

#+RESULTS:
: 13:42:28.219 [debug] QUERY OK source="aircrafts" db=5.5ms queue=0.5ms idle=19.7ms
: UPDATE "aircrafts" AS a0 SET "range" = $1 WHERE (a0."aircraft_code" = 'SU9') [3500]
: >>> : {1, nil}

Давайте проверим, что получилось в результате обновления данных.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi SuperJet-100 |  3500 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "SU9",
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "SU9")
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.one()
#+END_SRC

#+RESULTS:
: 13:42:28.221 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.6ms idle=26.8ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'SU9') []
: >>> : %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3500}

Для удаления строк из таблиц используется команда ~DELETE~, которая похожа на
команду ~SELECT~. Удалим какую-нибудь одну строку из таблицы ~aircrafts~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
: DELETE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "CN1"

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "CN1")
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 13:42:28.226 [debug] QUERY OK source="aircrafts" db=4.2ms queue=0.4ms idle=28.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'CN1') []
: >>> : {1, nil}

Вы можете указать и какое-нибудь более сложное условие. Давайте, например,
удалим информацию о самолетах с дальностью полета более 10000 км, а также с
дальностью полета менее 3000 км:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE range > 10000 OR range < 3000;
#+END_SRC

#+RESULTS:
: DELETE 2

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.range > 10000 or a.range < 3000

  # macro example
  Aircraft
  |> where([a], a.range > 10000 or a.range < 3000)
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 14:03:41.612 [debug] QUERY OK source="aircrafts" db=4.5ms queue=0.5ms idle=39.0ms
: DELETE FROM "aircrafts" AS a0 WHERE ((a0."range" > 10000) OR (a0."range" < 3000)) []
: >>> : {2, nil}

При необходимости удаления всех строк из таблицы команда будет совсем простой:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts;
#+END_SRC

#+RESULTS:
: DELETE 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.delete_all(Aircraft)
#+END_SRC

#+RESULTS:
: 13:42:28.233 [debug] QUERY OK source="aircrafts" db=5.4ms queue=0.5ms idle=33.6ms
: DELETE FROM "aircrafts" AS a0 []
: >>> : {6, nil}

Теперь в таблице ~aircrafts~ нет ни одной строки.

Для таблицы ~aircrafts~ ближайшей «родственницей» является таблица ~seats~.

Значения атрибута ~fare_conditions~ могут выбираться из ограниченного списка
значений. Проверка на соответствие вводимых значений этому списку будет
обеспечиваться с помощью ограничения ~CHECK~.

В этой таблице используется *внешний ключ*. Предложение ~FOREIGN KEY~ создает
ограничение ссылочной целостности. В качестве внешнего ключа служит атрибут
~aircraft_code~. Он ссылается на одноименный атрибут в таблице ~aircrafts~.
Таблица ~seats~ называется *ссылающейся* (*referencing*), а таблица ~aircrafts~
— *ссылочной* (*referenced*).

Поскольку номера мест привязаны к модели самолета, то в случае удаления из
таблицы ~aircrafts~ какой-либо строки с конкретным кодом самолета необходимо
удалить также и из таблицы ~seats~ все строки, в которых значение атрибута
~aircraft_code~ такое же. Поэтому в предложении для определения внешнего ключа
появляется важное дополнение: ~ON DELETE CASCADE~. Это означает, что при
удалении какой-либо строки из таблицы ~aircrafts~ удаление строк из таблицы
~seats~, связанных с этой строкой по внешнему ключу, берет на себя СУБД,
избавляя программиста от этой заботы. Подобные действия, которые выполняет сама
СУБД, называются *каскадным удалением*. Таким образом, внешний ключ служит для
связи таблиц между собой.

Итак, команда для создания нашей второй таблицы ~seats~ такова:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  CREATE TABLE seats(
    aircraft_code char(3) NOT NULL,
    seat_no varchar(4) NOT NULL,
    fare_conditions varchar(10) NOT NULL,
    CHECK (fare_conditions IN ('Economy', 'Comfort', 'Business')),
    PRIMARY KEY (aircraft_code, seat_no),
    FOREIGN KEY (aircraft_code) REFERENCES aircrafts (aircraft_code) ON DELETE CASCADE
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d seats
#+END_SRC

#+RESULTS:
#+begin_example
                           Table "public.seats"
     Column      |         Type          | Collation | Nullable | Default
-----------------+-----------------------+-----------+----------+---------
 aircraft_code   | character(3)          |           | not null |
 seat_no         | character varying(4)  |           | not null |
 fare_conditions | character varying(10) |           | not null |
Indexes:
    "seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
Check constraints:
    "seats_fare_conditions_check" CHECK (fare_conditions::text = ANY (ARRAY['Economy'::text, 'Comfort'::text, 'Business'::text]))
Foreign-key constraints:
    "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Принципиально новым по сравнению с рассмотренной выше таблицей ~aircrafts~
является наличие ограничения внешнего ключа. Это ограничение имеет имя
~seats_aircraft_code_fkey~, сгенерированное самой СУБД. Давайте сразу же
проделаем эксперимент, позволяющий показать работу внешнего ключа. Выполните
следующую команду для ввода данных в таблицу ~seats~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES ('123', '1A', 'Business');
#+END_SRC

#+RESULTS:
: ERROR:  insert or update on table "seats" violates foreign key constraint "seats_aircraft_code_fkey"
: DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts".

#+BEGIN_SRC elixir :eval no :exports both
  Seat.changeset(%Seat{}, %{
    aircraft_code: "123",
    seat_no: "1A",
    fare_conditions: "Business"
  })
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:28:52.511 [debug] QUERY ERROR db=2.7ms queue=9.1ms idle=0.0ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3) ["123", "Business", "1A"]
: >>> :
: {:error,
:  #Ecto.Changeset<
:    action: :insert,
:    changes: %{aircraft_code: "123", fare_conditions: "Business", seat_no: "1A"},
:    errors: [
:      aircraft_code: {"does not exist",
:       [constraint: :foreign, constraint_name: "seats_aircraft_code_fkey"]}
:    ],
:    data: #AirDB.Seat<>,
:    valid?: false
:  >}

Теперь нужно заполнить данными таблицу ~seats~.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES
    ('SU9', '1A', 'Business'),
    ('SU9', '1B', 'Business'),
    ('SU9', '10A', 'Economy'),
    ('SU9', '10B', 'Economy'),
    ('SU9', '10F', 'Economy'),
    ('SU9', '20F', 'Economy');

  INSERT INTO seats VALUES
    ('773', '1A', 'Business'),
    ('773', '1B', 'Business'),
    ('773', '10A', 'Economy'),
    ('773', '10B', 'Economy'),
    ('773', '10F', 'Economy'),
    ('773', '20F', 'Economy');
#+END_SRC

#+RESULTS:
: INSERT 0 6
: INSERT 0 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "SU9", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.521 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["SU9", "Business", "1A", "SU9", "Business", "2B", "SU9", "Economy", "10A", "SU9", "Economy", "10B", "SU9", "Economy", "10F", "SU9", "Economy", "20F"]
: >>> : {6, nil}

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "773", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.601 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["773", "Business", "1A", "773", "Business", "2B", "773", "Economy", "10A", "773", "Economy", "10B", "773", "Economy", "10F", "773", "Economy", "20F"]
: >>> : {6, nil}

Теперь решим еще одну задачу. Предположим, что нам нужно получить информацию о
количестве мест в салонах для всех типов самолетов. Конечно, для решения задачи,
поставленной выше, в принципе можно воспользоваться такими командами:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    where: s.aircraft_code == "SU9"

  # macro example
  Seat
  |> where([s], s.aircraft_code == "SU9")
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 14:33:18.421 [debug] QUERY OK source="seats" db=0.3ms decode=0.4ms queue=0.5ms idle=3.0ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'SU9') []
: >>> : 6

И похожими для всех остальных самолетов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    where: s.aircraft_code == "CN1"

  # macro example
  Seat
  |> where([s], s.aircraft_code == "CN1")
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 14:33:18.427 [debug] QUERY OK source="seats" db=0.5ms queue=0.7ms idle=13.5ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'CN1') []
: >>> : 0

Очевидно, что это нерациональный подход. Язык SQL позволяет упростить решение
такой задачи за счет применения операции группирования строк на основе
некоторого критерия. В модифицированной команде вместо предложения ~WHERE~ будет
добавлено предложение ~GROUP BY~, которое отвечает за группировку строк с
одинаковыми значениями атрибута ~aircraft_code~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |
| 773           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: s.aircraft_code,
    select: %{aircraft_code: s.aircraft_code, count: count()}

  # macro example
  Seat
  |> group_by([s], s.aircraft_code)
  |> select([s], %{aircraft_code: s.aircraft_code, count: count()})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.428 [debug] QUERY OK source="seats" db=0.4ms queue=0.5ms idle=14.9ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" []
: >>> : [%{aircraft_code: "SU9", count: 6}]

Если мы захотим отсортировать выборку по числу мест в самолетах, то нужно будет
дополнить команду предложением ~ORDER BY~, которое обеспечит сортировку
результирующих строк по значениям второго столбца.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code
   ORDER BY count;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: s.aircraft_code,
    order_by: selected_as(:count),
    select: %{aircraft_code: s.aircraft_code, count: selected_as(count(), :count)}

  # macro example
  Seat
  |> group_by([s], s.aircraft_code)
  |> order_by(selected_as(:count))
  |> select([s], %{aircraft_code: s.aircraft_code, count: selected_as(count(), :count)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.429 [debug] QUERY OK source="seats" db=0.4ms queue=0.6ms idle=16.1ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" ORDER BY count []
: >>> : [%{aircraft_code: "SU9", count: 6}]

Теперь поставим более сложную задачу: подсчитать количество мест в салонах для
всех моделей самолетов, но теперь уже с учетом класса обслуживания (бизнес-класс
и экономический класс). В этом случае группировка выполняется уже по двум
атрибутам: ~aircraft_code~ и ~fare_conditions~. Отсортируем выборку по тем же
столбцам, по которым выполняли группировку.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         fare_conditions,
         count(*)
    FROM seats
   GROUP BY aircraft_code, fare_conditions
   ORDER BY aircraft_code, fare_conditions;
#+END_SRC

#+RESULTS:
| aircraft_code | fare_conditions | count |
|---------------+-----------------+-------|
| SU9           | Business        |     2 |
| SU9           | Economy         |     4 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: [s.aircraft_code, s.fare_conditions],
    order_by: [s.aircraft_code, s.fare_conditions],
    select: %{aircraft_code: s.aircraft_code, fare_condition: s.fare_conditions, count: count()}

  # macro example
  Seat
  |> group_by([s], [s.aircraft_code, s.fare_conditions])
  |> order_by([s], [s.aircraft_code, s.fare_conditions])
  |> select([s], %{
    aircraft_code: s.aircraft_code,
    fare_condition: s.fare_conditions,
    count: count()
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.431 [debug] QUERY OK source="seats" db=0.4ms queue=0.8ms idle=17.5ms
: SELECT s0."aircraft_code", s0."fare_conditions", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code", s0."fare_conditions" ORDER BY s0."aircraft_code", s0."fare_conditions" []
: >>> :
: [
:   %{aircraft_code: "SU9", count: 2, fare_condition: "Business"},
:   %{aircraft_code: "SU9", count: 4, fare_condiiton: "Economy"}
: ]
** Контрольные вопросы и задания
*** Вопрос 1
Попробуйте ввести в таблицу ~aircrafts~ строку с таким значением атрибута «Код
самолета» (~aircraft_code~), которое вы уже вводили, например:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO aircrafts VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

Вы получите сообщение об ошибке:

#+RESULTS:
: ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
: DETAIL:  Key (aircraft_code)=(SU9) already exists.

Обратите внимание, что в этой команде мы не привели список атрибутов, что вполне
допустимо при задании значений атрибутов в том же порядке, в котором атрибуты
следуют в определении таблицы. Но в ваших прикладных программах так поступать
все же не следует, поскольку в случае возможной реструктуризации таблицы и
изменения порядка следования атрибутов в ней ваши команды ~INSERT~ могут
перестать работать корректно.

Подумайте, почему появилось сообщение. Если вы забыли структуру таблицы
~aircrafts~, то можно вывести ее определение на экран с помощью команды ~\d
aircrafts~.

*ОТВЕТ*: Нарушен констрейнт - ~Key (aircraft_code)=(SU9) already exists~.
*** Вопрос 2
Предложение ~ORDER BY~ команды ~SELECT~ позволяет отсортировать данные при
выводе. По умолчанию сортировка выполняется по возрастанию значений атрибута,
указанного в этом предложении. Но можно упорядочить строки и по убыванию
значения атрибута. Для этого нужно после имени атрибута в предложении ~ORDER BY~
добавить ключевое слово ~DESC~ (это сокращение от слова /descendant/ — убывающий
порядок). Самостоятельно напишите команду для выборки всех строк из таблицы
~aircrafts~, чтобы строки были упорядочены по убыванию значения атрибута
«Максимальная дальность полета, км» (~range~).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts ORDER BY range DESC;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           319 | Airbus A319-100     |  6700 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           733 | Boeing 737-300      |  4200 |
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           CR2 | Bombardier CRJ-200  |  2700 |
|           CN1 | Cessna 208 Caravan  |  1200 |

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      order_by: [desc: a.range],
      select: map(a, [:aircraft_code, :model, :range])

  Repo.all(query)
#+END_SRC

#+RESULTS:
: 16:37:27.091 [debug] QUERY OK source="aircrafts" db=0.3ms queue=0.4ms idle=1772.2ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."range" DESC []
: >>> :
: [
  : %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
  : %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
  : %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
  : %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
  : %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
  : %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
  : %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
  : %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
  : %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200}
: ]
*** Вопрос 3
Команда ~UPDATE~ позволяет в процессе обновления выполнять арифметические
действия над значениями, находящимися в строках таблицы. Представим себе, что
двигатели самолета /Sukhoi SuperJet/ стали в два раза экономичнее, вследствие
чего дальность полета этого лайнера возросла ровно в два раза. Команда ~UPDATE~
позволяет увеличить значение атрибута ~range~ в строке, хранящей информацию об
этом самолете, даже не выполняя предварительно выборку с целью выяснения
текущего значения этого атрибута. При присваивании нового значения атрибуту
~range~ можно справа от знака ~=~ написать не только числовую константу, но и
целое выражение. В нашем случае оно будет простым: ~range = range * 2~.
Самостоятельно напишите команду ~UPDATE~ полностью, при этом не забудьте, что
увеличить дальность полета нужно только у одной модели — /Sukhoi SuperJet/,
поэтому необходимо использовать условие ~WHERE~. Затем с помощью команды
~SELECT~ проверьте полученный результат.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = range * 2 WHERE aircraft_code = 'SU9';
  SELECT range FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1
: range
: 6000

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      where: a.aircraft_code == "SU9",
      update: [set: [range: fragment("range * 2")]]

  Repo.update_all(query, [])
#+END_SRC

#+RESULTS:
: 16:41:34.417 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.2ms idle=1098.1ms
: UPDATE "aircrafts" AS a0 SET "range" = range * 2 WHERE (a0."aircraft_code" = 'SU9') []
: >>> : {0, nil}
*** Вопрос 4
Если в предложении ~WHERE~ команды ~DELETE~ вы укажете логически и синтаксически
корректное условие, но строк, удовлетворяющих этому условию, в таблице не
окажется, то в ответ СУБД выведет сообщение ~DELETE 0~.

Такая ситуация не является ошибкой или сбоем в работе СУБД. Например, если после
удаления какой-то строки вы повторно попытаетесь удалить ее же, то получите
именно такое сообщение. Самостоятельно смоделируйте описанную ситуацию, подобрав
условие, которому гарантированно не соответствует ни одна строка в таблице
«Самолеты» (~aircrafts~).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'XXX';
#+END_SRC

#+RESULTS:
: DELETE 0

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      where: a.aircraft_code == "XXX"

  Repo.delete_all(query)
#+END_SRC

#+RESULTS:
: 16:49:32.082 [debug] QUERY OK source="aircrafts" db=0.4ms idle=1764.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'XXX') []
: >>> : {0, nil}
* Типы данных СУБД PostgreSQL
** Числовые типы
Группа числовых типов данных включает в себя целый ряд разновидностей:
целочисленные типы, числа фиксированной точности, типы данных с плавающей
точкой, последовательные типы (~serial~).

В составе целочисленных типов находятся следующие представители: ~smallint~,
~integer~, ~bigint~. Если атрибут таблицы имеет один из этих типов, то он
позволяет хранить только целочисленные данные. При этом перечисленные типы
различаются по количеству байтов, выделяемых для хранения данных. В PostgreSQL
существуют псевдонимы для этих стандартизированных имен типов, а именно: ~int2~,
~int4~ и ~int8~. Число байтов отражается в имени типа.

Числа фиксированной точности представлены двумя типами — ~numeric~ и ~decimal~.
Однако они являются идентичными по своим возможностям. Числа типа ~numeric~
могут хранить очень большое количество цифр: 131072 цифры — до десятичной точки
(запятой), 16383 — после точки. Его главное достоинство — это обеспечение
/точных/ результатов при выполнении вычислений, когда это, конечно, возможно в
принципе. Для задания значения этого типа используются два базовых понятия:
*масштаб* (*scale*) и *точность* (*precision*). Масштаб показывает число
значащих цифр, стоящих справа от десятичной точки (запятой). Точность указывает
общее число цифр как до десятичной точки, так и после нее. Параметры этого типа
данных указываются в круглых скобках после имени типа: ~numeric(точность,
масштаб)~.

Представителями типов данных с плавающей точкой являются типы ~real~ и ~double
precision~. Они представляют собой реализацию стандарта IEEE «Standard 754 for
Binary Floating-Point Arithmetic». Тип данных ~real~ может представить числа в
диапазоне, как минимум, от 1E−37 до 1E+37 с точностью не меньше 6 десятичных
цифр. Тип ~double precision~ имеет диапазон значений примерно от 1E−307 до
1E+308 с точностью не меньше 15 десятичных цифр.

При попытке записать в такой столбец слишком большое или слишком маленькое
значение будет генерироваться ошибка. Если точность вводимого числа выше
допустимой, то будет иметь место округление значения. А вот при вводе очень
маленьких чисел, которые невозможно представить значениями, отличными от нуля,
будет генерироваться *ошибка потери значимости*, или исчезновения значащих
разрядов (*an underflow error*).

При работе с числами таких типов нужно помнить, что сравнение двух чисел с
плавающей точкой на предмет равенства их значений может привести к неожиданным
результатам:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 0.1::real * 10 = 1.0::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| f        |

В дополнение к обычным числам эти типы данных поддерживают и специальные
значения ~Infinity~ (бесконечность), ~−Infinity~ (отрицательная бесконечность) и
~NaN~ (нечисло).

PostgreSQL поддерживает также тип данных ~float~, определенный в стандарте SQL.
В объявлении типа может использоваться параметр: ~float(p)~. Если его значение
лежит в диапазоне от 1 до 24, то это будет равносильно использованию типа
~real~, а если же значение лежит в диапазоне от 25 до 53, то это будет
равносильно использованию типа ~double precision~. Если же при объявлении типа
параметр не используется, то это также будет равносильно использованию типа
~double precision~.

Последним из числовых типов является тип ~serial~. Однако он фактически
реализован не как настоящий тип, а просто как удобная замена целой группы
SQL-команд. Тип ~serial~ удобен в тех случаях, когда требуется в какой-либо
столбец вставлять уникальные целые значения, например, значения суррогатного
первичного ключа. Кроме типа ~serial~ существуют еще два аналогичных типа:
~bigserial~ и ~smallserial~. Им фактически, за кадром, соответствуют типы
~bigint~ и ~smallint~.
** Символьные (строковые) типы
Стандартные представители строковых типов — это типы ~character varying(n)~ и
~character(n)~, где параметр указывает максимальное число символов в строке,
которую можно сохранить в столбце такого типа. При работе с многобайтовыми
кодировками символов, например UTF-8, нужно учитывать, что речь идет о символах,
а не о байтах. Если сохраняемая строка символов будет короче, чем указано в
определении типа, то значение типа ~character~ будет дополнено пробелами до
требуемой длины, а значение типа ~character varying~ будет сохранено так, как
есть. Типы ~character varying(n)~ и ~character(n)~ имеют псевдонимы ~varchar(n)~
и ~char(n)~ соответственно.

PostgreSQL дополнительно предлагает еще один символьный тип — ~text~. В столбец
этого типа можно ввести сколь угодно большое значение, конечно, в пределах,
установленных при компиляции исходных текстов СУБД.

Константы символьных типов в SQL-командах заключаются в одинарные кавычки. В том
случае, когда в константе содержится символ одинарной кавычки или обратной косой
черты, их необходимо удваивать.

В том случае, когда таких символов в константе много, все выражение становится
трудно воспринимать. На помощь может прийти использование удвоенного символа
«$». Эти символы выполняют ту же роль, что и одинарные кавычки, когда в них
заключается строковая константа. При использовании символов «$» в качестве
ограничителей уже не нужно удваивать никакие символы, содержащиеся в самой
константе: ни одинарные кавычки, ни символы обратной косой черты.

PostgreSQL предлагает еще одно расширение стандарта SQL — строковые константы в
стиле языка C. Чтобы иметь возможность их использовать, нужно перед начальной
одинарной кавычкой написать символ «E». При использовании C-стиля необходимо
удваивать обратную косую черту, если требуется поместить ее в константу
буквально. А для включения в содержимое константы символа обратной кавычки можно
либо удвоить ее, либо спрятать за обратной косой чертой.
** Типы «дата/время»
Даты обрабатываются в соответствии с григорианским календарем, причем это
делается даже в тех случаях, когда дата относится к тому моменту времени, когда
этот календарь в данной стране еще не был принят.

Начнем рассмотрение с типа ~date~. Рекомендуемый стандартом ISO 8601 формат
ввода дат таков: ~yyyy-mm-dd~, где символы ~y~, ~m~ и ~d~ обозначают цифру года,
месяца и дня соответственно. При выводе значений PostgreSQL использует формат по
умолчанию, если не предписан другой формат. По умолчанию используется формат,
рекомендуемый стандартом ISO 8601: ~yyyy-mm-dd~.

Для получения значения текущей даты служит функция ~current_date~. Ее
особенностью является то, что при ее вызове круглые скобки не используются.
Текущее время выводится с высокой точностью и дополняется числовым значением,
соответствующим локальному часовому поясу, который установлен в конфигурационном
файле сервера.

Если нам требуется вывести дату в другом формате, то для разового преобразования
формата можно использовать функцию ~to_char(date, 'dd-mm-yyyy');~

Для хранения времени суток служат два типа данных: ~time~ и ~time with time
zone~. Первый из них хранит только время суток, а второй — дополнительно — еще и
часовой пояс. Однако документация на PostgreSQL не рекомендует использовать тип
~time with time zone~, поскольку *смещение* (*offset*), соответствующее
конкретному часовому поясу, может зависеть от даты перехода на летнее время и
обратно, но в этом типе дата отсутствует. Время можно вводить не только в
24-часовом формате, но и в 12-часовом, при этом нужно использовать
дополнительные суффиксы ~am~ и ~pm~.

Для получения значения текущего времени служит функция ~current_time~. Она также
вызывается без указания круглых скобок.

В результате объединения типов даты и времени получается интегральный тип —
временная отметка. Этот тип существует в двух вариантах: с учетом часового пояса
— ~timestamp with time zone~, либо без учета часового пояса — ~timestamp~. Для
первого варианта существует сокращенное наименование — ~timestamptz~. Оба типа
занимают один и тот же объем 8 байтов, но значения типа ~timestamptz~ хранятся,
будучи приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся
к часовому поясу пользователя.

Для получения значения текущей временной отметки (т.е. даты и времени в одном
значении) служит функция ~current_timestamp~. Она также вызывается без указания
круглых скобок.

Последним типом является ~interval~, который представляет продолжительность
отрезка времени между двумя моментами времени. Его формат ввода таков: ~quantity
unit [quantity unit ...] direction~. Можно использовать альтернативный формат,
предлагаемый стандартом ISO 8601: ~P [ years-months-days ] [ T hours:minutes:seconds ]~

Здесь ~unit~ означает единицу измерения, а ~quantity~ — количество таких единиц.
В качестве единиц измерения можно использовать следующие: ~microsecond~,
~millisecond~, ~second~, ~minute~, ~hour~, ~day~, ~week~, ~month~, ~year~,
~decade~, ~century~, ~millennium~. Параметр ~direction~ может принимать значение
~ago~ (т.е. «тому назад») либо быть пустым.

Поскольку интервал — это отрезок времени между двумя временными отметками, то
значение этого типа можно получить при вычитании одной временной отметки из
другой.

Значения временных отметок можно усекать с той или иной точностью с помощью
функции ~date_trunc(точность, время)~.

Из значений временных отметок можно с помощью функции ~extract(поле FROM время)~
извлекать отдельные поля, т.е. год, месяц, день, число часов, минут или секунд и
т.д
** Логический тип
Логический (~boolean~) тип может принимать три состояния: истина и ложь, а также
неопределенное состояние, которое можно представить значением ~NULL~. Таким
образом, тип ~boolean~ реализует трехзначную логику.

В качестве истинного состояния могут служить следующие значения: ~TRUE~, ~'t'~,
~'true'~, ~'y'~, ~'yes'~, ~'on'~, ~'1'~.

В качестве ложного состояния могут служить следующие значения: ~FALSE~, ~'f'~,
~'false'~, ~'n'~, ~'no'~, ~'off'~, ~'0'~.
** Массивы
*TODO* продублировать запросы используя Ecto

Массивы могут быть многомерными и могут содержать значения любого из встроенных
типов, а также типов данных, определенных пользователем. Массив в команде
вставки представленв виде строкового литерала с указанием типа данных и
квадратных скобок, означающих массив.

Предположим, что нам необходимо сформировать и сохранить в базе данных в удобной
форме графики работы пилотов авиакомпании, т.е. номера дней недели, когда они
совершают полеты.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE pilots (pilot_name text, schedule integer[]);
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots
         VALUES ('Ivan',  '{1, 3, 5, 6, 7}'::integer[]),
                ('Petr',  '{1, 2, 5, 7}'::integer[]),
                ('Pavel', '{2, 5}'::integer[]),
                ('Boris', '{3, 5, 6}'::integer[]);
#+END_SRC

#+RESULTS:
: INSERT 0 4

Предположим, что руководство компании решило, что каждый пилот должен летать 4
раза в неделю. Значит, нам придется обновить значения в таблице. Пилоту по имени
Boris добавим один день с помощью операции конкатенации ~||~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = schedule || 7
   WHERE pilot_name ='Boris';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {2,5,6}     |
| Petr       | {1,2,5,7}   |

Пилоту по имени Pavel добавим один день в конец списка (массива) с помощью
функции ~array_append~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_append(schedule, 6)
   WHERE pilot_name ='Pavel';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {2,5,6}     |
| Petr       | {1,2,5,7}   |

Ему же добавим один день в начало списка с помощью функции ~array_prepend~
(обратите внимание, что параметры функции поменялись местами):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_prepend(1, schedule)
   WHERE pilot_name = 'Pavel';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {1,2,5,6}   |
| Petr       | {1,2,5,7}   |

У пилота по имени Ivan имеется лишний день в графике. С помощью функции
~array_remove~ удалим из графика пятницу (второй параметр функции указывает
значение элемента массива, а не индекс):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_remove(schedule, 5)
   WHERE pilot_name = 'Ivan';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {1,2,5,7} |

У пилота по имени Petr изменим дни полетов, не изменяя их общего количества.
Воспользуемся индексами для работы на уровне отдельных элементов массива. По
умолчанию нумерация индексов начинается *с единицы*, а не с нуля. При
необходимости ее можно изменить. К элементам одного и того же массива можно
обращаться в предложении ~SET~ по отдельности, как будто это разные столбцы.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule[1] = 2,
         schedule[2] = 3
   WHERE pilot_name = 'Petr';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

А можно было бы, используя *срез* (*slice*) массива, сделать и так:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule[1:2] = ARRAY[2, 3]
   WHERE pilot_name = 'Petr';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

Теперь продемонстрируем основные операции, которые можно применять к массивам,
выполняя выборки из таблиц.

Функция ~array_position~ возвращает индекс первого вхождения элемента с
указанным значением в массив. Если же такого элемента нет, она возвратит ~NULL~.
Получим список пилотов, летающих по средам:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE array_position(schedule, 3) IS NOT NULL;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Petr       | {2,3,5,7} |

Оператор ~@>~ означает проверку того факта, что в левом массиве содержатся все
элементы правого массива. Конечно, при этом в левом массиве могут находиться и
другие элементы. Выберем пилотов, летающих по понедельникам и воскресеньям:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE schedule @> '{1, 7}'::integer[];
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Ivan       | {1,3,6,7} |

Еще аналогичный вопрос: кто летает по вторникам и/или по пятницам? Для получения
ответа воспользуемся оператором ~&&~, который проверяет наличие общих элементов
у массивов, т.е. пересекаются ли их множества значений.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE schedule && ARRAY[2, 5];
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

Сформулируем вопрос в форме отрицания: кто не летает ни во вторник, ни в
пятницу?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE NOT (schedule && ARRAY[2, 5]);
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Ivan       | {1,3,6,7} |

Иногда требуется развернуть массив в виде столбца таблицы. В таком случае
поможет функция ~unnest~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT unnest(schedule) AS days_of_week
    FROM pilots
   WHERE pilot_name = 'Ivan';
#+END_SRC

#+RESULTS:
| days_of_week |
|--------------|
|            1 |
|            3 |
|            6 |
|            7 |
** Типы JSON
*TODO* продублировать запросы используя Ecto

Типы JSON предназначены для сохранения в столбцах таблиц базы данных таких
значений, которые представлены в формате /JSON/ (JavaScript Object Notation).
Существует два типа: ~json~ и ~jsonb~. Основное различие между ними заключается
в быстродействии. Если столбец имеет тип ~json~, тогда сохранение значений
происходит быстрее, потому что они записываются в том виде, в котором были
введены. Но при последующем использовании этих значений в качестве операндов или
параметров функций будет каждый раз выполняться их разбор, что замедляет работу.
При использовании типа ~jsonb~ разбор производится однократно, при записи
значения в таблицу. Это несколько замедляет операции вставки строк, в которых
содержатся значения данного типа. Но все последующие обращения к сохраненным
значениям выполняются быстрее, т.к. выполнять их разбор уже не требуется.

Есть еще ряд отличий, в частности, тип ~json~ сохраняет порядок следования
ключей в объектах и повторяющиеся значения ключей, а тип ~jsonb~ этого не
делает. Рекомендуется в приложениях использовать тип ~jsonb~, если только нет
какихто особых аргументов в пользу выбора типа ~json~.

Для иллюстрации использования типов JSON обратимся к тематике авиаперевозок.
Разработчики базы данных авиакомпании получили задание создать специальную
таблицу, в которую будут заноситься сведения о тех видах спорта, которыми
занимается пилот, будет отмечаться наличие у него домашней библиотеки, а также
фиксироваться количество стран, которые он посетил в ходе туристических поездок.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE pilot_hobbies(pilot_name text, hobbies jsonb);
  INSERT INTO pilot_hobbies
    VALUES ('Ivan',  '{"sports": ["футбол", "плавание"], "home_lib": true, "trips": 3}'::jsonb),
           ('Petr',  '{"sports": ["теннис", "плавание"],"home_lib": true, "trips": 2}'::jsonb),
           ('Pavel', '{"sports": ["плавание"], "home_lib": false, "trips": 4}'::jsonb),
           ('Boris', '{"sports": ["футбол", "плавание", "теннис"],"home_lib": true, "trips": 0}'::jsonb);
#+END_SRC

#+RESULTS:
: CREATE TABLE
: INSERT 0 4

Предположим, что нужно сформировать футбольную сборную команду нашей
авиакомпании для участия в турнире. Мы можем выбрать всех футболистов таким
способом:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilot_hobbies
   WHERE hobbies @> '{"sports": ["футбол"]}'::jsonb;
#+END_SRC

#+RESULTS:
| pilot_name | hobbies                                                                    |
|------------+----------------------------------------------------------------------------|
| Ivan       | {"trips": 3, "sports": ["футбол", "плавание"], "home_lib": true}           |
| Boris      | {"trips": 0, "sports": ["футбол", "плавание", "теннис"], "home_lib": true} |

Можно было эту задачу решить и таким способом. Операция ~->~ служит для
обращения к конкретному ключу JSON-объекта. В этом решении мы выводим только
информацию о спортивных предпочтениях пилотов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies -> 'sports' AS sports
    FROM pilot_hobbies
   WHERE hobbies->'sports' @> '["футбол"]'::jsonb;
#+END_SRC

#+RESULTS:
| pilot_name | sports                           |
|------------+----------------------------------|
| Ivan       | ["футбол", "плавание"]           |
| Boris      | ["футбол", "плавание", "теннис"] |

Как можно проверить наличие ключа? Продемонстрируем это:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM pilot_hobbies
   WHERE hobbies ? 'sport';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

А вот ключ ~sports~ присутствует. Выполним ту же проверку:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM pilot_hobbies
   WHERE hobbies ? 'sports';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     4 |

А как выполнять обновление JSON-объектов в строках таблицы? Предположим, что
пилот по имени Boris решил посвятить себя только хоккею. Тогда в базе данных мы
выполним такую операцию:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = hobbies || '{"sports": ["хоккей"]}'
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports results :eval no
  SELECT pilot_name, hobbies
    FROM pilot_hobbies
   WHERE pilot_name = 'Boris';
#+END_SRC

Проверим, что получилось:

#+RESULTS:
| pilot_name | hobbies                                              |
|------------+------------------------------------------------------|
| Boris      | {"trips": 0, "sports": ["хоккей"], "home_lib": true} |

Если впоследствии Boris захочет возобновить занятия футболом, то с помощью
функции ~jsonb_set~ можно будет обновить сведения о нем в таблице:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"')
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
: UPDATE 1

Второй параметр функции указывает путь в пределах JSON-объекта, куда нужно
добавить новое значение. В данном случае этот путь состоит из имени ключа
(~sports~) и номера добавляемого элемента в массиве видов спорта (номер 1).
Нумерация элементов начинается с нуля. Третий параметр имеет тип ~jsonb~,
поэтому его литерал заключается в одинарные кавычки, а само добавляемое значение
берется в двойные кавычки. В результате получается — ~'"футбол"'~.

Проверим успешность выполнения этой операции:

#+BEGIN_SRC sql :engine postgres :exports results :eval no
  SELECT pilot_name, hobbies
    FROM pilot_hobbies
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
| pilot_name | hobbies                                                        |
|------------+----------------------------------------------------------------|
| Boris      | {"trips": 0, "sports": ["хоккей", "футбол"], "home_lib": true} |
** Контрольные вопросы и задания
*** Вопрос 1
Создайте таблицу, содержащую атрибут типа ~numeric(precision, scale)~. Пусть это
будет таблица, содержащая результаты каких-то измерений. Команда может быть,
например, такой:

src_sql[:exports code]{CREATE TABLE test_numeric(measurement numeric(5, 2),
description text);}

Попробуйте с помощью команды ~INSERT~ продемонстрировать округление вводимого
числа до той точности, которая задана при создании таблицы. Подумайте, какая из
следующих команд вызовет ошибку и почему? Проверьтесвои предположения, выполнив
эти команды.
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9999,
  'Какое-то измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9009, 'Еще
  одно измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.1111, 'И еще
  измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (998.9999, 'И еще
  одно');}

Продемонстрируйте генерирование ошибки при попытке ввода числа, количество цифр
в котором слева от десятичной точки (запятой) превышает допустимое.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP table test_numeric;
  CREATE TABLE test_numeric(measurement numeric(5, 2), description text);
  -- INSERT INTO test_numeric VALUES (999.9999, 'Какое-то измерение');
  INSERT INTO test_numeric VALUES (999.9009, 'Еще одно измерение');
  INSERT INTO test_numeric VALUES (999.1111, 'И еще измерение');
  INSERT INTO test_numeric VALUES (998.9999, 'И еще одно');
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_numeric;
#+END_SRC

#+RESULTS:
| measurement | description        |
|-------------+--------------------|
|      999.90 | Еще одно измерение |
|      999.11 | И еще измерение    |
|      999.00 | И еще одно         |

src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9999, 'Какое-то
 измерение');} вызывает переполнение типа:

: ERROR:  numeric field overflow
: DETAIL:  A field with precision 5, scale 2 must round to an absolute value less than 10^3.
*** Вопрос 2
Предположим, что возникла необходимость хранить в одном столбце таблицы данные,
представленные с различной точностью. Это могут быть, например, результаты
физических измерений разнородных показателей или различные медицинские
показатели здоровья пациентов (результаты анализов). В таком случае можно
использовать тип ~numeric~ без указания масштаба и точности.

Команда для создания таблицы может быть, например, такой:

src_sql[:exports code]{CREATE TABLE test_numeric(measurement numeric,
description text);}

Если у вас в базе данных уже есть таблица с таким же именем, то можно
предварительно ее удалить с помощью команды:

src_sql[:exports code]{DROP TABLE test_numeric;}

Вставьте в таблицу несколько строк:
- src_sql[:exports code]{INSERT INTO test_numeric VALUES
  (1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (1.5, 'Точность 2
  знака, масштаб 1 знак');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES
  (0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (1234567890,
  'Точность 10 знаков, масштаб 0 знаков (целое число)');}

Теперь сделайте выборку из таблицы и посмотрите, что все эти
разнообразныезначения сохранены именно в том виде, как вы их вводили.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP table test_numeric;
  CREATE TABLE test_numeric(measurement numeric, description text);
  INSERT INTO test_numeric VALUES (1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков');
  INSERT INTO test_numeric VALUES (1.5, 'Точность 2 знака, масштаб 1 знак');
  INSERT INTO test_numeric VALUES (0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков');
  INSERT INTO test_numeric VALUES (1234567890, 'Точность 10 знаков, масштаб 0 знаков (целое число)');
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_numeric;
#+END_SRC

#+RESULTS:
|            measurement | description                                        |
|------------------------+----------------------------------------------------|
|  1234567890.0987654321 | Точность 20 знаков, масштаб 10 знаков              |
|                    1.5 | Точность 2 знака, масштаб 1 знак                   |
| 0.12345678901234567890 | Точность 21 знак, масштаб 20 знаков                |
|             1234567890 | Точность 10 знаков, масштаб 0 знаков (целое число) |
*** Вопрос 3
Тип данных ~numeric~ поддерживает специальное значение ~NaN~, которое означает
/not a number/. В документации утверждается, что значение ~NaN~ считается равным
другому значению ~NaN~, а также что значение ~NaN~ считается большим любого
другого «нормального» значения, т.е. ~не-NaN~. Проверьте эти утверждения с
помощью SQL-команды ~SELECT~. В качестве примера приведем команду:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric > 10000;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric = 'NaN'::numeric;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric > 10^99999::numeric;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 4
При работе с числами типов ~real~ и ~double precision~ нужно помнить, что
сравнение двух чисел с плавающей точкой на предмет равенства их значений может
привести к неожиданным результатам. Например, сравним два очень маленьких числа
(они представлены в экспоненциальной форме записи):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '5e-324'::double precision > '4e-324'::double precision;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| f        |

Чтобы понять, почему так получается, выполните еще запрос:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '5e-324'::double precision, '4e-324'::double precision;
#+END_SRC

#+RESULTS:
| float8 | float8 |
|--------+--------|
| 5e-324 | 5e-324 |

Самостоятельно проведите аналогичные эксперименты с очень большими числами,
находящимися на границе допустимого диапазона для чисел типов ~real~ и ~double
precision~.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '1e+308'::double precision, '1.79e+308'::double precision;
#+END_SRC

#+RESULTS:
| float8 |    float8 |
|--------+-----------|
| 1e+308 | 1.79e+308 |
*** Вопрос 5
Типы данных ~real~ и ~double precision~ поддерживают специальные значения
~Infinity~ (бесконечность) и ~−Infinity~ (отрицательная бесконечность).
Проверьте с помощью SQL-команды ~SELECT~ ожидаемые свойства этих значений.
Например, сравните ~Infinity~ с наибольшим значением, которое допускается для
типа ~double precision~ (можно использовать сокращенное написание ~Inf~):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'Inf'::double precision > 1e+308;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '-Inf'::double precision < '5e-324'::double precision;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 6
Типы данных ~real~ и ~double precision~ поддерживают специальное значение ~NaN~,
которое означает «не число» (not a number).

В математике существует такое понятие, как /неопределенность/. В качестве одного
из ее вариантов служит результат операции умножения нуля на бесконечность.
Посмотрите, что выдаст в результате PostgreSQL:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 0.0 * 'Inf'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
|      NaN |

В документации утверждается, что значение ~NaN~ считается равным другому
значению ~NaN~, а также что значение ~NaN~ считается большим любого другого
«нормального» значения, т.е. ~не-NaN~. Проверьте эти утверждения с помощью
SQL-команды ~SELECT~.

Например, сравните значения ~NaN~ и ~Infinity~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::real > 'Inf'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::real = 'NaN'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::real > '1e+30'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 7
Тип ~serial~ может применяться для столбцов, содержащих числовые значения,
которые должны быть уникальными в пределах таблицы, например, идентификаторы
каких-то объектов. В качестве иллюстрации применения типа ~serial~ предложим
таблицу, содержащую наименования улиц и площадей:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  CREATE TABLE test_serial(id serial, name text);
#+END_SRC

#+RESULTS:
: CREATE TABLE

Введите несколько строк. Обратите внимание, что значение для столбца ~id~
указывать не обязательно (и даже не нужно). Но поскольку мы задаем значения не
для всех столбцов, имеющихся в таблице, мы должны указать в команде ~INSERT~ не
только список значений, но и список столбцов. Конечно, в данном простом случае
эти списки состоят лишь из одного элемента.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO test_serial (name) VALUES ('Вишневая');
  INSERT INTO test_serial (name) VALUES ('Грушевая');
  INSERT INTO test_serial (name) VALUES ('Зеленая');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

Сделайте выборку данных из таблицы, вы увидите, что значения столбца ~id~ имеют
последовательные значения, начиная с 1.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name     |
|----+----------|
|  1 | Вишневая |
|  2 | Грушевая |
|  3 | Зеленая  |

Давайте проведем эксперимент со столбцом ~id~. Выполните команду ~INSERT~, в
которой укажите явное значение столбца ~id~:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO test_serial (id, name) VALUES (10, 'Прохладная');
#+END_SRC

#+RESULTS:
: INSERT 0 1

А теперь добавьте еще одну строку, но уже не указывая явно значение для
столбца ~id~ (как мы поступали в предыдущих командах):

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO test_serial (name) VALUES ('Луговая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name       |
|----+------------|
|  1 | Вишневая   |
|  2 | Грушевая   |
|  3 | Зеленая    |
| 10 | Прохладная |
|  4 | Луговая    |

Вы увидите, что явное задание значения для столбца ~id~ не влияет на
автоматическое генерирование значений этого столбца.
*** Вопрос 8
Немного усложним определение таблицы из предыдущего задания. Пусть теперь
столбец ~id~ будет первичным ключом этой таблицы.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE test_serial;
  CREATE TABLE test_serial(id serial PRIMARY KEY, name text);
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

Теперь выполните следующие команды для добавления строк в таблицу и удаления
одной строки из нее. Для пошагового управления этим процессом выполняйте выборку
данных из таблицы с помощью команды ~SELECT~ после каждой команды вставки или
удаления.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  INSERT INTO test_serial (name) VALUES ('Вишневая');
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name     |
|----+----------|
|  1 | Вишневая |

Явно зададим значение столбца ~id~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  INSERT INTO test_serial (id, name) VALUES (2, 'Прохладная');
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name       |
|----+------------|
|  1 | Вишневая   |
|  2 | Прохладная |

При выполнении этой команды СУБД выдаст сообщение об ошибке. Почему?

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Грушевая');
#+END_SRC

#+RESULTS:
: ERROR:  duplicate key value violates unique constraint "test_serial_pkey"
: DETAIL:  Key (id)=(2) already exists.

*ОТВЕТ*: команда вставки с явно указанным значением столбца ~id~ не
икрементировала значение ~sequence~ связанного с этим столбцом.

Повторим эту же команду. Теперь все в порядке. Почему?

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Грушевая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

*ОТВЕТ*: откат транзакции не приводит к откату на предыдущее значение
~sequence~.

Добавим еще одну строку.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Зеленая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

А теперь удалим ее же.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM test_serial WHERE id = 4;
#+END_SRC

#+RESULTS:
: DELETE 1

Добавим последнюю строку.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Луговая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

Теперь сделаем выборку.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name       |
|----+------------|
|  1 | Вишневая   |
|  2 | Прохладная |
|  3 | Грушевая   |
|  5 | Луговая    |

Вы увидите, что в нумерации образовалась «дыра». Это из-за того, что при
формировании нового значения из последовательности поиск максимального значения,
уже имеющегося в столбце, не выполняется.
*** Вопрос 9
Какой календарь используется в PostgreSQL для работы с датами: юлианский или
григорианский?

*ОТВЕТ*: григорианский
*** Вопрос 10
Каждый тип данных из группы «дата/время» имеет ограничение на минимальное и
максимальное допустимое значение. Найдите в документации в разделе 8.5 «Типы
даты/времени» эти значения и подумайте, почему они таковы.

| Имя                                     | Размер  | Описание                              | Наименьшее значение | Наибольшее значение | Точность                 |
|-----------------------------------------+---------+---------------------------------------+---------------------+---------------------+--------------------------|
| timestamp [ (p) ] [ without time zone ] | 8 байт  | дата и время (без часового пояса)     | 4713 до н. э.       | 294276 н. э.        | 1 микросекунда / 14 цифр |
| timestamp [ (p) ] with time zone        | 8 байт  | дата и время (с часовым поясом)       | 4713 до н. э.       | 294276 н. э.        | 1 микросекунда / 14 цифр |
| date                                    | 4 байта | дата (без времени суток)              | 4713 до н. э.       | 5874897 н. э.       | 1 день                   |
| time [ (p) ] [ without time zone ]      | 8 байт  | время суток (без даты)                | 00:00:00            | 24:00:00            | 1 микросекунда / 14 цифр |
| time [ (p) ] with time zone             | 12 байт | только время суток (с часовым поясом) | 00:00:00+1559       | 24:00:00-1559       | 1 микросекунда / 14 цифр |
| interval [ поля ] [ (p) ]               | 16 байт | временной интервал                    | -178000000 лет      | 178000000 лет       | 1 микросекунда / 14 цифр |
*** Вопрос 11
Типы ~timestamp~, ~time~ и ~interval~ позволяют задать точность ввода и вывода
значений. Точность предписывает количество десятичных цифр в поле секунд.
Проиллюстрируем эту возможность на примере типа ~time~, выполнив три запроса: в
первом запросе вообще не используем параметр точности, во втором назначим его
равным 0, в третьем запросе сделаем его равным 3.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT current_time AS first,
         current_time::time(0) AS second,
         current_time::time(3) AS third;
#+END_SRC

#+RESULTS:
|              first |   second |       third |
|--------------------+----------+-------------|
| 20:20:04.330104+02 | 20:20:04 | 20:20:04.33 |

Выполните подобные команды для типов ~timestamp~ и ~interval~.

Тип ~date~ такой возможности — задавать точность — не имеет. Как вы думаете,
почему?

*ОТВЕТ*:

Тип ~date~ не хранит секунды.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT current_timestamp AS first,
         current_timestamp::timestamptz(0) AS second,
         current_timestamp::timestamptz(3) AS third;
#+END_SRC

#+RESULTS:
| first                         | second                 | third                      |
|-------------------------------+------------------------+----------------------------|
| 2021-04-08 20:23:43.408871+02 | 2021-04-08 20:23:43+02 | 2021-04-08 20:23:43.409+02 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '1 day 15 seconds 12345 milliseconds ago'::interval AS first,
         '1 day 15 seconds 12345 milliseconds ago'::interval(0) AS second,
         '1 day 15 seconds 12345 milliseconds ago'::interval(2) AS third;
#+END_SRC

#+RESULTS:
| first                 | second            | third                |
|-----------------------+-------------------+----------------------|
| -1 days -00:00:27.345 | -1 days -00:00:27 | -1 days -00:00:27.35 |
*** Вопрос 12
Формат ввода и вывода даты можно изменить с помощью конфигурационного параметра
~datestyle~. Значение этого параметра состоит из двух компонентов: первый
управляет форматом вывода даты, а второй регулирует порядок следования составных
частей даты (год, месяц, день) при вводе и выводе. Текущее значение этого
параметра можно узнать с помощью команды ~SHOW~: src_sql[:exports code]{SHOW
datestyle;}

По умолчанию он имеет такое значение:

#+BEGIN_EXAMPLE
asakura=# show datestyle;
 DateStyle
-----------
 ISO, DMY
(1 row)
#+END_EXAMPLE

Продемонстрируем влияние этого параметра на работу с типами данных ~date~ и
~timestamp~. Для экспериментов возьмем дату, в которой число (день) превышает
12, чтобы нельзя было день перепутать с номером месяца. Пусть это будет,
например, 18 мая 2016 г.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '18-05-2016'::date;
#+END_SRC

#+RESULTS:
|       date |
|------------|
| 2016-05-18 |

Попробуем ввести дату в порядке «месяц, день, год»:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT '05-18-2016'::date;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "05-18-2016"
: LINE 1: SELECT '05-18-2016'::date;
:                ^
: HINT:  Perhaps you need a different "datestyle" setting.

В ответ получим сообщение об ошибке. Если бы мы выбрали дату, в которой число
(день) было бы не больше 12, например, 9, то сообщение об ошибке не было бы
сформировано, т.е. мы с такой датой не смогли бы проиллюстрировать влияние
значения ~DMY~ параметра ~datestyle~. Но главное, что в таком случае мы бы
просто не заметили допущенной ошибки.

А вот использовать порядок «год, месяц, день» при вводе можно несмотря на то,
что параметр ~datestyle~ предписывает «день, месяц, год». Порядок «год, месяц,
день» является универсальным, его можно использовать всегда, независимо от
настроек параметра ~datestyle~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '2016-05-18'::date;
#+END_SRC

#+RESULTS:
|       date |
|------------|
| 2016-05-18 |

Продолжим экспериментирование с параметром ~datestyle~. Давайте изменим его
значение. Сделать это можно многими способами, но мы упомянем лишь некоторые:
- зменив его значение в конфигурационном файле ~postgresql.conf~, который
  находится в каталоге ~/usr/local/pgsql/data~;
- назначив переменную системного окружения ~PGDATESTYLE~;
- воспользовавшись командой ~SET~.

Сейчас выберем третий способ, а первые два рассмотрим при выполнении других
заданий. Поскольку параметр ~datestyle~ состоит фактически из двух частей,
которые можно задавать не только обе сразу, но и по отдельности, изменим только
порядок следования составных частей даты, не изменяя формат вывода с ISO на
какой-либо другой.

#+BEGIN_SRC sql :engine postgres :results value verbatim :session datestyle :eval no
  SET datestyle TO 'MDY';
#+END_SRC

#+RESULTS:
: SET

Повторим одну из команд, выполненных ранее. Теперь она должна вызвать ошибку.
Почему?

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :session datestyle :eval no
  SELECT '18-05-2016'::date;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "18-05-2016"
: LINE 1: SELECT '18-05-2016'::date;
:                ^
: HINT:  Perhaps you need a different "datestyle" setting.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :session datestyle :eval no
  SELECT '18-05-2016'::timestamp;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "18-05-2016"
: LINE 1: SELECT '18-05-2016'::date;
:                ^
: HINT:  Perhaps you need a different "datestyle" setting.

А такая команда, наоборот, теперь будет успешно выполнена:

#+BEGIN_SRC sql :engine postgres :exports both :session datestyle :eval no
  SELECT '05-18-2016'::date;
#+END_SRC

#+RESULTS:
|       date |
|------------|
| 2016-05-18 |

#+BEGIN_SRC sql :engine postgres :exports both :session datestyle :eval no
  SELECT '05-18-2016'::timestamp;
#+END_SRC

#+RESULTS:
|                date |
|---------------------|
| 2016-05-18 00:00:00 |

Теперь приведите настройку параметра ~datestyle~ в исходное состояние:

#+BEGIN_SRC sql :engine postgres :results value verbatim :session datestyle :eval no
  SET datestyle TO DEFAULT;
#+END_SRC

#+RESULTS:
: SET

Самостоятельно выполните команды ~SELECT~, приведенные выше, но замените в них
тип ~date~ на тип ~timestamp~. Вы увидите, что дата в рамках типа ~timestamp~
обрабатывается аналогично типу ~date~.

Сейчас изменим сразу обе части параметра *datestyle*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :session datestyle :eval no
  SET datestyle TO 'Postgres, DMY';
#+END_SRC

#+RESULTS:
: SET

Проверьте полученный результат с помощью команды ~SHOW~.

Самостоятельно выполните команды ~SELECT~, приведенные выше, как для значения
типа ~date~, так и для значения типа ~timestamp~. Обратите внимание, что если
выбран формат Postgres, то порядок следования составных частей даты (день,
месяц, год), заданный в параметре ~datestyle~, используется не только при вводе
значений, но и при выводе. Напомним, что вводом мы считаем команду ~SELECT~, а
выводом — результат ее выполнения, выведенный на экран.

В документации (см. раздел 8.5.2 «Вывод даты/времени») сказано, что формат
вывода даты может принимать значения ISO, Postgres, SQL и German. Первые два
варианта мы уже рассмотрели. Самостоятельно поэкспериментируйте с двумя
оставшимися по той же схеме, по которой вы уже действовали ранее при выполнении
этого задания. Можно воспользоваться и стандартными функциями ~current_date~ и
~current_timestamp~.
*** Вопрос 13
Установить новое значение параметра ~datestyle~ можно с помощью создания
переменной системного окружения ~PGDATESTYLE~. Назначить эту переменную можно в
конфигурационных файлах операционной системы. Но если нам нужно сделать это
только на время текущего сеанса работы клиентской программы, например утилиты
psql, то можно ввести значение этой переменной непосредственно в командной
строке: ~PGDATESTYLE="Postgres" psql -d test -U имя-пользователя~.

Проделайте эти действия, а затем уже из командной строки утилиты psql
проверьте текущее значение параметра ~datestyle~ с помощью команды ~SHOW~.

*ОТВЕТ*:

#+BEGIN_EXAMPLE
$ PGDATESTYLE="Postgres" psql
psql (13.2 (Ubuntu 13.2-1.pgdg20.04+1), server 12.6 (Ubuntu 12.6-1.pgdg20.04+1))
Type "help" for help.

asakura=# show datestyle;
   DateStyle
---------------
 Postgres, DMY
(1 row)

asakura=# SELECT current_timestamp;
          current_timestamp
--------------------------------------
 Thu 08 Apr 20:34:34.440317 2021 CEST
(1 row)

asakura=#
#+END_EXAMPLE
*** Вопрос 14
Назначить значение параметра ~datestyle~ можно в конфигурационном файле
~postgresql.conf~, который находится в каталоге ~/usr/local/pgsql/data~.
Предварительно сохраните текущую (корректно работающую) версию этого файла, а
затем измените в нем значение параметра ~datestyle~, например, на ~Postgres,
YMD~. Перезапустите сервер PostgreSQL, чтобы изменения вступили в силу.

Для проверки полученного результата выполните несколько команд ~SELECT~,
например:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT current_timestamp;
#+END_SRC

*ОТВЕТ*:

#+RESULTS:
| current_timestamp                    |
|--------------------------------------|
| Fri Apr 09 11:03:56.041788 2021 CEST |
*** Вопрос 15
В документации в разделе 9.8 «Функции форматирования данных» представлены
описания множества полезных функций, позволяющих преобразовать в строку данные
других типов, например, ~timestamp~. Одна из таких функций — ~to_char~.

Приведем несколько команд, иллюстрирующих использование этой функции. Ее первым
параметром является форматируемое значение, а вторым — шаблон, описывающий
формат, в котором это значение будет представлено при вводе или выводе. Сначала
попробуйте разобраться, не обращаясь к документации, в том, что означает второй
параметр этой функции в каждой из приведенных команд, а затем проверьте свои
предположения по документации.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'mi:ss');
#+END_SRC

*ОТВЕТ*: минуты, секунды

#+RESULTS:
| to_char |
|---------|
|   07:47 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'dd');
#+END_SRC

*ОТВЕТ*: день

#+RESULTS:
| to_char |
|---------|
|      09 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'yyyy-mm-dd');
#+END_SRC

*ОТВЕТ*: год, месяц, день

#+RESULTS:
|    to_char |
|------------|
| 2021-04-09 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'dd/mm/yyyy mi:ss');
#+END_SRC

*ОТВЕТ*: американский формат даты и времени

#+RESULTS:
| to_char          |
|------------------|
| 09/04/2021 09:22 |
*** Вопрос 16
При выполнении приведения типа данных производится проверка значения на
допустимость. Попробуйте ввести недопустимое значение даты, например, 29 февраля
в невисокосном году. Получите сообщение об ошибке.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT 'Feb 29, 2015'::date;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "Feb 29, 2015"
: LINE 1: SELECT 'Feb 29, 2015'::date;
*** Вопрос 17
При выполнении приведения типа данных производится проверка значения
надопустимость. Попробуйте ввести недопустимое значение времени, например, с
нарушением формата.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT '21:15:16:22'::time;
#+END_SRC

#+RESULTS:
: ERROR: invalid input syntax for type time: "21:15:16:22"
: LINE 1: SELECT '21:15:16:22'::time;
*** Вопрос 18
Как вы думаете, значение какого типа будет получено при вычитании одной даты
из другой? Сначала попробуйте получить ответ, рассуждая логически, а затем
проверьте на практике в утилите psql.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::date -'2016-09-01'::date);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
|       15 |

*ОТВЕТ*: дни.
*** Вопрос 19
С типами даты и времени можно выполнять различные арифметические операции. Как
правило, их применение является интуитивно понятным. Выполните следующую команду
и проанализируйте результат.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('20:34:35'::time - '19:44:45'::time);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| 00:49:50 |

*ОТВЕТ*: ~interval~

А теперь попробуйте предположить, какой результат будет получен, если в этой
команде знак «минус» заменить на знак «плюс»? Проверьте ваши предположения с
помощью утилиты psql. Подробное описание всех допустимых арифметических операций
с датами и временем приведено в документации в разделе 9.9 «Операторы и функции
даты/времени».

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT ('20:34:35'::time + '19:44:45'::time);
#+END_SRC

#+RESULTS:
: ERROR:  operator is not unique: time without time zone + time without time zone
: LINE 1: SELECT ('20:34:35'::time + '19:44:45'::time);
:                                  ^
: HINT:  Could not choose a best candidate operator. You might need to add explicit type casts.
*** Вопрос 20
Значение типа ~interval~ можно получить при вычитании одной временной отметки из
другой, например:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT (current_timestamp - '2016-01-01'::timestamp) AS new_date;
#+END_SRC

#+RESULTS:
| new_date                  |
|---------------------------|
| 1925 days 14:32:13.783037 |

А что получится, если прибавить интервал к временной отметке? Сначала попробуйте
дать ответ, не прибегая к помощи утилиты psql, а затем проверьте свой ответ с
помощью этой утилиты. Например, прибавим интервал длительностью в 1 месяц к
текущей к временной отметке:

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT (current_timestamp + '1 mon'::interval) AS new_date;
#+END_SRC

#+RESULTS:
| new_date                      |
|-------------------------------|
| 2021-05-09 15:32:57.116552+02 |

В этой команде с помощью ключевого слова ~AS~ мы назначили псевдоним для того
столбца, который будет выведен в результате. Выполните эту же команду, убрав
псевдоним, и найдите отличия.
*** Вопрос 21
Можно с высокой степенью уверенности предположить, что при прибавлении
интервалов к датам и временным отметкам PostgreSQL учитывает тот факт, что
различные месяцы имеют различное число дней. Но как это реализуется на практике?
Например, что получится при прибавлении интервала в 1 месяц к последнему дню
января и к последнему дню февраля? Сначала сделайте обоснованные предположения о
результатах следующих двух команд, а затем проверьте предположения на практике и
проанализируйте полученные результаты:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-01-31'::date +'1 mon'::interval) AS new_date;
#+END_SRC

#+RESULTS:
| new_date            |
|---------------------|
| 2016-02-29 00:00:00 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-02-29'::date +'1 mon'::interval) AS new_date;
#+END_SRC

#+RESULTS:
| new_date            |
|---------------------|
| 2016-03-29 00:00:00 |

*ОТВЕТ*: если количество дней в месяце меньше - то тогда выбирает последний
день. Если больше - оставляет тот же номер дня.
*** Вопрос 22
Форматом ввода и вывода интервалов управляет параметр ~intervalstyle~. Его можно
изменить с помощью способов, аналогичных тем, что были описаны выше для
параметра ~datestyle~. Самостоятельно поэкспериментируйте с различными
значениями параметра ~intervalstyle~ аналогично тому, как вы этоделали с
параметром ~datestyle~. Используйте раздел 8.5 «Типы даты/времени» в
документации. Напомним, что вернуть исходное значение этого параметра в psql
можно с помощью команды:

src_sql[:exports code]{SET intervalstyle TO DEFAULT;}

*TODO* ответить на вопрос
*** Вопрос 23
Выполните следующие две команды и объясните различия в выведенных результатах:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::date - '2015-09-01'::date);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
|      381 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::timestamp - '2015-09-01'::timestamp);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| 381 days |

*ОТВЕТ*: в первом случае возвращает ~integer~, а во втором ~interval~.
*** Вопрос 24
Выполните следующие две команды и объясните различия в выведенных результатах:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('20:34:35'::time - 1);
#+END_SRC

#+RESULTS:
: ERROR:  operator does not exist: time without time zone - integer
: LINE 1: SELECT ('20:34:35'::time - 1);
:                                  ^
: HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::date - 1);
#+END_SRC

#+RESULTS:
|   ?column? |
|------------|
| 2016-09-15 |

Почему при выполнении первой команды возникает ошибка? Как можно модифицировать
эту команду, чтобы ошибка исчезла?

Для получения полной информации обратитесь к разделу 9.9 «Операторы и функции
даты/времени» документации.

*ОТВЕТ*: оператор ~-~ не определен для типа ~time~ и ~integer~. Можно привести к
типу ~interval~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('20:34:35'::time - '1 hour'::interval);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| 19:34:35 |
*** Вопрос 25
Значения временных отметок можно усекать с той или иной точностью с помощью
функции ~date_trunc~. Например, с помощью следующей команды можно «отрезать»
дробную часть секунды:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT date_trunc('sec', timestamp '1999-11-27 12:34:56.987654');
#+END_SRC

#+RESULTS:
| date_trunc          |
|---------------------|
| 1999-11-27 12:34:56 |

Напомним, что в данной команде используется операция приведения типа.

Выполните эту команду, последовательно указывая в качестве первого параметра
значения ~microsecond~, ~millisecond~, ~second~, ~minute~, ~hour~, ~day~,
~week~, ~month~, ~year~, ~decade~, ~century~, ~millennium~ (которые обозначают
соответственно микросекунды, миллисекунды, секунды, минуты, часы, дни, недели,
месяцы, годы, десятилетия, века и тысячелетия). Допустимы сокращения ~sec~,
~min~, ~mon~, ~dec~, ~cent~, ~mil~.

Обратите внимание, что результирующее значение получается не путем округления
исходного значения, а именно путем отбрасывания более мелких единиц. При этом
поля времени (часы, минуты и секунды) заменяются нулями, а поля даты (годы,
месяцы и дни) — заменяются цифрами 01. Однако при использовании параметра ~week~
картина получается более интересная.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', date_trunc('microsecond', timestamp '1999-11-27 12:34:56.987654')),
                 ('millisecond', date_trunc('millisecond', timestamp '1999-11-27 12:34:56.987654')),
                 ('second', date_trunc('second', timestamp '1999-11-27 12:34:56.987654')),
                 ('minute', date_trunc('minute', timestamp '1999-11-27 12:34:56.987654')),
                 ('hour', date_trunc('hour', timestamp '1999-11-27 12:34:56.987654')),
                 ('day', date_trunc('day', timestamp '1999-11-27 12:34:56.987654')),
                 ('week', date_trunc('week', timestamp '1999-11-27 12:34:56.987654')),
                 ('month', date_trunc('month', timestamp '1999-11-27 12:34:56.987654')),
                 ('year', date_trunc('year', timestamp '1999-11-27 12:34:56.987654')),
                 ('decade', date_trunc('decade', timestamp '1999-11-27 12:34:56.987654')),
                 ('century', date_trunc('century', timestamp '1999-11-27 12:34:56.987654')),
                 ('millennium', date_trunc('millennium', timestamp '1999-11-27 12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         | trunc                      |
|-------------+----------------------------|
| microsecond | 1999-11-27 12:34:56.987654 |
| millisecond | 1999-11-27 12:34:56.987    |
| second      | 1999-11-27 12:34:56        |
| minute      | 1999-11-27 12:34:00        |
| hour        | 1999-11-27 12:00:00        |
| day         | 1999-11-27 00:00:00        |
| week        | 1999-11-*22* 00:00:00      |
| month       | 1999-11-01 00:00:00        |
| year        | 1999-01-01 00:00:00        |
| decade      | 1990-01-01 00:00:00        |
| century     | 1901-01-01 00:00:00        |
| millennium  | 1001-01-01 00:00:00        |
*** Вопрос 26
Функция ~date_trunc~ может работать не только с данными типа ~timestamp~, но
также и с данными типа ~interval~. Самостоятельно ознакомьтесь с этими
возможностями по документации (см. раздел 9.9 «Операторы и функции
даты/времени»).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', date_trunc('microsecond', interval 'P1999-11-27T12:34:56.987654')),
                 ('millisecond', date_trunc('millisecond', interval 'P1999-11-27T12:34:56.987654')),
                 ('second',      date_trunc('second',      interval 'P1999-11-27T12:34:56.987654')),
                 ('minute',      date_trunc('minute',      interval 'P1999-11-27T12:34:56.987654')),
                 ('hour',        date_trunc('hour',        interval 'P1999-11-27T12:34:56.987654')),
                 ('day',         date_trunc('day',         interval 'P1999-11-27T12:34:56.987654')),
                 ('month',       date_trunc('month',       interval 'P1999-11-27T12:34:56.987654')),
                 ('year',        date_trunc('year',        interval 'P1999-11-27T12:34:56.987654')),
                 ('decade',      date_trunc('decade',      interval 'P1999-11-27T12:34:56.987654')),
                 ('century',     date_trunc('century',     interval 'P1999-11-27T12:34:56.987654')),
                 ('millennium',  date_trunc('millennium',  interval 'P1999-11-27T12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         | trunc                                      |
|-------------+--------------------------------------------|
| microsecond | 1999 years 11 mons 27 days 12:34:56.987654 |
| millisecond | 1999 years 11 mons 27 days 12:34:56.987    |
| second      | 1999 years 11 mons 27 days 12:34:56        |
| minute      | 1999 years 11 mons 27 days 12:34:00        |
| hour        | 1999 years 11 mons 27 days 12:00:00        |
| day         | 1999 years 11 mons 27 days                 |
| month       | 1999 years 11 mons                         |
| year        | 1999 years                                 |
| decade      | 1990 years                                 |
| century     | 1900 years                                 |
| millennium  | 1000 years                                 |

~week~ использовать нельзя:
: ERROR:  interval units "week" not supported because months usually have fractional weeks
*** Вопрос 27
Весьма полезной является функция ~extract~. С ее помощью можно извлечь значение
отдельного поля из временной отметки ~timestamp~. Наименование поля задается в
первом параметре. Эти наименования такие же, что и для функции ~date_trunc~.
Выполните следующую команду

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT extract('microsecond' FROM timestamp '1999-11-27 12:34:56.123459');
#+END_SRC

#+RESULTS:
| date_part |
|-----------|
|  56123459 |

Она выводит не просто значение поля микросекунд, т.е. 123459, а дополнительно
преобразует число секунд в микросекунды и добавляет значение поля микросекунд.

Выполните эту команду, последовательно указывая в качестве первого параметра
значения ~microsecond~, ~millisecond~, ~second~, ~minute~, ~hour~, ~day~,
~week~, ~month~, ~year~, ~decade~, ~century~, ~millennium~. Можно использовать
сокращения этих наименований, которые приведены в предыдущем задании.

Обратите внимание, что в ряде случаев выводится не просто конкретное поле
(фрагмент) из временной отметки, а некоторый продукт переработки этого поля.
Например, если в качестве первого параметра функции ~extract~ в вышеприведенной
команде указать ~cent~ (век), то мы получим в ответ не 19 (что и было бы
буквальным значением поля «век»), а 20, поскольку 1999 год принадлежит
двадцатому веку.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', extract('microsecond' FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('millisecond', extract('millisecond' FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('second',      extract('second'      FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('minute',      extract('minute'      FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('hour',        extract('hour'        FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('day',         extract('day'         FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('week',        extract('week'        FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('month',       extract('month'       FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('year',        extract('year'        FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('decade',      extract('decade'      FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('century',     extract('century'     FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('millennium',  extract('millennium'  FROM timestamp '1999-11-27 12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         |     trunc |
|-------------+-----------|
| microsecond |  56987654 |
| millisecond | 56987.654 |
| second      | 56.987654 |
| minute      |        34 |
| hour        |        12 |
| day         |        27 |
| week        |      *47* |
| month       |        11 |
| year        |      1999 |
| decade      |       199 |
| century     |      *20* |
| millennium  |         2 |
*** Вопрос 28
Функция ~extract~ может работать не только с данными типа ~timestamp~, но также
и с данными типа ~interval~. Самостоятельно ознакомьтесь с этими возможностями
по документации (см. раздел 9.9 «Операторы и функции даты/времени»).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', extract('microsecond' FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('millisecond', extract('millisecond' FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('second',      extract('second'      FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('minute',      extract('minute'      FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('hour',        extract('hour'        FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('day',         extract('day'         FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('month',       extract('month'       FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('year',        extract('year'        FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('decade',      extract('decade'      FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('century',     extract('century'     FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('millennium',  extract('millennium'  FROM interval 'P1999-11-27T12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         |     trunc |
|-------------+-----------|
| microsecond |  56987654 |
| millisecond | 56987.654 |
| second      | 56.987654 |
| minute      |        34 |
| hour        |        12 |
| day         |        27 |
| month       |        11 |
| year        |      1999 |
| decade      |       199 |
| century     |        19 |
| millennium  |         1 |

~week~ использовать нельзя:
: ERROR:  interval units "week" not supported
*** Вопрос 29
В тексте главы мы создавали таблицу с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE databases(is_open_source boolean, dbms_name text);
#+END_SRC

#+RESULTS:
: CREATE TABLE

и заполняли ее данными.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO databases VALUES (TRUE, 'PostgreSQL');
  INSERT INTO databases VALUES (FALSE, 'Oracle');
  INSERT INTO databases VALUES (TRUE, 'MySQL');
  INSERT INTO databases VALUES (FALSE, 'MS SQL Server');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

Как вы думаете, являются ли все приведенные ниже команды равнозначными в
смысле результатов, получаемых с их помощью?

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT * FROM databases WHERE NOT is_open_source;
  SELECT * FROM databases WHERE is_open_source <> 'yes';
  SELECT * FROM databases WHERE is_open_source <> 't';
  SELECT * FROM databases WHERE is_open_source <> '1';
  SELECT * FROM databases WHERE is_open_source <>  1;
#+END_SRC

*ОТВЕТ*: нет, см. ниже

: ERROR:  operator does not exist: boolean <> integer
: LINE 1: SELECT * FROM databases WHERE is_open_source <> 1;
:                                                     ^
: HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
*** Вопрос 30
Обратимся к таблице, создаваемой с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE test_bool(a boolean, b text);
#+END_SRC

#+RESULTS:
: CREATE TABLE

Как вы думаете, какие из приведенных ниже команд содержат ошибку?

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO test_bool VALUES ( TRUE, 'yes' );

  -- ERROR:  column "yes" does not exist
  INSERT INTO test_bool VALUES (  yes, 'yes' );

  INSERT INTO test_bool VALUES ('yes', true  );
  INSERT INTO test_bool VALUES ('yes', TRUE  );
  INSERT INTO test_bool VALUES (  '1', 'true');

  -- ERROR:  column "a" is of type boolean but expression is of type integer
  INSERT INTO test_bool VALUES (    1, 'true');

  INSERT INTO test_bool VALUES (  't', 'true');

  -- ERROR:  column "truth" does not exist
  INSERT INTO test_bool VALUES (  't', truth );

  INSERT INTO test_bool VALUES ( true, true  );
  INSERT INTO test_bool VALUES (1::boolean,   'true');
  INSERT INTO test_bool VALUES (111::boolean, 'true');
#+END_SRC

Проверьте свои предположения практически, выполнив эти команды.
*** Вопрос 31
Пусть в таблице ~birthdays~ хранятся даты рождения какой-то группы людей.
Создайте эту таблицу с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE birthdays(person text NOT NULL, birthday date NOT NULL);
#+END_SRC

#+RESULTS:
: CREATE TABLE

Добавьте в нее несколько строк, например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO birthdays VALUES ('Ken Thompson', '1955-03-23');
  INSERT INTO birthdays VALUES ('Ben Johnson', '1971-03-19');
  INSERT INTO birthdays VALUES ('Andy Gibson', '1987-08-12');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

Давайте выберем из таблицы ~birthdays~ строки для всех людей, родившихся в
каком-то конкретном месяце, например, в марте:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM birthdays
   WHERE extract('mon' FROM birthday) = 3;
#+END_SRC

#+RESULTS:
| person       |   birthday |
|--------------+------------|
| Ken Thompson | 1955-03-23 |
| Ben Johnson  | 1971-03-19 |

В этой команде в вызове функции ~extract~ имеет место неявное приведение типов,
т.к. ее вторым параметром должно быть значение типа ~timestamp~. Полагаться на
неявное приведение типов можно не всегда.

Если нам потребуется выяснить, кто из этих людей достиг возраста, скажем, 40
лет на момент выполнения запроса, то команда может быть такой (в последнем
столбце показана дата достижения возраста 40 лет):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *,
         birthday + '40 years'::interval
    FROM birthdays
   WHERE birthday + '40 years'::interval < current_timestamp;
#+END_SRC

#+RESULTS:
| person       |   birthday | ?column?            |
|--------------+------------+---------------------|
| Ken Thompson | 1955-03-23 | 1995-03-23 00:00:00 |
| Ben Johnson  | 1971-03-19 | 2011-03-19 00:00:00 |

Можно заменить ~current_timestamp~ на ~current_date~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *,
         birthday + '40 years'::interval
    FROM birthdays
   WHERE birthday + '40 years'::interval < current_date;
#+END_SRC

#+RESULTS:
| person       |   birthday | ?column?            |
|--------------+------------+---------------------|
| Ken Thompson | 1955-03-23 | 1995-03-23 00:00:00 |
| Ben Johnson  | 1971-03-19 | 2011-03-19 00:00:00 |

А вот если мы захотим определить точный возраст каждого человека на текущий
момент времени, то как получить этот результат? Первый вариант таков:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *,
         (current_date::timestamp - birthday::timestamp)::interval
    FROM birthdays;
#+END_SRC

#+RESULTS:
| person       |   birthday | interval   |
|--------------+------------+------------|
| Ken Thompson | 1955-03-23 | 24128 days |
| Ben Johnson  | 1971-03-19 | 18288 days |
| Andy Gibson  | 1987-08-12 | 12298 days |

Этот вариант не дает результата, представленного в удобной форме: он показывает
возраст в днях, а для пересчета числа дней в число лет нужны дополнительные
действия. Хотя, наверное, возможны ситуации, когда требуется определить возраст
именно в днях.

В PostgreSQL предусмотрена специальная функция, позволяющая решить нашу задачу
простым способом. Самостоятельно найдите ее описание в документации (см. раздел
9.9 «Операторы и функции даты/времени») и напишите команду с её использованием.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *, age(birthday::timestamp) FROM birthdays;
#+END_SRC

#+RESULTS:
| person       |   birthday | age                   |
|--------------+------------+-----------------------|
| Ken Thompson | 1955-03-23 | 66 years 21 days      |
| Ben Johnson  | 1971-03-19 | 50 years 25 days      |
| Andy Gibson  | 1987-08-12 | 33 years 8 mons 1 day |
*** Вопрос 32
Изучая приемы работы с массивами, можно, как и в других случаях, пользоваться
способностью команды ~SELECT~ обходиться без создания таблиц. Покажем лишь два
примера.

Для объединения (конкатенации) массивов служит функция ~array_cat~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_cat(ARRAY[1, 2, 3], ARRAY[3, 5]);
#+END_SRC

#+RESULTS:
| array_cat   |
|-------------|
| {1,2,3,3,5} |

Удалить из массива элементы, имеющие указанное значение, можно таким образом с
помощью функции ~array_remove~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_remove(ARRAY[2, 3, 4], 3);
#+END_SRC

#+RESULTS:
| array_remove |
|--------------|
| {2,4}        |

Для работы с массивами предусмотрено много различных функций и операторов,
представленных в разделе документации 9.18 «Функции и операторы для работы с
массивами». Самостоятельно ознакомьтесь с ними, используя описанную технологию
работы с командой ~SELECT~.

*ОТВЕТ*:

~array_ndims~ возвращает число размерностей массива:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_ndims(ARRAY[ARRAY[1, 2, 3], ARRAY[4, 4, 4]]);
#+END_SRC

#+RESULTS:
| array_ndims |
|-------------|
|           2 |

~array_dims~ возвращает текстовое представление размерностей массива:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_dims(ARRAY[ARRAY[1, 2, 3], ARRAY[4, 4, 4]]);
#+END_SRC

#+RESULTS:
| array_dims |
|------------|
| [1:2][1:3] |

~array_position(anyarray, anyelement [, int])~ возвращает позицию первого
вхождения второго аргумента в массиве, начиная с элемента, выбираемого третьим
аргументом, либо с первого элемента (массив должен быть одномерным):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
#+END_SRC

#+RESULTS:
| array_position |
|----------------|
|              2 |

~array_to_string(anyarray, text [, text])~ выводит элементы массива через
заданный разделитель и позволяет определить замену для значения NULL:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*');
#+END_SRC

#+RESULTS:
| array_to_string |
|-----------------|
| 1,2,3,*,5       |
*** Вопрос 33
В разделе документации 8.15 «Массивы» сказано, что массивы могут быть
многомерными и в них могут содержаться значения любых типов. Давайте сначала
рассмотрим одномерные массивы текстовых значений.

Предположим, что пилоты авиакомпании имеют возможность высказывать свои
пожелания насчет конкретных блюд, из которых должен состоять их обед во время
полета. Для учета пожеланий пилотов необходимо модифицировать таблицу ~pilots~,
с которой мы работали в разделе 4.5.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS pilots;
  CREATE TABLE pilots(pilot_name text, schedule integer[], meal text[]);
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

Добавим строки в таблицу:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots VALUES ('Ivan',  '{1, 3, 5, 6, 7}'::integer[], '{"сосиска", "макароны", "кофе"}'::text[]),
                            ('Petr',  '{1, 2, 5, 7}'::integer [],   '{"котлета", "каша", "кофе"}'::text[]),
                            ('Pavel', '{2, 5}'::integer[],          '{"сосиска", "каша", "кофе"}'::text[]),
                            ('Boris', '{3, 5, 6}'::integer[],       '{"котлета", "каша", "чай"}'::text[]);
#+END_SRC

#+RESULTS:
: INSERT 0 4

Обратите внимание, что каждое из текстовых значений, включаемых в литерал
массива, заключается в двойные кавычки, а в качестве типа данных указывается
~text[]~.

Вот что получилось:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM pilots;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    | meal                    |
|------------+-------------+-------------------------|
| Ivan       | {1,3,5,6,7} | {сосиска,макароны,кофе} |
| Petr       | {1,2,5,7}   | {котлета,каша,кофе}     |
| Pavel      | {2,5}       | {сосиска,каша,кофе}     |
| Boris      | {3,5,6}     | {котлета,каша,чай}      |

Давайте получим список пилотов, предпочитающих на обед сосиски:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM pilots WHERE meal[1] = 'сосиска';
#+END_SRC

#+RESULTS:
| pilot_name | schedule    | meal                    |
|------------+-------------+-------------------------|
| Ivan       | {1,3,5,6,7} | {сосиска,макароны,кофе} |
| Pavel      | {2,5}       | {сосиска,каша,кофе}     |

Предположим, что руководство авиакомпании решило, что пища пилотов должна быть
разнообразной. Оно позволило им выбрать свой рацион на каждый из четырех дней
недели, в которые пилоты совершают полеты. Для нас это решение руководства
выливается в необходимость модифицировать таблицу, а именно: столбец ~meal~
теперь будет содержать двумерные массивы. Определение этого столбца станет
таким: ~meal text[][]~.

Задание. Создайте новую версию таблицы и соответственно измените команду
~INSERT~, чтобы в ней содержались литералы двумерных массивов. Они будут
выглядеть примерно так:

: '{ { "сосиска", "макароны", "кофе" },
:    { "котлета", "каша", "кофе" },
:    { "сосиска", "каша", "кофе" },
:    { "котлета", "каша", "чай" } }'::text[][]

Сделайте ряд выборок и обновлений строк в этой таблице. Для обращения к
элементам двумерного массива нужно использовать два индекса. Не забывайте, что
по умолчанию номера индексов начинаются с единицы.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS pilots;
  CREATE TABLE pilots(pilot_name text, schedule integer[], meal text[][]);
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

Добавим строки в таблицу:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots
  VALUES (
         'Ivan', '{1, 3, 5, 6, 7}'::integer[],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);

  INSERT INTO pilots
  VALUES (
         'Petr', '{1, 2, 5, 7}'::integer [],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);

  INSERT INTO pilots
  VALUES (
         'Pavel', '{2, 5}'::integer[],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);

  INSERT INTO pilots
  VALUES (
         'Boris', '{3, 5, 6}'::integer[],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM pilots WHERE meal[1][1] = 'сосиска';
#+END_SRC

#+RESULTS:
| pilot_name | schedule    | meal                                                                                 |
|------------+-------------+--------------------------------------------------------------------------------------|
| Ivan       | {1,3,5,6,7} | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
| Petr       | {1,2,5,7}   | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
| Pavel      | {2,5}       | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
| Boris      | {3,5,6}     | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
*** Вопрос 34
В тексте раздела 4.6 мы выполняли обновление JSON-объекта с помощью функции
~jsonb_set~: добавляли значение в массив. Для обновления скалярных значений,
например, по ключу ~trips~, можно сделать так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{trips}', '10')
   WHERE pilot_name = 'Pavel';
#+END_SRC

#+RESULTS:
: UPDATE 1

Второй параметр функции — это путь в пределах JSON-объекта. Он теперь
представляет собой лишь имя ключа. Однако его необходимо заключить в фигурные
скобки. Третий параметр — это новое значение. Хотя оно числовое, но все равно
требуется записать его в одинарных кавычках.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies->'trips' AS trips
    FROM pilot_hobbies;
#+END_SRC

#+RESULTS:
| pilot_name | trips |
|------------+-------|
| Ivan       |     3 |
| Petr       |     2 |
| Boris      |     0 |
| Pavel      |    10 |

Задание. Самостоятельно выполните изменение значения по ключу ~home_lib~ в одной
из строк таблицы.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{home_lib}', 'false')
   WHERE pilot_name = 'Ivan';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies->'home_lib' AS home_lib
    FROM pilot_hobbies;
#+END_SRC

#+RESULTS:
| pilot_name | home_lib |
|------------+----------|
| Petr       | true     |
| Boris      | true     |
| Pavel      | false    |
| Ivan       | false    |
*** Вопрос 35
Изучая приемы работы с типами JSON, можно, как и в случае с массивами,
пользоваться способностью команды ~SELECT~ обходиться без создания таблиц.

Покажем лишь один пример. Добавить новый ключ и соответствующее ему
значения в уже существующий объект можно оператором ~||~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '{"sports": "hockey"}'::jsonb || '{"trips": 5}'::jsonb;
#+END_SRC

#+RESULTS:
| ?column?                         |
|----------------------------------|
| {"trips": 5, "sports": "hockey"} |

Для работы с типами JSON предусмотрено много различных функций и операторов,
представленных в разделе документации 9.15 «Функции и операторы JSON».
Самостоятельно ознакомьтесь с ними, используя описанную технологию работы с
командой ~SELECT~.

*TODO* ответить на вопрос
*** Вопрос 36
Объекты JSON в разных строках таблицы могут иметь различные наборы ключей.
Добавьте дополнительный ключ и соответствующее ему значение в JSON-объект
какой-нибудь строки таблицы ~pilots~. Используйте оператор ~||~.

*TODO* ответить на вопрос
*** Вопрос 37
Объекты JSON позволяют не только добавлять в них новые ключи, но также и удалять
из них ключи существующие. Удалите один из ключей из JSON-объекта какой-нибудь
строки таблицы ~pilots~. Соответствующее ему значение будет также удалено, т.к.
без ключа оно не может существовать. Воспользуйтесь оператором ~-~.

*TODO* ответить на вопрос
* Основы языка определения данных
** Значения по умолчанию и ограничения целостности
Итак, начнем созначений по умолчанию. При работе с базами данных нередко
возникают ситуации, когда то или иное значение является типичным для какого-то
конкретного столбца. В команде ~CREATE TABLE~ мы можем отразить этот факт с
помощью ключевого слова ~DEFAULT~: src_sql[:exports code]{mark numeric(1)
DEFAULT 5, ...}

Теперь перейдем к рассмотрению различных видов *ограничений* (*constraints*).

Первым будето *граничение CHECK*. Для его создания используется ключевое слово
~CHECK~, за которым следует выражение в круглых скобках, содержащее одно или
несколько условий, налагаемых на атрибуты таблицы. Это ограничение бывает двух
видов: уровня атрибута и уровня таблицы. Различие между ними только в
синтаксическом оформлении: в обоих случаях в выражении могут содержаться
обращения не только к одному, но и к нескольким атрибутам таблицы. В первом
случае ограничение ~CHECK~ является частью определения одного конкретного
атрибута, а во втором случае оно записывается как самостоятельный элемент
определения таблицы.

src_sql[:exports code]{term numeric(1) CHECK (term = 1 OR term = 2), ...}

Каждое ограничение имеет имя. Мы можем задать его сами с помощью ключевого слова
~CONSTRAINT~. Если же мы этого не сделаем, тогда СУБД сформирует имя
автоматически. Когда мы задаем имя сами, мы можем выбрать его с учетом сути
налагаемых ограничений, с позиции предметной области. Если же это имя формирует
СУБД, оно будет сформировано «механически», т.к. СУБД не знает ни сути этих
ограничений, ни специфики предметной области.

src_sql[:exports code]{mark numeric(1), CONSTRAINT valid_mark CHECK (mark >= 3
AND mark <= 5), ...}

Следующим видом ограничений, который мы рассмотрим, будет *ограничение NOT
NULL*. Оно означает, что в столбце таблицы, на который наложено это ограничение,
должны обязательно присутствовать какие-либо определенные значения. Оно
функционально эквивалентно ограничению src_sql[:exports code]{CHECK (column_name
IS NOT NULL)}, но в PostgreSQL создание явного ограничения ~NOT NULL~ является
более эффективным подходом.

Еще один вид ограничений — это *ограничение уникальности UNIQUE*. При добавлении
ограничения уникальности автоматически создается индекс на основе B-дерева для
поддержки этого ограничения. Такое ограничение, наложенное на конкретный
столбец, означает, что все значения, содержащиеся в этом столбце в различных
строках таблицы, должны быть уникальными, т.е. не должны повторяться.

src_sql[:exports code]{record_book numeric(5) UNIQUE, ...}

src_sql[:exports code]{record_book numeric(5), CONSTRAINT unique_record_book
UNIQUE (record_book), ...}

Ограничение уникальности может включать в себя и несколько столбцов. В этом
случае уникальной должна быть уже комбинация их значений.

src_sql[:exports code]{doc_ser numeric(4), doc_num numeric(6), CONSTRAINT
unique_passport UNIQUE (doc_ser, doc_num), ...}

Переходим к *первичным ключам*. Как мы уже говорили ранее, этот ключ является
уникальным идентификатором строк в таблице. Ключ может быть как простым, т.е.
включать только один атрибут, так и составным, т.е. включать более одного
атрибута. При этом в отличие от уникального ключа, определяемого с помощью
*ограничения UNIQUE*, атрибуты, входящие в состав первичного ключа, не могут
иметь значений ~NULL~. Первичный ключ является частью метаданных, его наличие
позволяет другим таблицам использовать его в качестве уникального идентификатора
строк в данной таблице. Это удобно, например, при создании внешних ключей. При
добавлении первичного ключа автоматически создается индекс на основе B-дерева
для поддержки этого ограничения. В таблице может быть любое число ограничений
~UNIQUE~, дополненных ограничением ~NOT NULL~, но первичный ключ может быть
только один.

src_sql[:exports code]{record_book numeric(5) PRIMARY KEY, ...}

А можно сделать это и в виде отдельного ограничения:

src_sql[:exports code]{record_book numeric(5), PRIMARY KEY (record_book), ...}

В случае создания составного первичного ключа имена столбцов, входящих в его
состав, перечисляются в выражении ~PRIMARY KEY~ через запятую: src_sql[:exports
code]{PRIMARY KEY (column1, column2, ...), ...}

Завершаем наш обзор различных видов ограничений рассмотрением такого важного
понятия, как *внешний ключ* (*foreign key*). Внешние ключи являются средством
поддержания так называемой *ссылочной целостности* (*referential integrity*)
между связанными таблицами. Таблица «Успеваемость» будет *ссылающейся*
(*referencing*), а таблица «Студенты» — *ссылочной* (*referenced*). Обратите
внимание, что внешний ключ ссылающейся таблицы ссылается на первичный ключ
ссылочной таблицы. Допускается ссылка и на уникальный ключ, не являющийся
первичным. В данном контексте для описания отношений между таблицами можно
сказать, что таблица ~students~ является *главной*,а таблица ~progress~ —
*подчиненной*.

src_sql[:exports code]{record_book numeric(5) REFERENCES students (record_book),
...}

Поскольку внешний ключ в нашем примере ссылается на первичный ключ, можно
использовать сокращенную форму записи этого ограничения, не указывая список
атрибутов:

src_sql[:exports code]{record_book numeric(5) REFERENCES students, ...}

Можно определить внешний ключ и в форме ограничения уровня таблицы:

src_sql[:exports code]{record_book numeric(5), FOREIGN KEY (record_boook)
REFERENCES students (record_book), ...}

Конечно, число атрибутов и их типы данных во внешнем ключе ссылающейся таблицы и
в первичном ключе ссылочной таблицы должны быть согласованы. Ограничению
внешнего ключа можно присвоить наименование, как и любому другому ограничению, с
помощью ключевого слова ~CONSTRAINT~.

При наличии связей между таблицами, организованных с помощью внешних ключей,
необходимо придерживаться определенной политики при выполнении операций удаления
и обновления строк в ссылочных таблицах — тех, на которые ссылаются другие
таблицы.

Возможны несколько вариантов.
1. Удаление связанных строк. Эта операция называется *каскадным удалением*, и
   для ее реализации в определение внешнего ключа добавляются ключевые слова
   src_sql[:exports code]{ON DELETE CASCADE}.
2. Запрет удаления строки из таблицы. Для реализации такой политики в
   определение внешнего ключа добавляются ключевые слова ~ON DELETE RESTRICT~
   или ~ON DELETE NO ACTION~. Если в определении внешнего ключа не предписано
   конкретное действие, то по умолчанию используется ~NO ACTION~. Отличие между
   этими двумя вариантами лишь в том, что при использовании ~NO ACTION~ можно
   отложить проверку выполнения ограничения на более поздний срок в рамках
   транзакции, а в случае ~RESTRICT~ проверка выполняется немедленно.
3. Присваивание атрибутам внешнего ключа в строках таблицы значения ~NULL~ - ~ON
   DELETE SET NULL~. Для реализации этого подхода необходимо, чтобы на атрибуты
   внешнего ключа не было наложено ограничение ~NOT NULL~.
4. Присваивание атрибутам внешнего ключа значения по умолчанию (~DEFAULT~), если
   оно, конечно, было предписано при создании таблицы. Оформляется этот вариант
   так ~ON DELETE SET DEFAULT~. Важно учитывать, что если в ссылочной таблице
   нет строки с тем же значением ключевого атрибута, которое было предписано во
   фразе ~DEFAULT~ при создании ссылающейся таблицы, то будет иметь место
   нарушение ограничения ссылочной целостности и операция удаления не будет
   выполнена.

При выполнении операции ~UPDATE~ используются эти же варианты подходов
поотношению к обеспечению ссылочной целостности. Аналогом каскадного удаления
является каскадное обновление: ~ON UPDATE CASCADE~.
** Модификация таблиц
Модифицировать таблицы приходится по различным причинам. В этом случае на помощь
приходит команда ~ALTER TABLE~.

Она предусматривает, наверное, все ситуации, которые могут возникнуть в реальной
работе. Например, может возникнуть необходимость добавить новый столбец в
таблицу — команда ~ALTER TABLE~ имеет для этого фразу ~ADD COLUMN~. Возможна и
обратная ситуация, когда нужно удалить столбец из таблицы — для этого есть фраза
~DROP COLUMN~. Если нужно добавить ограничение, то помогут фразы ~ADD CHECK~ и
~ADD CONSTRAINT~. Если потребовался внешний ключ, то можно добавить и его.

Предположим, что нам понадобилось иметь в базе данных сведения о крейсерской
скорости полета всех моделей самолетов, которые эксплуатируются в нашей
авиакомпании.

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE airports
    ADD COLUMN speed integer NOT NULL CHECK (speed >= 300);

  -- аналогично трем следующим командам
  ALTER TABLE aircrafts ADD COLUMN speed integer;
  ALTER TABLE aircrafts ALTER COLUMN speed SET NOT NULL;
  ALTER TABLE aircrafts ADD CHECK (speed >= 300);
#+END_SRC

Если необходимость наличия того или иного ограничения отпадет, его можно
удалить:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE aircrafts ALTER COLUMN speed DROP NOT NULL;
  ALTER TABLE aircrafts DROP CONSTRAINT aircrafts_speed_check;
#+END_SRC

Если мы решим не усложнять нашу базу данных дополнительной информацией, то можем
удалить и столбец. Конечно, вовсе не обязательно предварительно удалять
ограничения, наложенные на этот столбец.

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE aircrafts DROP COLUMN speed;
#+END_SRC

Еще одна полезная возможность команды ~ALTER TABLE~ — изменение типа данных для
какого-либо столбца:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE airports
    ALTER COLUMN longitude SET DATA TYPE numeric(5, 2),
    ALTER COLUMN latitude  SET DATA TYPE numeric(5, 2);
#+END_SRC

Но если исходный и целевой типы данных относятся к разным группам, тогда
потребуются некоторые дополнительные усилия с нашей стороны. Для реализации
такой задачи служит фраза ~USING~ команды ~ALTER TABLE~.

#+BEGIN_SRC sql :engine postgres :eval no
   ALTER TABLE seats
     -- в таблице есть ограничение, которое завязано на строковый тип,
     -- поэтому его нужно удалать
     DROP CONSTRAINT seats_fare_conditions_check,
     ALTER COLUMN fare_conditions SET DATA TYPE integer
       USING ( CASE WHEN fare_conditions = 'Economy'  THEN 1
                    WHEN fare_conditions = 'Business' THEN 2
                    ELSE 3 END
       );
#+END_SRC

Внешний ключ можно добавить такой командой:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE seats
    ADD FOREIGN KEY (fare_conditions) REFERENCES fare_conditions (fare_conditions_code);
#+END_SRC

А столбец переименовать такой:

#+BEGIN_SRC sql :engine postgres :eval no
   ALTER TABLE seats
  RENAME COLUMN fare_conditions TO fare_conditions_code;
#+END_SRC

А ограничение можно переименовать вот так:

#+BEGIN_SRC sql :engine postgres :eval no
   ALTER TABLE seats
  RENAME CONSTRAINT seats_fare_conditions_fkey TO seats_fare_conditions_code_fkey;
#+END_SRC

Добавить ограничение уникальности по столбцу возможно так:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE fare_conditions ADD UNIQUE (fare_conditions_name);
#+END_SRC
** Представления
Чтобы избежать необходимости многократного формирования сложных запросов, можно
использовать так называемые *представления* (*views*). Если речь идет о выборке
данных, то представления практически неотличимы от таблиц с точки зрения
обращения к ним в командах ~SELECT~. В отличие от таблиц, представления не
содержат данных. При каждом обращении к представлению в команде ~SELECT~ данные
выбираются из таблиц, на основе которых это представление создано.

Давайте создадим простое представление.

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE VIEW seats_by_fare_cond (code, fare_cond, num_seats)
    AS
    SELECT aircraft_code,
           fare_conditions,
           count(*)
      FROM seats
     GROUP BY aircraft_code, fare_conditions
     ORDER BY aircraft_code, fare_conditions;
#+END_SRC

СУБД PostgreSQL предлагает свое расширение команды ~CREATE VIEW~, а именно —
фразу ~OR REPLACE~. Если представление уже существует, то можно его не удалять,
а просто заменить новой версией. Однако нужно помнить о том, что при создании
новой версии представления (без явного удаления старой с помощью команды ~DROP
VIEW~) должны оставаться неизменными имена столбцов представления. Если же
выхотите изменить имя хотя бы одного столбца, то сначала нужно удалить
представление с помощью команды ~DROP VIEW~, а уже затем создать его заново.

PostgreSQL предлагает свое расширение — так называемое материализованное
представление. Упрощенный синтаксис команды ~CREATE MATERIALIZED VIEW~,
предназначенной для создания материализованных представлений похож на синтаксис
создания обычного представления.

В момент выполнения команды создания материализованного представления оно
заполняется данными, но только если в команде не было фразы ~WITH NO DATA~. Если
же она была включена в команду, тогда в момент своего создания представление
остается пустым, а для заполнения его данными нужно использовать команду
~REFRESH MATERIALIZED VIEW~.

Материализованное представление очень похоже на обычную таблицу. Однако оно
отличается от таблицы тем, что не только сохраняет данные, но также запоминает
запрос, с помощью которого эти данные были собраны.

Подводя итог раздела, назовем положительные стороны использования представлений.
1. Упрощение разграничения полномочий пользователей на доступ к хранимым данным.
2. Упрощение запросов к базе данных.
3. Снижение зависимости прикладных программ от изменений структуры таблиц базы
   данных.
4. Снижение времени выполнения сложных запросов за счет использования
   материализованных представлений. Одним из недостатков является то, что их
   необходимо своевременно обновлять с помощью команды ~REFRESH~, чтобы они
   содержали актуальные данные.
** Схемы базы данных
Схема — это логический фрагмент базы данных, в котором могут содержаться
различные объекты: таблицы, представления, индексы и др. В базе данных
обязательно есть хотя бы одна схема. При создании базы данных в ней
автоматически создается схема с именем ~public~.

В каждой базе данных может содержаться более одной схемы. Их имена должны быть
уникальными в пределах конкретной базы данных. Имена объектов базы данных
(таблиц, представлений, последовательностей и др.) должны быть уникальными в
пределах конкретной схемы, но в разных схемах имена объектов могут повторяться.
Таким образом, можно сказать, что схема образует так называемое *пространство
имен*.

Если в базе данных создано более одной схемы, то доступ к объектам, содержащимся
в конкретной схеме, можно организовать разными способами. Первый заключаетсяв
том, чтобы имена объектов предварять именем схемы.

Другой способ заключается в том, чтобы одну из схем сделать текущей. Среди
параметров времени исполнения, которые предусмотрены в конфигурации сервера
PostgreSQL, есть параметр ~search_path~. Он содержит имена схем, которые
PostgreSQL просматривает при поиске конкретного объекта базы данных, когда имя
схемы в команде не указано. Посмотреть значение этого параметра можно с помощью
команды ~SHOW search_path;~.

Чтобы изменить порядок просмотра схем при поиске объектов в базе данных, нужно
воспользоваться командой ~SET search_path = public, ...;~. При этом первой в
списке схем следует указать именно ту, которую СУБД должна просматривать первой.
Эта схема и станет текущей. Конечно, такой список может состоять и всего из
одной схемы.

При создании объектов базы данных, например таблиц, необходимо учитывать
следующее: если имя схемы в команде не указано, то объект будет создан в текущей
схеме. Если же вы хотите создать объект в конкретной схеме, которая не является
текущей, то нужно указать ее имя перед именем создаваемого объекта, разделив их
точкой.
** Контрольные вопросы и задания
*** Вопрос 1
При использовании значений по умолчанию с ключевым словом ~DEFAULT~ возможны и
ситуации, когда типичным будет не конкретное значение данных, а способ его
получения. Например, если мы захотим фиксировать в каждой строке таблицы
«Студенты» имя пользователя базы данных, добавившего эту строку в таблицу, тогда
необходимо в определение таблицы добавить еще один столбец. Этот столбец по
умолчанию будет получать значение, возвращаемое функцией ~current_user~.

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),
    who_adds_row text DEFAULT current_user, -- добавленный столбец
    PRIMARY KEY (record_book)
  );
#+END_SRC

Эта функция — ~current_user~ — будет вызываться не при создании таблицы, а при
вставке каждой строки. При этом в команде ~INSERT~ не требуется указывать
значение для столбца ~who_adds_row~, поскольку функция ~current_user~ будет
вызываться самой СУБД PostgreSQL:

#+BEGIN_SRC sql :engine postgres :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);
#+END_SRC

Давайте пойдем дальше и пожелаем фиксировать не только имя пользователя базы
данных, добавившего строку в таблицу, но также и момент времени, когда это было
сделано.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE TABLE students(
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),
    who_adds_row text DEFAULT current_user,
    inserted_at timestamptz DEFAULT current_timestamp,
    PRIMARY KEY (record_book)
  );

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|
| INSERT 0 1   |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num | who_adds_row | inserted_at                   |
|-------------+----------------------+---------+---------+--------------+-------------------------------|
|       12300 | Иванов Иван Иванович |     402 |  543281 | asakura      | 2021-04-15 18:25:37.350046+02 |
*** Вопрос 2
Посмотрите, какие ограничения уже наложены на атрибуты таблицы ~progress~.
Воспользуйтесь командой ~\d~ утилиты psql. А теперь предложите для этой таблицы
ограничение уровня таблицы.

В качестве примера рассмотрим такой вариант. Добавьте в таблицу ~progress~ еще
один атрибут — «Форма проверки знаний» (~test_form~), который может принимать
только два значения: «экзамен» или «зачет». Тогда набор допустимых значений
атрибута ~mark~ будет зависеть от того, экзамен или зачет предусмотрены по
данной дисциплине. Если предусмотрен экзамен, тогда допускаются значения 3, 4,
5, если зачет — тогда 0 (не зачтено) или 1 (зачтено).

Не забудьте, что значения ~NULL~ для атрибутов ~test_form~ и ~mark~ не
допускаются.

Новое ограничение может быть таким:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE progress
    ADD CHECK (
      ( test_form = 'экзамен' AND mark IN (3, 4, 5) )
      OR
      ( test_form = 'зачет'   AND mark IN (0, 1) )
    );
#+END_SRC

Проверьте, как будет работать новое ограничение в модифицированной таблице
~progress~. Для этого выполните команды ~INSERT~, как удовлетворяющие
ограничению, так и нарушающие его.

В таблице уже было ограничение на допустимые значения атрибута ~mark~. Как вы
думаете, не будет ли оно конфликтовать с новым ограничением? Проверьте эту
гипотезу. Если ограничения конфликтуют, тогда удалите старое ограничение и снова
попробуйте добавить строки в таблицу.

Подумайте, какое еще ограничение уровня таблицы можно предложить для этой
таблицы?

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE TABLE IF NOT EXISTS progress (
    record_book numeric(5) NOT NULL,
    subject text NOT NULL,
    acad_year text NOT NULL,
    term numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5
  );

  ALTER TABLE progress
    ADD COLUMN test_form text NOT NULL;

  ALTER TABLE progress
    ADD CHECK (
      ( test_form = 'экзамен' AND mark IN (3, 4, 5) )
      OR
      ( test_form = 'зачет'   AND mark IN (0, 1) )
    );
#+END_SRC

#+RESULTS:
: CREATE TABLE
: ALTER TABLE
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :eval no
  INSERT INTO progress (record_book, subject, acad_year, term, mark, test_form)
    VALUES (12300, 'DBA', 'first', 1, 5, 'экзамен');
#+END_SRC

#+RESULTS:
: INSERT 0 1

Да, конфликтует, нужно удалить:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE progress
    DROP CONSTRAINT progress_mark_check;

  INSERT INTO progress (record_book, subject, acad_year, term, mark, test_form)
    VALUES (12300, 'DBA', 'first', 1, 1, 'зачет');
#+END_SRC

#+RESULTS:
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark | test_form |
|-------------+---------+-----------+------+------+-----------|
|       12300 | DBA     | first     |    1 |    5 | экзамен   |
|       12300 | DBA     | first     |    1 |    1 | зачет     |
*** Вопрос 3
В определении таблицы ~progress~ на атрибуты ~term~ и ~mark~ наложены как
ограничения ~CHECK~, так и ограничение ~NOT NULL~. Возникает вопрос: не является
ли ограничение ~NOT NULL~ избыточным? Ведь в ограничении ~CHECK~ явно указаны
допустимые значения.

Проверьте гипотезу об избыточности ограничения ~NOT NULL~ в данном случае. Для
этого модифицируйте таблицу, убрав ограничение ~NOT NULL~, и попробуйте добавить
в нее строку с отсутствующим значением атрибута ~term~ (или ~mark~).

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE progress ALTER COLUMN term DROP NOT NULL;

  INSERT INTO progress (record_book, subject, acad_year, mark, test_form)
    VALUES (12300, 'DBA', 'first', 1, 'зачет');
#+END_SRC

#+RESULTS:
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

Ограничение ~NOT NULL~ не было избыточным, так как ограничение явно не проверяло
на ~NULL~.

#+RESULTS:
| record_book | subject | acad_year | term | mark | test_form |
|-------------+---------+-----------+------+------+-----------|
|       12300 | DBA     | first     |    1 |    5 | экзамен   |
|       12300 | DBA     | first     |    1 |    1 | зачет     |
|       12300 | DBA     | first     |      |    1 | зачет     |
*** Вопрос 4
В определении таблицы ~progress~ для атрибута ~mark~ не только задано
ограничение ~CHECK~, но и установлено значение по умолчанию с помощью ключевого
слова ~DEFAULT~:

#+BEGIN_SRC sql :engine postgres :eval no
  ...
  mark numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,
  ...
#+END_SRC

Как вы думаете, что будет, если в ограничении ~DEFAULT~ мы «случайно» допустим
ошибку, написав ~DEFAULT 6~? Если в команде ~INSERT~ не указать значение для
атрибута ~mark~, то на каком этапе эта ошибка будет выявлена: уже на этапе
создания таблицы или только при вставке строки в нее? Вот эта команда может быть
вам полезной для проверки гипотезы, посколькув ней отсутствует передаваемое
значение для атрибута ~mark~:

#+BEGIN_SRC sql :engine postgres :eval no
  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);
#+END_SRC

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS progress;

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 6
  );
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);
#+END_SRC

#+RESULTS:
: ERROR:  new row for relation "progress" violates check constraint "progress_mark_check"
: DETAIL:  Failing row contains (12300, Физика, 2016/2017, 1, 6).

Ошибка будет выявлена на этапе вставки строки в таблицу.
*** Вопрос 5
В стандарте SQL сказано, что при наличии ограничения уникальности, включающего
один или более столбцов, все же возможны повторяющиеся значения этих столбцов в
разных строках, но лишь в том случае, если это значения ~NULL~. PostgreSQL
придерживается такого же подхода.

Модифицируйте определение таблицы ~students~, добавив ограничение уникальности
по двум столбцам: ~doc_ser~ и ~doc_num~. А затем проверьте выше приведенное
утверждение, добавив в таблицу не только строки, содержащие конкретные значения
этих двух столбцов, но также и по две строки, имеющие следующие свойства:
- одинаковые значения столбца ~doc_ser~ и ~NULL~-значения столбца ~doc_num~;
- ~NULL~-значения столбца ~doc_num~ и столбца ~doc_ser~.

Подобные вещи возможны, так как ~NULL~-значения не считаются совпадающими. Это
можно проверить с помощью команды: src_sql[:exports code]{SELECT (null =
null);}. Она даст пустой результат (т.е. ~NULL~).

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS students;

  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),
    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12301, 'Иванов Иван Иванович', 0402, NULL);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12302, 'Иванов Иван Иванович', 0402, NULL);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12303, 'Иванов Иван Иванович', NULL, NULL);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12304, 'Иванов Иван Иванович', NULL, NULL);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num |
|-------------+----------------------+---------+---------|
|       12300 | Иванов Иван Иванович |     402 |  543281 |
|       12301 | Иванов Иван Иванович |     402 |         |
|       12302 | Иванов Иван Иванович |     402 |         |
|       12303 | Иванов Иван Иванович |         |         |
|       12304 | Иванов Иван Иванович |         |         |
*** Вопрос 6
Модифицируйте определения таблиц ~students~ и ~progress~. В таблице ~students~ в
качестве первичного ключа назначьте комбинацию атрибутов ~doc_ser~ и ~doc_num~,
а в таблице ~progress~ соответствующим образом измените определение внешнего
ключа.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE students(
    record_book numeric(5) NOT NULL UNIQUE,
    name        text       NOT NULL,
    doc_ser     numeric(4),
    doc_num     numeric(6),

    PRIMARY KEY (doc_ser, doc_num)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Обратите внимание, что для атрибутов ~doc_ser~ и ~doc_num~ можно не указывать
ограничение ~NOT NULL~: они входят в состав первичного ключа, а в нем
~NULL~-значения не допускаются, поэтому ограничение ~NOT NULL~ фактически
подразумевается при включении атрибута в состав первичного ключа.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE progress(
    doc_ser   numeric(4),
    doc_num   numeric(6),
    subject   text       NOT NULL,
    acad_year text       NOT NULL,
    term      numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark      numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,

    FOREIGN KEY (doc_ser, doc_num)
      REFERENCES students (doc_ser, doc_num)
      ON DELETE CASCADE
      ON UPDATE CASCADE
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Теперь и первичный, и внешний ключи — составные. Проверьте их действие, добавив
несколько строк в каждую таблицу.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d students
#+END_SRC

#+RESULTS:
#+begin_example
                   Table "public.students"
   Column    |     Type     | Collation | Nullable | Default
-------------+--------------+-----------+----------+---------
 record_book | numeric(5,0) |           | not null |
 name        | text         |           | not null |
 doc_ser     | numeric(4,0) |           | not null |
 doc_num     | numeric(6,0) |           | not null |
Indexes:
    "students_pkey" PRIMARY KEY, btree (doc_ser, doc_num)
    "students_record_book_key" UNIQUE CONSTRAINT, btree (record_book)
Referenced by:
    TABLE "progress" CONSTRAINT "progress_doc_ser_doc_num_fkey" FOREIGN KEY (doc_ser, doc_num) REFERENCES students(doc_ser, doc_num) ON UPDATE CASCADE ON DELETE CASCADE

#+end_example

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d progress
#+END_SRC

#+RESULTS:
#+begin_example
                  Table "public.progress"
  Column   |     Type     | Collation | Nullable | Default
-----------+--------------+-----------+----------+---------
 doc_ser   | numeric(4,0) |           |          |
 doc_num   | numeric(6,0) |           |          |
 subject   | text         |           | not null |
 acad_year | text         |           | not null |
 term      | numeric(1,0) |           | not null |
 mark      | numeric(1,0) |           | not null | 5
Check constraints:
    "progress_mark_check" CHECK (mark >= 3::numeric AND mark <= 5::numeric)
    "progress_term_check" CHECK (term = 1::numeric OR term = 2::numeric)
Foreign-key constraints:
    "progress_doc_ser_doc_num_fkey" FOREIGN KEY (doc_ser, doc_num) REFERENCES students(doc_ser, doc_num) ON UPDATE CASCADE ON DELETE CASCADE

#+end_example

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (doc_ser, doc_num, subject, acad_year, term)
    VALUES (0402, 543281, 'Физика', '2016/2017', 1);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num |
|-------------+----------------------+---------+---------|
|       12300 | Иванов Иван Иванович |     402 |  543281 |
*** Вопрос 7
Модифицируйте определение таблицы ~progress~, а если потребуется, то и
определение таблицы ~students~, чтобы изучить все варианты реагирования СУБД на
обновление строк в ссылочной таблице, в данном случае — ~students~.
Последовательно изменяйте определение внешнего ключа таблицы ~progress~,
испробовав варианты ~ON UPDATE CASCADE~, ~ONUPDATE RESTRICT~, ~ON UPDATE SET
NULL~ и ~ON UPDATE SET DEFAULT~. Для получения информативной картины введите
несколько строк в обе таблицы, а затем выполняйте операцию ~UPDATE~, подбирая
значения ключевых атрибутов таким образом, чтобы вызвать ожидаемую реакцию СУБД.

Учтите, что при использовании фразы ~ON UPDATE SET DEFAULT~ необходимо, чтобы,
во-первых, с помощью ключевого слова ~DEFAULT~ было установлено значение по
умолчанию для атрибута внешнего ключа в ссылающейся таблице, а во-вторых, это
значение по умолчанию все равно должно присутствовать в одной из строк ссылочной
таблицы. Как вы считаете, с учетом сказанного, возможно ли использование ~ON
UPDATE SET DEFAULT~ в нашем случае?

Попробуйте обосновать или, наоборот, опровергнуть целесообразность использования
каждой из этих политик — ~CASCADE~, ~RESTRICT~, ~SET NULL~ и ~SETDEFAULT~ — при
выполнении операции ~UPDATE~ в реальной информационной системе, предназначенной
для учета успеваемости студентов.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE progress;
  DROP TABLE students;

  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5
  );
#+END_SRC

#+RESULTS:
: DROP TABLE
: DROP TABLE
: CREATE TABLE
: CREATE TABLE

*ON DELETE NO ACTION*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE NO ACTION;

  DELETE FROM students;
#+END_SRC

#+RESULTS:
: DELETE 0
: DELETE 0
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE

: ERROR:  update or delete on table "students" violates foreign key constraint "progress_record_book_fkey" on table "progress"
: DETAIL:  Key (record_book)=(12300) is still referenced from table "progress".

*ON DELETE RESTRICT*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;

  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE RESTRICT;

  DELETE FROM students;
#+END_SRC

#+RESULTS:
: ALTER TABLE
: DELETE 1
: DELETE 1
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE

: ERROR:  update or delete on table "students" violates foreign key constraint "progress_record_book_fkey" on table "progress"
: DETAIL:  Key (record_book)=(12300) is still referenced from table "progress".

*ON DELETE SET DEFAULT*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;

  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (1, 'John Doe', 1, 1);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ALTER COLUMN record_book SET DEFAULT 1;

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE SET DEFAULT;

  DELETE FROM students WHERE record_book != 1;

  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;

  ALTER TABLE progress
    ALTER COLUMN record_book DROP DEFAULT;
#+END_SRC

#+RESULTS:
#+begin_example
ALTER TABLE
DELETE 1
DELETE 1
INSERT 0 1
INSERT 0 1
INSERT 0 1
ALTER TABLE
ALTER TABLE
DELETE 1
ALTER TABLE
ALTER TABLE
#+end_example

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|
|           1 | Физика  | 2016/2017 |    1 |    5 |

*ON DELETE SET NULL*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ALTER COLUMN record_book DROP NOT NULL;

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE SET NULL;

  DELETE FROM students;

  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;
#+END_SRC

#+RESULTS:
: DELETE 1
: DELETE 1
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE
: ALTER TABLE
: DELETE 1
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|
|             | Физика  | 2016/2017 |    1 |    5 |

*ON DELETE CASCADE*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  ALTER TABLE progress
    ALTER COLUMN record_book SET NOT NULL;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE CASCADE;

  DELETE FROM students;

  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;
#+END_SRC

#+RESULTS:
: DELETE 1
: DELETE 0
: ALTER TABLE
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE
: DELETE 1
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|

*ON UPDATE CASCADE*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  ALTER TABLE progress
    ALTER COLUMN record_book SET NOT NULL;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON UPDATE CASCADE;

  UPDATE students SET record_book = 1;
#+END_SRC

#+RESULTS:
: DELETE 0
: DELETE 0
: ALTER TABLE
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|
|           1 | Физика  | 2016/2017 |    1 |    5 |
*** Вопрос 8
В таблице ~progress~ есть атрибут ~subject~. Это текстовый атрибут. Одинаковые
наименования учебных дисциплин записываются в таблицу ~progress~ многократно.
Создайте еще одну таблицу — ~subjects~, в которой будет два атрибута:
~subject_id~ и ~subject~. Тип данных первого из них будет ~integer~, а второго —
~text~. В качестве первичного ключа будет служить ~subject_id~, а второй атрибут
будет уникальным. Введите в новую таблицу две три строки для различных учебных
дисциплин.

Модифицируйте таблицу ~progress~, заменив атрибут ~subject~ на ~subject_id~. Тип
данных нового атрибута будет ~integer~. Поскольку тип данных изменится, то для
замены первоначальных значений, хранящихся в этом столбце, на новые придется
использовать конструкцию ~USING~ (о ней говорится в тексте главы).

Добавьте в определение таблицы ~progress~ еще один внешний ключ, который будет
ссылаться на таблицу ~subjects~. В составе этого внешнего ключа будет только
один атрибут — ~subject_id~. Мы видим, что таблица может иметь больше одного
внешнего ключа. Таким образом, структура связей в реальной базе данных может
оказаться весьма сложной.

Теперь введите несколько строк и в таблицу ~progress~, учитывая ее связь с новой
таблицей ~subjects~.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,

    FOREIGN KEY (record_book) REFERENCES students (record_book)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE subjects (
    subject_id integer,
    subject    text NOT NULL,

    PRIMARY KEY (subject_id),
    UNIQUE (subject)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  INSERT INTO subjects (subject_id, subject)
    VALUES (1, 'Физика'),
           (2, 'Математика');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 2

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval n
  ALTER TABLE progress
    RENAME COLUMN subject TO subject_id;

  ALTER TABLE progress
    ALTER COLUMN subject_id SET DATA TYPE integer
      USING ( CASE WHEN subject_id = 'Физика' THEN 1
                   WHEN subject_id = 'Математика' THEN 2
                   ELSE NULL END
      );
#+END_SRC

#+RESULTS:
: ALTER TABLE
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject_id | acad_year | term | mark |
|-------------+------------+-----------+------+------|
|       12300 |          1 | 2016/2017 |    1 |    5 |

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE progress
    ADD FOREIGN KEY (subject_id) REFERENCES subjects (subject_id);

  INSERT INTO progress (record_book, subject_id, acad_year, term)
    VALUES (12300, 2, '2016/2017', 2);
#+END_SRC

#+RESULTS:
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject_id | acad_year | term | mark |
|-------------+------------+-----------+------+------|
|       12300 |          1 | 2016/2017 |    1 |    5 |
|       12300 |          2 | 2016/2017 |    2 |    5 |
*** Вопрос 9
В таблице ~students~ есть текстовый атрибут ~name~, на который наложено
ограничение ~NOT NULL~. Как вы думаете, что будет, если при вводе новой строки в
эту таблицу дать атрибуту ~name~ в качестве значения пустую строку? Например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, '', 0402, 543281);
#+END_SRC

Наверное, проектируя эту таблицу, мы хотели бы все же, чтобы пустые строки в
качестве значения атрибута ~name~ не проходили в базу данных? Какое решение вы
можете предложить? Видимо, нужно добавить ограничение ~CHECK~ для столбца
~name~. Если вы еще не изучили команду ~ALTER TABLE~, то удалите таблицу
~students~ и создайте ее заново с учетом нового ограничения, а если вы уже
познакомились с командой ~ALTER TABLE~, то сделайте так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE students ADD CHECK (name <> '');
#+END_SRC

Добавив ограничение, попробуйте теперь вставить в таблицу ~students~ строку
(~row~), в которой значение атрибута ~name~ было бы пустой строкой (~string~).

Давайте продолжим эксперименты и предложим в качестве значения атрибута ~name~
строку, содержащую сначала один пробел, а потом — два пробела.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students VALUES (12346, ' ', 0406, 112233);
  INSERT INTO students VALUES (12347, '  ', 0407, 112234);
#+END_SRC

Для того чтобы «увидеть» эти пробелы в выборке, сделаем так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT *, length(name) FROM students;
#+END_SRC

Оказывается, эти невидимые значения имеют ненулевую длину. Что делать, чтобы не
допустить таких значений-невидимок? Один из способов: возложить проверку таких
ситуаций на прикладную программу. А что можно сделать на уровне определения
таблицы ~students~? Какое ограничение нужно предложить? В разделе 9.4
документации «Строковые функции и операторы» есть функция ~trim~. Попробуйте
воспользоваться ею. Если вы еще не изучили команду ~ALTER TABLE~, то удалите
таблицу ~students~ и создайте ее заново с учетом нового ограничения, а если уже
познакомились с ней, то сделайте так:

src_sql[:exports code]{ALTER TABLE students ADD CHECK (...);}

Есть ли подобные слабые места в таблице ~progress~?

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,

    FOREIGN KEY (record_book) REFERENCES students (record_book)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, '', 0402, 543281);
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name | doc_ser | doc_num |
|-------------+------+---------+---------|
|       12300 |      |     402 |  543281 |

*ОТВЕТ*: пустая строка не равняятся ~NULL~.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM students;
  ALTER TABLE students ADD CHECK (name <> '');
#+END_SRC

#+RESULTS:
: DELETE 1
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students VALUES (12346, ' ', 0406, 112233);
  INSERT INTO students VALUES (12347, '  ', 0407, 112234);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *, length(name) FROM students;
#+END_SRC

#+RESULTS:
| record_book | name | doc_ser | doc_num | length |
|-------------+------+---------+---------+--------|
|       12346 |      |     406 |  112233 |      1 |
|       12347 |      |     407 |  112234 |      2 |

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM students;
  ALTER TABLE students ADD CHECK (trim(name) <> '');
#+END_SRC

#+RESULTS:
: DELETE 2
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO students VALUES (12346, ' ', 0406, 112233);
  INSERT INTO students VALUES (12347, '  ', 0407, 112234);
#+END_SRC

#+RESULTS:
: ERROR:  new row for relation "students" violates check constraint "students_name_check1"
: DETAIL:  Failing row contains (12346,  , 406, 112233).

*ОТВЕТ*: В таблице ~progress~ подобные слабые места. Можно защититься так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval n
  ALTER TABLE progress
    ADD CHECK (trim(subject) <> ''),
    ADD CHECK (trim(acad_year) <> '');
#+END_SRC

#+RESULTS:
: ALTER TABLE
*** Вопрос 10
В таблице ~students~ атрибут ~doc_ser~ имеет числовой тип, однако в сериях таких
документов могут встречаться лидирующие нули, которые в числовых столбцах не
сохраняются. Например, при записи значения серии «0402» первый ноль не
сохранится. Модифицируйте таблицу ~students~, заменив числовой тип данных на
символьный, например, ~character~. Как вы думаете, эта операция пройдет без
затруднений или они все же возможны? Проверьте ваши предположения, выполнив
модификацию.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value vebatim :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  ALTER TABLE students
    ALTER COLUMN doc_ser SET DATA TYPE char(4);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12301, 'Иванов Иван Иванович', '0402', 543281);
#+END_SRC

#+RESULTS:
: CREATE TABLE
: INSERT 0 1
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num |
|-------------+----------------------+---------+---------|
|       12300 | Иванов Иван Иванович |     402 |  543281 |
|       12301 | Иванов Иван Иванович |    0402 |  543281 |
*** Вопрос 11
В таблице ~flights~ есть ограничение, которое регулирует соотношения значений
фактического времени вылета и фактического времени прилета. Как вы думаете, не
является ли выражение ~actual_arrival IS NOT NULL~ во второй части условного
оператора ~OR~ избыточным?

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE flights (
    ...
    CHECK ( actual_arrival IS NULL OR
           ( actual_departure IS NOT NULL AND
             actual_arrival IS NOT NULL AND
             actual_arrival > actual_departure
           )
    ),
    ...
#+END_SRC

Проверьте ваши предположения на практике. Для этого сначала удалите существующее
ограничение с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE flights DROP CONSTRAINT имя-ограничения;
#+END_SRC

Как определить имя этого ограничения? С помощью команды ~\d flights~ получите
описание таблицы ~flights~, а в нем есть названия всех ограничений. Затем
создайте это же ограничение, но в модифицированном виде:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE flights
    ADD CHECK ( actual_arrival IS NULL OR
               ( actual_departure IS NOT NULL AND
                 actual_arrival > actual_departure
               )
    );
#+END_SRC

Попробуйте добавить в таблицу ~flights~ две-три строки, подбирая такие значения
атрибутов ~actual_departure~ и ~actual_arrival~, чтобы проверить все возможные
исходы этих проверок. Конечно, вместо добавления новых строк можно
модифицировать одну и ту же строку с помощью команды ~UPDATE~.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d flights
#+END_SRC

#+RESULTS:
#+begin_example
                               Table "public.flights"
         Column         |           Type           | Collation | Nullable | Default
------------------------+--------------------------+-----------+----------+---------
 flight_id              | integer                  |           | not null |
 flight_no              | character(6)             |           | not null |
 scheduled_departure    | timestamp with time zone |           | not null |
 scheduled_arrival      | timestamp with time zone |           | not null |
 departure_airport_code | character(3)             |           | not null |
 arrival_airport_code   | character(3)             |           | not null |
 status                 | character varying(20)    |           | not null |
 aircraft_code          | character(3)             |           | not null |
 actual_departure       | timestamp with time zone |           |          |
 actual_arrival         | timestamp with time zone |           |          |
Indexes:
    "flights_pkey" PRIMARY KEY, btree (flight_id)
    "flights_flight_no_scheduled_departure_index" UNIQUE CONSTRAINT, btree (flight_no, scheduled_departure)
Check constraints:
    "flights_actual_arrival_time_check" CHECK (actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure)
    "flights_arrival_time_check" CHECK (scheduled_arrival > scheduled_departure)
    "flights_status_check" CHECK (status::text = ANY (ARRAY['On Time'::text, 'Delayed'::text, 'Departed'::text, 'Arrived'::text, 'Scheduled'::text, 'Cancelled'::text]))
Foreign-key constraints:
    "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    "flights_arrival_airport_code_fkey" FOREIGN KEY (arrival_airport_code) REFERENCES airports(airport_code)
    "flights_departure_airport_code_fkey" FOREIGN KEY (departure_airport_code) REFERENCES airports(airport_code)
Referenced by:
    TABLE "ticket_flights" CONSTRAINT "ticket_flights_flight_id_fkey" FOREIGN KEY (flight_id) REFERENCES flights(flight_id)

#+end_example

*TODO* ответить на вопрос
*** Вопрос 12
Команда ~ALTER TABLE~ позволяет переименовать таблицу. Например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE table_name RENAME TO new_table_name;
#+END_SRC

Поскольку в командах создания таблиц базы данных «Авиаперевозки» мы не указывали
имена ограничений для первичных и внешних ключей, то их имена были сформированы
автоматически самой СУБД. Как вы думаете, получили ли эти ограничения новые
имена после переименования таблицы?

Проверьте ваши предположения, выполнив такую операцию с одной из таблиц базы
данных «Авиаперевозки», имеющих внешние ключи.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval n
  ALTER TABLE flights RENAME TO полёты;
#+END_SRC

#+RESULTS:
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d полёты
#+END_SRC

#+RESULTS:
#+begin_example
                               Table "public.полёты"
         Column         |           Type           | Collation | Nullable | Default
------------------------+--------------------------+-----------+----------+---------
 flight_id              | integer                  |           | not null |
 flight_no              | character(6)             |           | not null |
 scheduled_departure    | timestamp with time zone |           | not null |
 scheduled_arrival      | timestamp with time zone |           | not null |
 departure_airport_code | character(3)             |           | not null |
 arrival_airport_code   | character(3)             |           | not null |
 status                 | character varying(20)    |           | not null |
 aircraft_code          | character(3)             |           | not null |
 actual_departure       | timestamp with time zone |           |          |
 actual_arrival         | timestamp with time zone |           |          |
Indexes:
    "flights_pkey" PRIMARY KEY, btree (flight_id)
    "flights_flight_no_scheduled_departure_index" UNIQUE CONSTRAINT, btree (flight_no, scheduled_departure)
Check constraints:
    "flights_actual_arrival_time_check" CHECK (actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure)
    "flights_arrival_time_check" CHECK (scheduled_arrival > scheduled_departure)
    "flights_status_check" CHECK (status::text = ANY (ARRAY['On Time'::text, 'Delayed'::text, 'Departed'::text, 'Arrived'::text, 'Scheduled'::text, 'Cancelled'::text]))
Foreign-key constraints:
    "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    "flights_arrival_airport_code_fkey" FOREIGN KEY (arrival_airport_code) REFERENCES airports(airport_code)
    "flights_departure_airport_code_fkey" FOREIGN KEY (departure_airport_code) REFERENCES airports(airport_code)
Referenced by:
    TABLE "ticket_flights" CONSTRAINT "ticket_flights_flight_id_fkey" FOREIGN KEY (flight_id) REFERENCES "полёты"(flight_id)
#+end_example

Ограничения новые имена не получат. Их нужно переименовать вручную.
*** Вопрос 13
И представление ~flights_v~, и материализованное представление ~routes~
построены на основе таблиц ~flights~ и ~airports~. Логично предположить, что при
каскадном удалении, например, таблицы «Аэропорты», представление «Рейсы» будет
также удалено, поскольку при удалении базовой таблицы этому представлению просто
неоткуда будет брать данные.

А что вы можете предположить насчет материализованного представления «Маршруты»:
будет ли оно также удалено или нет? Ведь оно уже содержит данные, в отличие от
обычного представления. Так ли, условно говоря, сильна его связь с таблицами, на
основе которых оно сконструировано?

Проведите необходимые эксперименты, начав с команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE airports;
#+END_SRC

Если вам потребуется восстановить все объекты базы данных, то вы всегда сможете
воспользоваться файлом ~demo_small.sql~ и просто повторить процедуру
развертывания учебной базы данных, которая описана в главе 2. Поэтому смело
экспериментируйте с таблицами и представлениями.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  DROP TABLE airports;
#+END_SRC

#+RESULTS:
: ERROR:  cannot drop table airports because other objects depend on it
: DETAIL:  view flights_v depends on table airports
: view routes depends on table airports
: constraint flights_arrival_airport_code_fkey on table "полёты" depends on table airports
: constraint flights_departure_airport_code_fkey on table "полёты" depends on table airports
: HINT:  Use DROP ... CASCADE to drop the dependent objects too.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE airports CASCADE;
#+END_SRC

#+RESULTS:
: DROP TABLE

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d routes
#+END_SRC

#+RESULTS:
: error: Did not find any relation named "routes".
*** Вопрос 14
Представления (~views~) могут быть обновляемыми. Это значит, что можно с помощью
команд ~INSERT~, ~UPDATE~ и ~DELETE~, применяемых к представлению, внести
изменения в таблицу, лежащую в основе этого представления.

Самостоятельно ознакомьтесь с этим вопросом с помощью документации (см. описание
команды ~CREATE VIEW~) и, создав простое представление над одной из таблиц базы
данных «Авиаперевозки», выполните несколько команд с целью внесения изменений в
эту таблицу.

*TODO* ответить на вопрос
*** Вопрос 15
Определение таблицы можно изменить с помощью команды ~ALTER TABLE~. Аналогичные
команды существуют и для изменения представлений и материализованных
представлений: ~ALTER VIEW~ и ~ALTER MATERIALIZED VIEW~. Самостоятельно
ознакомьтесь с их возможностями с помощью документации.

*TODO* ответить на вопрос
*** Вопрос 16
Как вы думаете, при изменении данных в таблицах, на основе которых
сконструировано материализованное представление, содержимое этого представления
тоже синхронно изменяется или нет?

Если содержимое материализованного представления изменяется синхронно с базовыми
таблицами, то продемонстрируйте это. Если же оно остается неизменным, то
покажите, как его синхронизировать с базовыми таблицами.

*ОТВЕТ*

Требуется ручная инициализация синхронизации следующей командой:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  REFRESH MATERIALIZED VIEW routes;
#+END_SRC
* Схема базы
** Миграции
#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Repo.Migrations.AddsAircraftsTable do
    use Ecto.Migration

    def change do
      create table(:aircrafts, primary_key: false, comment: "Aircrafts") do
        add :aircraft_code, :char, size: 3, primary_key: true, comment: "Aircraft code, IATA"
        add :model, :text, null: false, comment: "Aircraft model"
        add :range, :integer, null: false, comment: "Maximal flying distance, km"
      end

      create constraint(:aircrafts, "aircrafts_range_check", check: "range > 0", comment: "range should be greater than 0")
    end
  end

  defmodule AirDB.Repo.Migrations.AddsAirportsTable do
    use Ecto.Migration

    def change do
      create table(:airports, primary_key: false, comment: "Airports") do
        add :airport_code, :char, size: 3, primary_key: true, comment: "Airport code"
        add :airport_name, :text, null: false, comment: "Airport name"
        add :city, :text, null: false, comment: "City"
        add :coordinates, :point, null: false, comment: "Airport coordinates (longitude and latitude)"
        add :timezone, :text, null: false, comment: "Airport time zone"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsBookingsTable do
    use Ecto.Migration

    def change do
      create table(:bookings, primary_key: false, comment: "Bookings") do
        add :book_ref, :char, size: 6, primary_key: true, comment: "Booking number"
        add :book_date, :timestamptz, null: false, comment: "Booking date"
        add :total_amount, :numeric, null: false, precision: 10, scale: 2, comment: "Total booking cost"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsFlightsTable do
    use Ecto.Migration

    def up do
      create table(:flights, primary_key: false, comment: "Flights") do
        add :flight_id, :integer, primary_key: true, comment: "Flight ID"
        add :flight_no, :char, size: 6, null: false, comment: "Flight number"
        add :scheduled_departure, :timestamptz, null: false, comment: "Scheduled departure time"
        add :scheduled_arrival, :timestamptz, null: false, comment: "Scheduled arrival time"

        add :departure_airport_code,
          references(:airports, column: :airport_code, type: :char),
          size: 3,
          null: false,
          comment: "Airport of departure"

        add :arrival_airport_code,
          references(:airports, column: :airport_code, type: :char),
          size: 3,
          null: false,
          comment: "Airport of arrival"

        add :status, :varchar, size: 20, null: false, comment: "Flight status"

        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char),
          size: 3,
          null: false,
          comment: "Aircraft code, IATA"

        add :actual_departure, :timestamptz, comment: "Actual departure time"
        add :actual_arrival, :timestamptz, comment: "Actual arrival time"
      end

      create constraint(
        :flights,
        "flights_arrival_time_check",
        check: "scheduled_arrival > scheduled_departure"
      )

      create constraint(
        :flights,
        "flights_actual_arrival_time_check",
        check: "actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure"
      )

      create constraint(
        :flights,
        "flights_status_check",
        check: "status = ANY(ARRAY['On Time', 'Delayed', 'Departed', 'Arrived', 'Scheduled', 'Cancelled'])"
      )

      create unique_index(:flights, [:flight_no, :scheduled_departure])

      execute ~S"""
      ALTER TABLE flights
        ADD CONSTRAINT "flights_flight_no_scheduled_departure_index"
          UNIQUE USING INDEX "flights_flight_no_scheduled_departure_index"
      """
    end

    def down do
      drop table(:flights)
    end
  end

  defmodule AirDB.Repo.Migrations.AddsFlightsView do
    use Ecto.Migration

    def up do
      execute """
      CREATE VIEW flights_v AS
       SELECT f.flight_id,
              f.flight_no,
              f.scheduled_departure,
              timezone(dep.timezone, f.scheduled_departure) AS scheduled_departure_local,
              f.scheduled_arrival,
              timezone(arr.timezone, f.scheduled_arrival) AS scheduled_arrival_local,
              (f.scheduled_arrival - f.scheduled_departure) AS scheduled_duration,
              f.departure_airport_code,
              dep.airport_name AS departure_airport_name,
              dep.city AS departure_city,
              f.arrival_airport_code,
              arr.airport_name AS arrival_airport_name,
              arr.city AS arrival_city,
              f.status,
              f.aircraft_code,
              f.actual_departure,
              timezone(dep.timezone, f.actual_departure) AS actual_departure_local,
              f.actual_arrival,
              timezone(arr.timezone, f.actual_arrival) AS actual_arrival_local,
              (f.actual_arrival - f.actual_departure) AS actual_duration
         FROM flights f,
              airports dep,
              airports arr
        WHERE f.departure_airport_code = dep.airport_code
          AND f.arrival_airport_code = arr.airport_code
      """

      execute "COMMENT ON VIEW flights_v IS 'Flights (extended)'"
      execute "COMMENT ON COLUMN flights_v.flight_id IS 'Flight ID'"
      execute "COMMENT ON COLUMN flights_v.flight_no IS 'Flight number'"
      execute "COMMENT ON COLUMN flights_v.scheduled_departure IS 'Scheduled departure time'"
      execute "COMMENT ON COLUMN flights_v.scheduled_departure_local IS 'Scheduled departure time, local time at the point of departure'"
      execute "COMMENT ON COLUMN flights_v.scheduled_arrival IS 'Scheduled arrival time'"
      execute "COMMENT ON COLUMN flights_v.scheduled_arrival_local IS 'Scheduled arrival time, local time at the point of destionation'"
      execute "COMMENT ON COLUMN flights_v.scheduled_duration IS 'Scheduled flight duration'"
      execute "COMMENT ON COLUMN flights_v.departure_airport_code IS 'Departure airport code'"
      execute "COMMENT ON COLUMN flights_v.departure_airport_name IS 'Departure airport name'"
      execute "COMMENT ON COLUMN flights_v.departure_city IS 'City of departure'"
      execute "COMMENT ON COLUMN flights_v.arrival_airport_code IS 'Arrival airport code'"
      execute "COMMENT ON COLUMN flights_v.arrival_airport_name IS 'Arrival airport name'"
      execute "COMMENT ON COLUMN flights_v.arrival_city IS 'City of arrival'"
      execute "COMMENT ON COLUMN flights_v.status IS 'Flight status'"
      execute "COMMENT ON COLUMN flights_v.aircraft_code IS 'Aircraft code, IATA'"
      execute "COMMENT ON COLUMN flights_v.actual_departure IS 'Actual departure time'"
      execute "COMMENT ON COLUMN flights_v.actual_departure_local IS 'Actual departure time, local time at the point of departure'"
      execute "COMMENT ON COLUMN flights_v.actual_arrival IS 'Actual arrival time'"
      execute "COMMENT ON COLUMN flights_v.actual_arrival_local IS 'Actual arrival time, local time at the point of destination'"
      execute "COMMENT ON COLUMN flights_v.actual_duration IS 'Actual flight duration'"
    end

    def down do
      execute "DROP VIEW flights_v"
    end
  end

  defmodule AirDB.Repo.Migrations.AddsSeatsTable do
    use Ecto.Migration

    def change do
      create table(:seats, primary_key: false, comment: "Seats") do
        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char, on_delete: :delete_all),
          size: 3,
          primary_key: true,
          comment: "Aircraft code, IATA"

        add :seat_no, :varchar, size: 4, primary_key: true, comment: "Seat number"
        add :fare_conditions, :varchar, size: 10, null: false, comment: "Travel class"
      end

      create constraint(
        :seats,
        "seats_fare_conditions_check",
        check: "fare_conditions = ANY(ARRAY['Economy', 'Comfort', 'Business'])"
      )
    end
  end

  defmodule AirDB.Repo.Migrations.AddsTicketsTable do
    use Ecto.Migration

    def change do
      create table(:tickets, primary_key: false, comment: "Tickets") do
        add :ticket_no, :char, size: 13, primary_key: true, comment: "Ticket number"

        add :book_ref,
          references(:bookings, column: :book_ref, type: :char),
          size: 6,
          null: false,
          comment: "Booking number"

        add :passenger_id, :varchar, size: 20, null: false, comment: "Passenger ID"
        add :passenger_name, :text, null: false, comment: "Passenger name"
        add :contact_data, :jsonb, comment: "Passenger contact information"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsTicketFlightsTable do
    use Ecto.Migration

    def change do
      create table(:ticket_flights, primary_key: false, comment: "Flight segment") do
        add :ticket_no,
          references(:tickets, column: :ticket_no, type: :char),
          size: 13,
          primary_key: true,
          comment: "Ticket number"

        add :flight_id,
          references(:flights, column: :flight_id, type: :integer),
          primary_key: true,
          comment: "Flight ID"

        add :fare_conditions, :varchar, size: 10, null: false, comment: "Travel class"
        add :amount, :numeric, precision: 10, scale: 2, null: false, comment: "Travel cost"
      end

      create constraint(:ticket_flights, "ticket_flights_amount_check", check: "amount > 0")
      create constraint(
        :ticket_flights,
        "ticket_flights_fare_condition_check",
        check: "fare_conditions = ANY(ARRAY['Economy', 'Comfort', 'Business'])"
      )
    end
  end

  defmodule AirDB.Repo.Migrations.AddsBoardingPassesTable do
    use Ecto.Migration

    def up do
      create table(:boarding_passes, primary_key: false, comment: "Boarding passes") do
        add :ticket_no,
          references(:ticket_flights, column: :ticket_no, with: [flight_id: :flight_id], type: :char),
          size: 13,
          primary_key: true,
          comment: "Ticket number"

        add :flight_id, :integer, primary_key: true, comment: "Flight ID"
        add :boarding_no, :integer, null: false, comment: "Boarding pass number"
        add :seat_no, :varchar, size: 4, null: false, comment: "Seat number"
      end

      create unique_index(:boarding_passes, [:flight_id, :boarding_no])
      create unique_index(:boarding_passes, [:flight_id, :seat_no])

      execute ~S"""
      ALTER TABLE boarding_passes
        ADD CONSTRAINT "boarding_passes_flight_id_boarding_no_index"
          UNIQUE USING INDEX "boarding_passes_flight_id_boarding_no_index"
      """

      execute ~S"""
      ALTER TABLE boarding_passes
        ADD CONSTRAINT "boarding_passes_flight_id_seat_no_index"
          UNIQUE USING INDEX "boarding_passes_flight_id_seat_no_index"
      """
    end

    def down do
      drop table(:boarding_passes)
    end
  end

  defmodule AirDB.Repo.Migrations.AddsRoutesView do
    use Ecto.Migration

    def up do
      execute """
      CREATE VIEW routes AS
      WITH f3 AS (
              SELECT f2.flight_no,
                  f2.departure_airport_code,
                  f2.arrival_airport_code,
                  f2.aircraft_code,
                  f2.duration,
                  array_agg(f2.days_of_week) AS days_of_week
                FROM ( SELECT f1.flight_no,
                          f1.departure_airport_code,
                          f1.arrival_airport_code,
                          f1.aircraft_code,
                          f1.duration,
                          f1.days_of_week
                        FROM ( SELECT flights.flight_no,
                                  flights.departure_airport_code,
                                  flights.arrival_airport_code,
                                  flights.aircraft_code,
                                  (flights.scheduled_arrival - flights.scheduled_departure) AS duration,
                                  (to_char(flights.scheduled_departure, 'ID'::text))::integer AS days_of_week
                                FROM flights) f1
                        GROUP BY f1.flight_no, f1.departure_airport_code, f1.arrival_airport_code, f1.aircraft_code, f1.duration, f1.days_of_week
                        ORDER BY f1.flight_no, f1.departure_airport_code, f1.arrival_airport_code, f1.aircraft_code, f1.duration, f1.days_of_week) f2
                GROUP BY f2.flight_no, f2.departure_airport_code, f2.arrival_airport_code, f2.aircraft_code, f2.duration
              )
      SELECT f3.flight_no,
          f3.departure_airport_code,
          dep.airport_name AS departure_airport_name,
          dep.city AS departure_city,
          f3.arrival_airport_code,
          arr.airport_name AS arrival_airport_name,
          arr.city AS arrival_city,
          f3.aircraft_code,
          f3.duration,
          f3.days_of_week
        FROM f3,
          airports dep,
          airports arr
        WHERE ((f3.departure_airport_code = dep.airport_code) AND (f3.arrival_airport_code = arr.airport_code))
      """

      execute "COMMENT ON VIEW routes IS 'Routes'"
      execute "COMMENT ON COLUMN routes.flight_no IS 'Flight number'"
      execute "COMMENT ON COLUMN routes.departure_airport_code IS 'Code of airport of departure'"
      execute "COMMENT ON COLUMN routes.departure_airport_name IS 'Name of airport of departure'"
      execute "COMMENT ON COLUMN routes.departure_city IS 'City of departure'"
      execute "COMMENT ON COLUMN routes.arrival_airport_code IS 'Code of airport of arrival'"
      execute "COMMENT ON COLUMN routes.arrival_airport_name IS 'Name of airport of arrival'"
      execute "COMMENT ON COLUMN routes.arrival_city IS 'City of arrival'"
      execute "COMMENT ON COLUMN routes.aircraft_code IS 'Aircraft code, IATA'"
      execute "COMMENT ON COLUMN routes.duration IS 'Scheduled duration of flight'"
      execute "COMMENT ON COLUMN routes.days_of_week IS 'Days of week on which flights are scheduled'"
    end

    def down do
      execute "DROP VIEW routes"
    end
  end
#+END_SRC
** Схемы
#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Aircraft do
    use Ecto.Schema

    import Ecto.Changeset

    alias AirDB.Seat
    alias AirDB.Route

    @primary_key false
    schema "aircrafts" do
      field :aircraft_code, :string, primary_key: true
      field :model, :string
      field :range, :integer

      has_many :seats, Seat,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        on_replace: :mark_as_invalid

      has_many :routes, Route,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        on_replace: :mark_as_invalid
    end

    @doc false
    def changeset(aircraft, params \\ %{}) do
      aircraft
      |> cast(params, [:aircraft_code, :model, :range])
      |> cast_assoc(:seats, with: &Seat.changeset/2)
      |> validate_required([:aircraft_code, :model, :range])
      |> validate_length(:aircraft_code, is: 3, count: :bytes)
      |> unique_constraint(:aircraft_code, name: :aircrafts_pkey)
      |> check_constraint(:range, name: :aircrafts_range_check, message: "should be greater than 0")
    end
  end

  defmodule AirDB.Airport do
    use Ecto.Schema
    import Ecto.Changeset

    @primary_key false
    schema "airports" do
      field :airport_code, :string, primary_key: true
      field :airport_name, :string
      field :city, :string
      field :coordinates, AirDB.Ecto.Point
      field :timezone, :string
    end

    @doc false
    def changeset(airport, params \\ %{}) do
      airport
      |> cast(params, [:airport_code, :airport_name, :city, :coordinates, :timezone])
      |> validate_required([:airport_code, :airport_name, :city, :coordinates, :timezone])
      |> validate_length(:airport_code, is: 3, count: :bytes)
      |> unique_constraint(:airport_code, name: :airports_pkey)
    end
  end

  defmodule AirDB.BoardingPass do
    use Ecto.Schema

    import Ecto.Changeset

    alias AirDB.Flight
    alias AirDB.Ticket

    @primary_key false
    schema "boarding_passes" do
      belongs_to :ticket, Ticket,
        primary_key: true,
        foreign_key: :ticket_no,
        references: :ticket_no,
        type: :string

      belongs_to :flight, Flight,
        primary_key: true,
        foreign_key: :flight_id,
        references: :flight_id,
        type: :integer

      field :boarding_no, :integer
      field :seat_no, :string
    end

    @doc false
    def changeset(boarding_pass, params \\ %{}) do
      boarding_pass
      |> cast(params, [:ticket_no, :flight_id, :boarding_no, :seat_no])
      |> validate_required([:ticket_no, :flight_id, :boarding_no, :seat_no])
      |> unique_constraint([:ticket_no, :flight_id], name: :boarding_passes_pkey)
      |> unique_constraint([:flight_id, :boarding_no],
        message: "boarding no has already been taken"
      )
      |> unique_constraint([:flight_id, :seat_no], message: "seat no has already been taken")
      |> foreign_key_constraint(:ticket_no,
        name: :boarding_passes_ticket_no_fkey,
        message: "ticket_flights does not exist"
      )
      |> validate_length(:ticket_no, is: 13, count: :bytes)
      |> validate_length(:seat_no, min: 2, max: 4, count: :bytes)
    end
  end

  defmodule AirDB.Booking do
    use Ecto.Schema
    import Ecto.Changeset

    @primary_key false
    schema "bookings" do
      field :book_ref, :string, primary_key: true
      field :book_date, :utc_datetime
      field :total_amount, :decimal
    end

    @doc false
    def changeset(booking, params \\ %{}) do
      booking
      |> cast(params, [:book_ref, :book_date, :total_amount])
      |> validate_required([:book_ref, :book_date, :total_amount])
      |> validate_length(:book_ref, is: 6, count: :bytes)
      |> unique_constraint(:book_ref, name: :bookings_pkey)
    end
  end

  defmodule AirDB.Flight do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Airport
    alias AirDB.Aircraft

    @primary_key false
    schema "flights" do
      field :flight_id, :integer, primary_key: true
      field :flight_no, :string

      field :scheduled_departure, :utc_datetime
      field :scheduled_arrival, :utc_datetime

      field :status, :string

      field :actual_departure, :utc_datetime
      field :actual_arrival, :utc_datetime

      belongs_to :departure_airport, Airport,
        foreign_key: :departure_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :arrival_airport, Airport,
        foreign_key: :arrival_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :aircraft, Aircraft,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string
    end

    @doc false
    def changeset(flight, params \\ %{}) do
      flight
      |> cast(params, [
        :flight_id,
        :flight_no,
        :scheduled_departure,
        :scheduled_arrival,
        :departure_airport_code,
        :arrival_airport_code,
        :status,
        :aircraft_code,
        :actual_departure,
        :actual_arrival
      ])
      |> cast_assoc(:departure_airport, with: &Airport.changeset/2)
      |> cast_assoc(:arrival_airport, with: &Airport.changeset/2)
      |> cast_assoc(:aircraft, with: &Aircraft.changeset/2)
      |> validate_required([
        :flight_id,
        :flight_no,
        :scheduled_departure,
        :scheduled_arrival,
        :status
      ])
      |> validate_length(:flight_no, is: 6, count: :bytes)
      |> validate_length(:departure_airport_code, is: 3, count: :bytes)
      |> validate_length(:arrival_airport_code, is: 3, count: :bytes)
      |> validate_length(:aircraft_code, is: 3, count: :bytes)
      |> validate_inclusion(:status, [
        "On Time",
        "Delayed",
        "Departed",
        "Arrived",
        "Scheduled",
        "Cancelled"
      ])
      |> check_constraint(:status, name: :flights_status_check)
      |> check_constraint(:scheduled_arrival, name: :flights_arrival_time_check)
      |> check_constraint(:actual_arrival, name: :flights_actual_arrival_time_check)
      |> unique_constraint(:flight_id, name: :flights_pkey)
      |> unique_constraint([:flight_no, :scheduled_departure])
      |> foreign_key_constraint(:departure_airport_code)
      |> foreign_key_constraint(:arrival_airport_code)
      |> foreign_key_constraint(:aircraft_code)
    end
  end

  defmodule AirDB.FlightExtended do
    use Ecto.Schema

    @primary_key false
    schema "flights_v" do
      field :flight_id, :integer
      field :flight_no, :string
      field :scheduled_departure, :utc_datetime
      field :scheduled_departure_local, :naive_datetime
      field :scheduled_arrival, :utc_datetime
      field :scheduled_arrival_local, :naive_datetime
      # interval
      field :scheduled_duration, :binary
      field :departure_airport_name, :string
      field :departure_city, :string
      field :arrival_airport_name, :string
      field :arrival_city, :string
      field :status, :string
      field :actual_departure, :utc_datetime
      field :actual_departure_local, :naive_datetime
      field :actual_arrival, :utc_datetime
      field :actual_arrival_local, :naive_datetime
      # interval
      field :actual_duration, :binary

      belongs_to :departure_airport, Airport,
        foreign_key: :departure_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :arrival_airport, Airport,
        foreign_key: :arrival_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :aircraft, Aircraft,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string
    end
  end

  defmodule AirDB.Route do
    use Ecto.Schema

    @primary_key false
    schema "routes" do
      field :flight_no, :string
      field :departure_airport_name, :string
      field :departure_city, :string
      field :arrival_airport_name, :string
      field :arrival_city, :string
      field :duration, :binary
      field :days_of_week, {:array, :integer}

      belongs_to :aircraft, AirDB.Aircraft,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string

      belongs_to :departure_airport, AirDB.Airport,
        foreign_key: :departure_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :arrival_airport, AirDB.Airport,
        foreign_key: :arrival_airport_code,
        references: :airport_code,
        type: :string
    end
  end

  defmodule AirDB.Seat do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Aircraft

    @primary_key false
    schema "seats" do
      belongs_to :aircraft, Aircraft,
        primary_key: true,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string

      field :seat_no, :string, primary_key: true
      field :fare_conditions, :string
    end

    @doc false
    def changeset(seat, params \\ %{}) do
      seat
      |> cast(params, [:aircraft_code, :seat_no, :fare_conditions])
      |> cast_assoc(:aircraft, with: &Aircraft.changeset/2)
      |> validate_required([:seat_no, :fare_conditions])
      |> validate_length(:aircraft_code, is: 3, count: :bytes)
      |> validate_length(:seat_no, min: 2, max: 4, count: :bytes)
      |> foreign_key_constraint(:aircraft_code)
      |> unique_constraint([:aircraft_code, :seat_no], name: :seats_pkey)
      |> validate_inclusion(:fare_conditions, ["Economy", "Comfort", "Business"])
      |> check_constraint(:fare_conditions, name: :seats_fare_conditions_check)
    end
  end

  defmodule AirDB.Ticket do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Booking

    @primary_key false
    schema "tickets" do
      field :ticket_no, :string, primary_key: true
      field :passenger_id, :string
      field :passenger_name, :string
      field :contact_data, :map

      belongs_to :booking, Booking,
        foreign_key: :book_ref,
        references: :book_ref,
        type: :string
    end

    @doc false
    def changeset(ticket, params \\ %{}) do
      ticket
      |> cast(params, [
        :ticket_no,
        :book_ref,
        :passenger_id,
        :passenger_name,
        :contact_data
      ])
      |> cast_assoc(:booking, with: &Booking.changeset/2)
      |> validate_required([
        :ticket_no,
        :passenger_id,
        :passenger_name,
        :contact_data
      ])
      |> validate_length(:ticket_no, is: 13, count: :bytes)
      |> validate_length(:book_ref, is: 6, count: :bytes)
      |> validate_length(:passenger_id, min: 11, max: 20, count: :bytes)
      |> unique_constraint(:ticket_no, name: :tickets_pkey)
      |> foreign_key_constraint(:book_ref)
    end
  end

  defmodule AirDB.TicketFlights do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Ticket
    alias AirDB.Flight

    @primary_key false
    schema "ticket_flights" do
      field :fare_conditions, :string
      field :amount, :decimal

      belongs_to :ticket, Ticket,
        primary_key: true,
        foreign_key: :ticket_no,
        references: :ticket_no,
        type: :string

      belongs_to :flight, Flight,
        primary_key: true,
        foreign_key: :flight_id,
        references: :flight_id,
        type: :integer
    end

    @doc false
    def changeset(ticket_flight, params \\ %{}) do
      ticket_flight
      |> cast(params, [
        :ticket_no,
        :flight_id,
        :fare_conditions,
        :amount
      ])
      |> cast_assoc(:ticket, with: &Ticket.changeset/2)
      |> cast_assoc(:flight, with: &Flight.changeset/2)
      |> validate_required([:fare_conditions, :amount])
      |> validate_length(:ticket_no, is: 13, count: :bytes)
      |> unique_constraint([:ticket_no, :flight_id], name: :ticket_flights_pkey)
      |> foreign_key_constraint(:ticket_no)
      |> foreign_key_constraint(:flight_id)
      |> check_constraint(:amount, name: :ticket_flights_amount_check)
      |> check_constraint(:fare_conditions, name: :ticket_flights_fare_condition_check)
      |> validate_inclusion(:fare_conditions, ["Economy", "Comfort", "Business"])
    end
  end
#+END_SRC
#+END_SRC
