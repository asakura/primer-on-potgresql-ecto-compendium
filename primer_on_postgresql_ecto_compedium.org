#+TITLE: Конспект PostgreSQL Основы языка SQL (и Elixir's Ecto)
#+AUTHOR: Mikalai Seva
#+EMAIL: mikalai.seva@gmail.com
#+DESCRIPTION:
#+KEYWORDS: PostgreSQL SQL Primer Ecto Elixir
#+LANGUAGE: ru, en
#+OPTIONS: H:3 toc:2 p:t
#+OPTIONS: ^:{}
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* Введение в базы данных и SQL
** Что такое базы данных
Одним из основных понятий в теории баз данных является *модель данных*. Можно
сказать, что она характеризует способ организации данных и основные методы
доступа к ним. В ходе эволюции теорий и идей была разработана реляционная модель
данных, которая сейчас и является доминирующей. Характерной чертой реляционных
баз данных является тот факт, что данные воспринимаются пользователем как
таблицы.

Одним из достоинств реляционной базы данных является ее способность поддерживать
связи между элементами данных, избавляя программиста от необходимости заниматься
этой рутинной и очень трудоемкой работой. Работая с реляционными базами данных,
программист избавлен от программирования на «атомарном» уровне, потому что
современные языки для «общения» с этими базами данных являются декларативными.

Система баз данных — это компьютеризированная система, предназначенная для
хранения, переработки и выдачи информации по запросу пользователей. Такая
система включает в себя программное и аппаратное обеспечение, сами данные, а
также пользователей.

Современные системы баз данных являются, как правило, многопользовательскими. В
таких системах одновременный доступ к базе данных могут получить сразу несколько
пользователей.

Основным программным обеспечением является система управления базами данных.
По-английски она называется /database management system/ (DBMS). Кроме СУБД в
систему баз данных могут входить утилиты, средства для разработки приложений
(программ), средства проектирования базы данных, генераторы отчетов и др.

Пользователи систем с базами данных подразделяются на ряд категорий. Первая
категория — это прикладные программисты. Вторая категория — это конечные
пользователи, ради которых и выполняется вся работа. Они могут получить доступ к
базе данных, используя прикладные программы или универсальные приложения,
которые входят в программное обеспечение самой СУБД. Третья категория
пользователей — это администраторы базы данных. В их обязанности входят:
создание базы данных, выбор оптимальных режимов доступа к ней, разграничение
полномочий различных пользователей на доступ к той или иной информации в базе
данных, выполнение резервного копирования базы данных и т.д.

Систему баз данных можно разделить на два главных компонента: сервер и набор
клиентов (или внешних интерфейсов). Сервер — это и есть СУБД. Один сервер может
обслуживать много клиентов.

Современные СУБД включают в себя словарь данных. Это часть базы данных, которая
описывает сами данные, хранящиеся в ней. Словарь данных помогает СУБД выполнять
свои функции.
** Основные понятия реляционной модели
В эпоху, предшествующую рождению реляционной теории, базы данных традиционно
рассматривались как набор *файлов*, состоящих из *записей*, а записи, в свою
очередь, подразделялись на отдельные *поля*. Поле являлось элементарной единицей
данных.

В реляционных базах данных пользователь воспринимает данные в виде таблиц.
Поэтому термину «файл» соответствует термин *«таблица»*, вместо термина «запись»
используется термин *«строка»*, а вместо термина «поле» — термин *«столбец»*
(или *«колонка»*).

В формальной теории реляционных баз данных эти таблицы называют *отношениями*
(*relations*) — поэтому и базы данных называются реляционными. Отношение — это
математический термин. При определении свойств таких отношений используется
теория множеств. В терминах данной теории строки таблицы будут называться
*кортежами* (*tuples*), а колонки — *атрибутами*. Отношение имеет заголовок,
который состоит из атрибутов, и тело, состоящее из кортежей. Количество
атрибутов называется *степенью отношения*, а количество кортежей — *кардинальным
числом*. Кроме теории множеств, одним из оснований реляционной теории является
такой раздел математической логики, как исчисление предикатов.

При работе с базами данных часто приходится следовать *различным ограничениям*,
которые могут быть обусловлены спецификой конкретной предметной области.

Для идентификации строк в таблицах и для связи таблиц между собой используются
так называемые ключи. *Потенциальный ключ* — это комбинация атрибутов таблицы,
позволяющая уникальным образом идентифицировать строки в ней. Ключ может
состоять только лишь из одного атрибута таблицы. Потенциальный ключ должен быть
*неизбыточным*, т.е. никакое подмножество атрибутов, входящих в него, не должно
обладать свойством уникальности. Ключ, состоящий из нескольких атрибутов
называется *составным*.

Ключи нужны для адресации на уровне строк (записей). При наличии в таблице более
одного потенциального ключа один из них выбирается в качестве так называемого
*первичного ключа*, а остальные будут являться *альтернативными ключами*.

*Внешним ключ* - это ключ, используемый для объединения двух таблиц. Таблица,
содержащая внешний ключ, называется *ссылающейся* таблицей (*referencing
table*). Таблица, содержащая соответствующий потенциальный ключ, называется
*ссылочной* (*целевой*) таблицей (*referenced table*). В таких случаях говорят,
что внешний ключ ссылается на потенциальный ключ в ссылочной таблице. Внешний
ключ может быть составным, т.е. может включать более одного атрибута. Внешний
ключ не обязан быть уникальным.

Проблема обеспечения того, чтобы база данных не содержала неверных значений
внешних ключей, известна как проблема *ссылочной целостности*. Ограничение,
согласно которому значения внешних ключей должны соответствовать значениям
потенциальных ключей, называется *ограничением ссылочной целостности*
(*ссылочным ограничением*).

Обеспечением выполнения ограничений ссылочной целостности занимается СУБД, а от
разработчика требуется лишь указать атрибуты, служащие в качестве внешних
ключей. При проектировании баз данных часто предусматривается, что при удалении
строки из ссылочной таблицы соответствующие строки из ссылающейся таблицы должны
быть также удалены, а при изменении значения столбца, на который ссылается
внешний ключ, должны быть изменены значения внешнего ключа в ссылающейся
таблице. Этот подход называется *каскадным удалением* (*обновлением*).

Иногда применяются и другие подходы. Например, вместо удаления строк из
ссылающейся таблицы в этих строках просто заменяют значения атрибутов, входящих
во внешний ключ, так называемыми *NULL*-значениями. Первичные ключи не могут
содержать NULL-значений.

*Транзакция* — одно из важнейших понятий теории баз данных. Она означает набор
операций над базой данных, рассматриваемых как единая и неделимая единица
работы, выполняемая полностью или не выполняемая вовсе, если произошел какойто
сбой в процессе выполнения транзакции. Таким образом, транзакции являются
*средством обеспечения согласованности данных*.
** Что такое язык SQL
Язык SQL — это непроцедурный язык, который является стандартным средством работы
с данными во всех реляционных СУБД. *Операторы* (*команды*), написанные на этом
языке, лишь указывают СУБД, какой результат должен быть получен, но не описывают
процедуру получения этого результата. СУБД сама определяет способ выполнения
команды пользователя. В языке SQL традиционно выделяются группа операторов
определения данных (*Data Definition Language* — *DDL*), группа операторов
манипулирования данными (*Data Manipulation Language* — *DML*) и группа
операторов, управляющих привилегиями доступа к объектам базы данных (*Data
Control Language* — *DCL*).
* Основные операции с таблицами
Для создания таблиц в языке SQL служит команда ~CREATE TABLE~. Итак, команда для
создания нашей первой таблицы ~aircrafts~ такова:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  CREATE TABLE aircrafts(
    aircraft_code char(3) NOT NULL,
    model text NOT NULL,
    range integer NOT NULL,
    CHECK (range > 0),
    PRIMARY KEY (aircraft_code)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Значения всех атрибутов каждой строки данной таблицы должны быть определенными,
поэтому на них накладывается ограничение ~NOT NULL~. В принципе в таблицах базы
данных могут содержаться неопределенные значения некоторых атрибутов. Говоря
другими словами, их значения могут отсутствовать. В таких случаях в этих полях
содержится специальное значение ~NULL~.

К томуже атрибут ~range~ не должен принимать отрицательных значений и нулевого
значения, поэтому приходится добавить еще одно ограничение: ~range > 0~.

В качестве первичного ключа выбран атрибут ~aircraft_code~. Таким образом,
первичный ключ будет, как говорят, *естественным*. Это означает, что и в
реальной предметной области существует такое понятие, как код самолета, и это
понятие используется на практике. В отличие от естественных ключей иногда
используются и так называемые *суррогатные ключи*.

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d aircrafts
#+END_SRC

#+RESULTS:
#+begin_example
                   Table "public.aircrafts"
    Column     |     Type     | Collation | Nullable | Default
---------------+--------------+-----------+----------+---------
 aircraft_code | character(3) |           | not null |
 model         | text         |           | not null |
 range         | integer      |           | not null |
Indexes:
    "aircrafts_pkey" PRIMARY KEY, btree (aircraft_code)
Check constraints:
    "aircrafts_range_check" CHECK (range > 0)
Referenced by:
    TABLE "flights" CONSTRAINT "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    TABLE "seats" CONSTRAINT "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Для в вода данных в таблицу служит команда ~INSERT~. Давайте добавим одну строку
в таблицу ~aircrafts~.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range) VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC elixir :eval no :exports both
  %Aircraft{
    aircraft_code: "SU9",
    model: "Sukhoi SuperJet-100",
    range: 3000
  }
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:40:54.810 [debug] QUERY OK db=13.8ms decode=0.5ms queue=0.3ms idle=1.5ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3) ["SU9", "Sukhoi SuperJet-100", 3000]
: >>> :
: {:ok,
:  %AirDB.Aircraft{
:    __meta__: #Ecto.Schema.Metadata<:loaded, "aircrafts">,
:    aircraft_code: "SU9",
:    model: "Sukhoi SuperJet-100",
:    range: 3000,
:    seats: #Ecto.Association.NotLoaded<association :seats is not loaded>
:  }}

Давайте добавим еще несколько строк в таблицу ~aircrafts~. Команда ~INSERT~
позволяет сделать это за один раз.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO aircrafts (aircraft_code, model, range)
    VALUES ('773', 'Boeing 777-300', 11100),
           ('763', 'Boeing 767-300', 7900),
           ('733', 'Boeing 737-300', 4200),
           ('320', 'Airbus A320-200', 5700),
           ('321', 'Airbus A321-200', 5600),
           ('319', 'Airbus A319-100', 6700),
           ('CN1', 'Cessna 208 Caravan', 1200),
           ('CR2', 'Bombardier CRJ-200', 2700);
#+END_SRC

#+RESULTS:
: INSERT 0 8

#+BEGIN_SRC elixir :exports both :eval no
  Repo.insert_all(Aircraft, [
    %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
    %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
    %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
    %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
    %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
    %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
    %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
    %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
  ])
#+END_SRC

#+RESULTS:
: 13:37:23.199 [debug] QUERY OK db=3.4ms queue=0.5ms idle=28.0ms
: INSERT INTO "aircrafts" ("aircraft_code","model","range") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18),($19,$20,$21),($22,$23,$24) ["773", "Boeing 777-300", 11100, "763", "Boeing 767-300", 7900, "733", "Boeing 737-300", 4200, "320", "Airbus A320-200", 5700, "321", "Airbus A321-200", 5600, "319", "Airbus A319-100", 6700, "CN1", "Cessna 208 Caravan", 1200, "CR2", "Bombardier CRJ-200", 2700]
: >>> : {8, nil}

Давайте посмотрим, что содержится в таблице ~aircrafts~. Для этого служит
команда ~SELECT~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           733 | Boeing 737-300      |  4200 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           319 | Airbus A319-100     |  6700 |
|           CN1 | Cessna 208 Caravan  |  1200 |
|           CR2 | Bombardier CRJ-200  |  2700 |

#+BEGIN_SRC elixir :exports both :eval no
  select(Aircraft, [a], map(a, ^Aircraft.__schema__(:fields)))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 15:10:47.010 [debug] QUERY OK source="aircrafts" db=0.2ms decode=0.5ms queue=0.3ms idle=7.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 []
: >>> :
: [
:   %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3000},
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
: ]

Давайте упорядочим строки по значению атрибута ~model~, а заодно изменим порядок
расположения столбцов в выводе информации.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range FROM aircrafts ORDER BY model;
#+END_SRC

#+RESULTS:
| model               | aircraft_code | range |
|---------------------+---------------+-------|
| Airbus A319-100     |           319 |  6700 |
| Airbus A320-200     |           320 |  5700 |
| Airbus A321-200     |           321 |  5600 |
| Boeing 737-300      |           733 |  4200 |
| Boeing 767-300      |           763 |  7900 |
| Boeing 777-300      |           773 | 11100 |
| Bombardier CRJ-200  |           CR2 |  2700 |
| Cessna 208 Caravan  |           CN1 |  1200 |
| Sukhoi SuperJet-100 |           SU9 |  3000 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    order_by: a.model,
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> order_by([a], asc: a.model)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.211 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.8ms idle=16.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."model" []
: >>> :
: [
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3000}
: ]

Множество выбираемых строк можно ограничить с помощью предложения ~WHERE~
команды ~SELECT~. Давайте выберем модели самолетов, у которых максимальная
дальность полета находитсяв пределах от 4 до 6 тыс. км включительно. Условие
выбора строк может быть составным. В данном случае нужно скомбинировать два
ограничения с помощью логической операции ~AND~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, aircraft_code, range
    FROM aircrafts
   WHERE range >= 4000 AND range <= 6000;
#+END_SRC

#+RESULTS:
| model           | aircraft_code | range |
|-----------------+---------------+-------|
| Boeing 737-300  |           733 |  4200 |
| Airbus A320-200 |           320 |  5700 |
| Airbus A321-200 |           321 |  5600 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.range >= 4000 and a.range <= 6000,
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], a.range >= 4000 and a.range <= 6000)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:42:28.212 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.4ms idle=18.1ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE ((a0."range" >= 4000) AND (a0."range" <= 6000)) []
: >>> :
: [
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600}
: ]

Команда ~UPDATE~ предназначенна для обновления данных в таблицах. Условие,
указываемое в команде, должно ограничить диапазон обновляемых строк. Если это
условие не задать, то будут обновлены все строки в таблице.

Давайте предположим, что российские инженеры немного улучшили летные
характеристики самолета /Sukhoi SuperJet/, и теперь дальность его полета стала
на 500 км больше.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = 3500 WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "SU9"

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "SU9")
  |> Repo.update_all(set: [range: 3500])
#+END_SRC

#+RESULTS:
: 13:42:28.219 [debug] QUERY OK source="aircrafts" db=5.5ms queue=0.5ms idle=19.7ms
: UPDATE "aircrafts" AS a0 SET "range" = $1 WHERE (a0."aircraft_code" = 'SU9') [3500]
: >>> : {1, nil}

Давайте проверим, что получилось в результате обновления данных.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi SuperJet-100 |  3500 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "SU9",
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "SU9")
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.one()
#+END_SRC

#+RESULTS:
: 13:42:28.221 [debug] QUERY OK source="aircrafts" db=0.4ms queue=0.6ms idle=26.8ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'SU9') []
: >>> : %{aircraft_code: "SU9", model: "Sukhoi SuperJet-100", range: 3500}

Для удаления строк из таблиц используется команда ~DELETE~, которая похожа на
команду ~SELECT~. Удалим какую-нибудь одну строку из таблицы ~aircrafts~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
: DELETE 1

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.aircraft_code == "CN1"

  # macro example
  Aircraft
  |> where([a], a.aircraft_code == "CN1")
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 13:42:28.226 [debug] QUERY OK source="aircrafts" db=4.2ms queue=0.4ms idle=28.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'CN1') []
: >>> : {1, nil}

Вы можете указать и какое-нибудь более сложное условие. Давайте, например,
удалим информацию о самолетах с дальностью полета более 10000 км, а также с
дальностью полета менее 3000 км:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE range > 10000 OR range < 3000;
#+END_SRC

#+RESULTS:
: DELETE 2

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from a in Aircraft,
    where: a.range > 10000 or a.range < 3000

  # macro example
  Aircraft
  |> where([a], a.range > 10000 or a.range < 3000)
  |> Repo.delete_all()
#+END_SRC

#+RESULTS:
: 14:03:41.612 [debug] QUERY OK source="aircrafts" db=4.5ms queue=0.5ms idle=39.0ms
: DELETE FROM "aircrafts" AS a0 WHERE ((a0."range" > 10000) OR (a0."range" < 3000)) []
: >>> : {2, nil}

При необходимости удаления всех строк из таблицы команда будет совсем простой:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts;
#+END_SRC

#+RESULTS:
: DELETE 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.delete_all(Aircraft)
#+END_SRC

#+RESULTS:
: 13:42:28.233 [debug] QUERY OK source="aircrafts" db=5.4ms queue=0.5ms idle=33.6ms
: DELETE FROM "aircrafts" AS a0 []
: >>> : {6, nil}

Теперь в таблице ~aircrafts~ нет ни одной строки.

Для таблицы ~aircrafts~ ближайшей «родственницей» является таблица ~seats~.

Значения атрибута ~fare_conditions~ могут выбираться из ограниченного списка
значений. Проверка на соответствие вводимых значений этому списку будет
обеспечиваться с помощью ограничения ~CHECK~.

В этой таблице используется *внешний ключ*. Предложение ~FOREIGN KEY~ создает
ограничение ссылочной целостности. В качестве внешнего ключа служит атрибут
~aircraft_code~. Он ссылается на одноименный атрибут в таблице ~aircrafts~.
Таблица ~seats~ называется *ссылающейся* (*referencing*), а таблица ~aircrafts~
— *ссылочной* (*referenced*).

Поскольку номера мест привязаны к модели самолета, то в случае удаления из
таблицы ~aircrafts~ какой-либо строки с конкретным кодом самолета необходимо
удалить также и из таблицы ~seats~ все строки, в которых значение атрибута
~aircraft_code~ такое же. Поэтому в предложении для определения внешнего ключа
появляется важное дополнение: ~ON DELETE CASCADE~. Это означает, что при
удалении какой-либо строки из таблицы ~aircrafts~ удаление строк из таблицы
~seats~, связанных с этой строкой по внешнему ключу, берет на себя СУБД,
избавляя программиста от этой заботы. Подобные действия, которые выполняет сама
СУБД, называются *каскадным удалением*. Таким образом, внешний ключ служит для
связи таблиц между собой.

Итак, команда для создания нашей второй таблицы ~seats~ такова:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  CREATE TABLE seats(
    aircraft_code char(3) NOT NULL,
    seat_no varchar(4) NOT NULL,
    fare_conditions varchar(10) NOT NULL,
    CHECK (fare_conditions IN ('Economy', 'Comfort', 'Business')),
    PRIMARY KEY (aircraft_code, seat_no),
    FOREIGN KEY (aircraft_code) REFERENCES aircrafts (aircraft_code) ON DELETE CASCADE
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Проверим таблицу, которую создала СУБД:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
\a
\d seats
#+END_SRC

#+RESULTS:
#+begin_example
                           Table "public.seats"
     Column      |         Type          | Collation | Nullable | Default
-----------------+-----------------------+-----------+----------+---------
 aircraft_code   | character(3)          |           | not null |
 seat_no         | character varying(4)  |           | not null |
 fare_conditions | character varying(10) |           | not null |
Indexes:
    "seats_pkey" PRIMARY KEY, btree (aircraft_code, seat_no)
Check constraints:
    "seats_fare_conditions_check" CHECK (fare_conditions::text = ANY (ARRAY['Economy'::text, 'Comfort'::text, 'Business'::text]))
Foreign-key constraints:
    "seats_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code) ON DELETE CASCADE

#+end_example

Принципиально новым по сравнению с рассмотренной выше таблицей ~aircrafts~
является наличие ограничения внешнего ключа. Это ограничение имеет имя
~seats_aircraft_code_fkey~, сгенерированное самой СУБД. Давайте сразу же
проделаем эксперимент, позволяющий показать работу внешнего ключа. Выполните
следующую команду для ввода данных в таблицу ~seats~:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES ('123', '1A', 'Business');
#+END_SRC

#+RESULTS:
: ERROR:  insert or update on table "seats" violates foreign key constraint "seats_aircraft_code_fkey"
: DETAIL:  Key (aircraft_code)=(123) is not present in table "aircrafts".

#+BEGIN_SRC elixir :eval no :exports both
  Seat.changeset(%Seat{}, %{
    aircraft_code: "123",
    seat_no: "1A",
    fare_conditions: "Business"
  })
  |> Repo.insert()
#+END_SRC

#+RESULTS:
: 14:28:52.511 [debug] QUERY ERROR db=2.7ms queue=9.1ms idle=0.0ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3) ["123", "Business", "1A"]
: >>> :
: {:error,
:  #Ecto.Changeset<
:    action: :insert,
:    changes: %{aircraft_code: "123", fare_conditions: "Business", seat_no: "1A"},
:    errors: [
:      aircraft_code: {"does not exist",
:       [constraint: :foreign, constraint_name: "seats_aircraft_code_fkey"]}
:    ],
:    data: #AirDB.Seat<>,
:    valid?: false
:  >}

Теперь нужно заполнить данными таблицу ~seats~.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO seats VALUES
    ('SU9', '1A', 'Business'),
    ('SU9', '1B', 'Business'),
    ('SU9', '10A', 'Economy'),
    ('SU9', '10B', 'Economy'),
    ('SU9', '10F', 'Economy'),
    ('SU9', '20F', 'Economy');

  INSERT INTO seats VALUES
    ('773', '1A', 'Business'),
    ('773', '1B', 'Business'),
    ('773', '10A', 'Economy'),
    ('773', '10B', 'Economy'),
    ('773', '10F', 'Economy'),
    ('773', '20F', 'Economy');
#+END_SRC

#+RESULTS:
: INSERT 0 6
: INSERT 0 6

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "SU9", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "SU9", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "SU9", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.521 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["SU9", "Business", "1A", "SU9", "Business", "2B", "SU9", "Economy", "10A", "SU9", "Economy", "10B", "SU9", "Economy", "10F", "SU9", "Economy", "20F"]
: >>> : {6, nil}

#+BEGIN_SRC elixir :eval no :exports both
  Repo.insert_all(Seat, [
    %{aircraft_code: "773", seat_no: "1A", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "2B", fare_conditions: "Business"},
    %{aircraft_code: "773", seat_no: "10A", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10B", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "10F", fare_conditions: "Economy"},
    %{aircraft_code: "773", seat_no: "20F", fare_conditions: "Economy"}
  ])
#+END_SRC

#+RESULTS:
: 14:28:52.601 [debug] QUERY OK db=4.5ms queue=0.6ms idle=11.6ms
: INSERT INTO "seats" ("aircraft_code","fare_conditions","seat_no") VALUES ($1,$2,$3),($4,$5,$6),($7,$8,$9),($10,$11,$12),($13,$14,$15),($16,$17,$18) ["773", "Business", "1A", "773", "Business", "2B", "773", "Economy", "10A", "773", "Economy", "10B", "773", "Economy", "10F", "773", "Economy", "20F"]
: >>> : {6, nil}

Теперь решим еще одну задачу. Предположим, что нам нужно получить информацию о
количестве мест в салонах для всех типов самолетов. Конечно, для решения задачи,
поставленной выше, в принципе можно воспользоваться такими командами:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    where: s.aircraft_code == "SU9"

  # macro example
  Seat
  |> where([s], s.aircraft_code == "SU9")
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 14:33:18.421 [debug] QUERY OK source="seats" db=0.3ms decode=0.4ms queue=0.5ms idle=3.0ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'SU9') []
: >>> : 6

И похожими для всех остальных самолетов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM seats
   WHERE aircraft_code = 'CN1';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    where: s.aircraft_code == "CN1"

  # macro example
  Seat
  |> where([s], s.aircraft_code == "CN1")
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 14:33:18.427 [debug] QUERY OK source="seats" db=0.5ms queue=0.7ms idle=13.5ms
: SELECT count(*) FROM "seats" AS s0 WHERE (s0."aircraft_code" = 'CN1') []
: >>> : 0

Очевидно, что это нерациональный подход. Язык SQL позволяет упростить решение
такой задачи за счет применения операции группирования строк на основе
некоторого критерия. В модифицированной команде вместо предложения ~WHERE~ будет
добавлено предложение ~GROUP BY~, которое отвечает за группировку строк с
одинаковыми значениями атрибута ~aircraft_code~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |
| 773           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: s.aircraft_code,
    select: %{aircraft_code: s.aircraft_code, count: count()}

  # macro example
  Seat
  |> group_by([s], s.aircraft_code)
  |> select([s], %{aircraft_code: s.aircraft_code, count: count()})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.428 [debug] QUERY OK source="seats" db=0.4ms queue=0.5ms idle=14.9ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" []
: >>> : [%{aircraft_code: "SU9", count: 6}]

Если мы захотим отсортировать выборку по числу мест в самолетах, то нужно будет
дополнить команду предложением ~ORDER BY~, которое обеспечит сортировку
результирующих строк по значениям второго столбца.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         count(*)
    FROM seats
   GROUP BY aircraft_code
   ORDER BY count;
#+END_SRC

#+RESULTS:
| aircraft_code | count |
|---------------+-------|
| SU9           |     6 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: s.aircraft_code,
    order_by: selected_as(:count),
    select: %{aircraft_code: s.aircraft_code, count: selected_as(count(), :count)}

  # macro example
  Seat
  |> group_by([s], s.aircraft_code)
  |> order_by(selected_as(:count))
  |> select([s], %{aircraft_code: s.aircraft_code, count: selected_as(count(), :count)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.429 [debug] QUERY OK source="seats" db=0.4ms queue=0.6ms idle=16.1ms
: SELECT s0."aircraft_code", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code" ORDER BY count []
: >>> : [%{aircraft_code: "SU9", count: 6}]

Теперь поставим более сложную задачу: подсчитать количество мест в салонах для
всех моделей самолетов, но теперь уже с учетом класса обслуживания (бизнес-класс
и экономический класс). В этом случае группировка выполняется уже по двум
атрибутам: ~aircraft_code~ и ~fare_conditions~. Отсортируем выборку по тем же
столбцам, по которым выполняли группировку.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aircraft_code,
         fare_conditions,
         count(*)
    FROM seats
   GROUP BY aircraft_code, fare_conditions
   ORDER BY aircraft_code, fare_conditions;
#+END_SRC

#+RESULTS:
| aircraft_code | fare_conditions | count |
|---------------+-----------------+-------|
| SU9           | Business        |     2 |
| SU9           | Economy         |     4 |

#+BEGIN_SRC elixir :eval no :exports both
  # keyword example
  from s in Seat,
    group_by: [s.aircraft_code, s.fare_conditions],
    order_by: [s.aircraft_code, s.fare_conditions],
    select: %{aircraft_code: s.aircraft_code, fare_condition: s.fare_conditions, count: count()}

  # macro example
  Seat
  |> group_by([s], [s.aircraft_code, s.fare_conditions])
  |> order_by([s], [s.aircraft_code, s.fare_conditions])
  |> select([s], %{
    aircraft_code: s.aircraft_code,
    fare_condition: s.fare_conditions,
    count: count()
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 14:33:18.431 [debug] QUERY OK source="seats" db=0.4ms queue=0.8ms idle=17.5ms
: SELECT s0."aircraft_code", s0."fare_conditions", count(*) FROM "seats" AS s0 GROUP BY s0."aircraft_code", s0."fare_conditions" ORDER BY s0."aircraft_code", s0."fare_conditions" []
: >>> :
: [
:   %{aircraft_code: "SU9", count: 2, fare_condition: "Business"},
:   %{aircraft_code: "SU9", count: 4, fare_condiiton: "Economy"}
: ]
** Контрольные вопросы и задания
*** Вопрос 1
Попробуйте ввести в таблицу ~aircrafts~ строку с таким значением атрибута «Код
самолета» (~aircraft_code~), которое вы уже вводили, например:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO aircrafts VALUES ('SU9', 'Sukhoi SuperJet-100', 3000);
#+END_SRC

Вы получите сообщение об ошибке:

#+RESULTS:
: ERROR:  duplicate key value violates unique constraint "aircrafts_pkey"
: DETAIL:  Key (aircraft_code)=(SU9) already exists.

Обратите внимание, что в этой команде мы не привели список атрибутов, что вполне
допустимо при задании значений атрибутов в том же порядке, в котором атрибуты
следуют в определении таблицы. Но в ваших прикладных программах так поступать
все же не следует, поскольку в случае возможной реструктуризации таблицы и
изменения порядка следования атрибутов в ней ваши команды ~INSERT~ могут
перестать работать корректно.

Подумайте, почему появилось сообщение. Если вы забыли структуру таблицы
~aircrafts~, то можно вывести ее определение на экран с помощью команды ~\d
aircrafts~.

*ОТВЕТ*: Нарушен констрейнт - ~Key (aircraft_code)=(SU9) already exists~.
*** Вопрос 2
Предложение ~ORDER BY~ команды ~SELECT~ позволяет отсортировать данные при
выводе. По умолчанию сортировка выполняется по возрастанию значений атрибута,
указанного в этом предложении. Но можно упорядочить строки и по убыванию
значения атрибута. Для этого нужно после имени атрибута в предложении ~ORDER BY~
добавить ключевое слово ~DESC~ (это сокращение от слова /descendant/ — убывающий
порядок). Самостоятельно напишите команду для выборки всех строк из таблицы
~aircrafts~, чтобы строки были упорядочены по убыванию значения атрибута
«Максимальная дальность полета, км» (~range~).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts ORDER BY range DESC;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           319 | Airbus A319-100     |  6700 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           733 | Boeing 737-300      |  4200 |
|           SU9 | Sukhoi SuperJet-100 |  3000 |
|           CR2 | Bombardier CRJ-200  |  2700 |
|           CN1 | Cessna 208 Caravan  |  1200 |

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      order_by: [desc: a.range],
      select: map(a, [:aircraft_code, :model, :range])

  Repo.all(query)
#+END_SRC

#+RESULTS:
: 16:37:27.091 [debug] QUERY OK source="aircrafts" db=0.3ms queue=0.4ms idle=1772.2ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."range" DESC []
: >>> :
: [
  : %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
  : %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
  : %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
  : %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
  : %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
  : %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
  : %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
  : %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
  : %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200}
: ]
*** Вопрос 3
Команда ~UPDATE~ позволяет в процессе обновления выполнять арифметические
действия над значениями, находящимися в строках таблицы. Представим себе, что
двигатели самолета /Sukhoi SuperJet/ стали в два раза экономичнее, вследствие
чего дальность полета этого лайнера возросла ровно в два раза. Команда ~UPDATE~
позволяет увеличить значение атрибута ~range~ в строке, хранящей информацию об
этом самолете, даже не выполняя предварительно выборку с целью выяснения
текущего значения этого атрибута. При присваивании нового значения атрибуту
~range~ можно справа от знака ~=~ написать не только числовую константу, но и
целое выражение. В нашем случае оно будет простым: ~range = range * 2~.
Самостоятельно напишите команду ~UPDATE~ полностью, при этом не забудьте, что
увеличить дальность полета нужно только у одной модели — /Sukhoi SuperJet/,
поэтому необходимо использовать условие ~WHERE~. Затем с помощью команды
~SELECT~ проверьте полученный результат.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  UPDATE aircrafts SET range = range * 2 WHERE aircraft_code = 'SU9';
  SELECT range FROM aircrafts WHERE aircraft_code = 'SU9';
#+END_SRC

#+RESULTS:
: UPDATE 1
: range
: 6000

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      where: a.aircraft_code == "SU9",
      update: [set: [range: fragment("range * 2")]]

  Repo.update_all(query, [])
#+END_SRC

#+RESULTS:
: 16:41:34.417 [debug] QUERY OK source="aircrafts" db=0.2ms queue=0.2ms idle=1098.1ms
: UPDATE "aircrafts" AS a0 SET "range" = range * 2 WHERE (a0."aircraft_code" = 'SU9') []
: >>> : {0, nil}
*** Вопрос 4
Если в предложении ~WHERE~ команды ~DELETE~ вы укажете логически и синтаксически
корректное условие, но строк, удовлетворяющих этому условию, в таблице не
окажется, то в ответ СУБД выведет сообщение ~DELETE 0~.

Такая ситуация не является ошибкой или сбоем в работе СУБД. Например, если после
удаления какой-то строки вы повторно попытаетесь удалить ее же, то получите
именно такое сообщение. Самостоятельно смоделируйте описанную ситуацию, подобрав
условие, которому гарантированно не соответствует ни одна строка в таблице
«Самолеты» (~aircrafts~).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  DELETE FROM aircrafts WHERE aircraft_code = 'XXX';
#+END_SRC

#+RESULTS:
: DELETE 0

#+BEGIN_SRC elixir :exports both :eval no
  query =
    from a in Aircraft,
      where: a.aircraft_code == "XXX"

  Repo.delete_all(query)
#+END_SRC

#+RESULTS:
: 16:49:32.082 [debug] QUERY OK source="aircrafts" db=0.4ms idle=1764.0ms
: DELETE FROM "aircrafts" AS a0 WHERE (a0."aircraft_code" = 'XXX') []
: >>> : {0, nil}
* Типы данных СУБД PostgreSQL
** Числовые типы
Группа числовых типов данных включает в себя целый ряд разновидностей:
целочисленные типы, числа фиксированной точности, типы данных с плавающей
точкой, последовательные типы (~serial~).

В составе целочисленных типов находятся следующие представители: ~smallint~,
~integer~, ~bigint~. Если атрибут таблицы имеет один из этих типов, то он
позволяет хранить только целочисленные данные. При этом перечисленные типы
различаются по количеству байтов, выделяемых для хранения данных. В PostgreSQL
существуют псевдонимы для этих стандартизированных имен типов, а именно: ~int2~,
~int4~ и ~int8~. Число байтов отражается в имени типа.

Числа фиксированной точности представлены двумя типами — ~numeric~ и ~decimal~.
Однако они являются идентичными по своим возможностям. Числа типа ~numeric~
могут хранить очень большое количество цифр: 131072 цифры — до десятичной точки
(запятой), 16383 — после точки. Его главное достоинство — это обеспечение
/точных/ результатов при выполнении вычислений, когда это, конечно, возможно в
принципе. Для задания значения этого типа используются два базовых понятия:
*масштаб* (*scale*) и *точность* (*precision*). Масштаб показывает число
значащих цифр, стоящих справа от десятичной точки (запятой). Точность указывает
общее число цифр как до десятичной точки, так и после нее. Параметры этого типа
данных указываются в круглых скобках после имени типа: ~numeric(точность,
масштаб)~.

Представителями типов данных с плавающей точкой являются типы ~real~ и ~double
precision~. Они представляют собой реализацию стандарта IEEE «Standard 754 for
Binary Floating-Point Arithmetic». Тип данных ~real~ может представить числа в
диапазоне, как минимум, от 1E−37 до 1E+37 с точностью не меньше 6 десятичных
цифр. Тип ~double precision~ имеет диапазон значений примерно от 1E−307 до
1E+308 с точностью не меньше 15 десятичных цифр.

При попытке записать в такой столбец слишком большое или слишком маленькое
значение будет генерироваться ошибка. Если точность вводимого числа выше
допустимой, то будет иметь место округление значения. А вот при вводе очень
маленьких чисел, которые невозможно представить значениями, отличными от нуля,
будет генерироваться *ошибка потери значимости*, или исчезновения значащих
разрядов (*an underflow error*).

При работе с числами таких типов нужно помнить, что сравнение двух чисел с
плавающей точкой на предмет равенства их значений может привести к неожиданным
результатам:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 0.1::real * 10 = 1.0::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| f        |

В дополнение к обычным числам эти типы данных поддерживают и специальные
значения ~Infinity~ (бесконечность), ~−Infinity~ (отрицательная бесконечность) и
~NaN~ (нечисло).

PostgreSQL поддерживает также тип данных ~float~, определенный в стандарте SQL.
В объявлении типа может использоваться параметр: ~float(p)~. Если его значение
лежит в диапазоне от 1 до 24, то это будет равносильно использованию типа
~real~, а если же значение лежит в диапазоне от 25 до 53, то это будет
равносильно использованию типа ~double precision~. Если же при объявлении типа
параметр не используется, то это также будет равносильно использованию типа
~double precision~.

Последним из числовых типов является тип ~serial~. Однако он фактически
реализован не как настоящий тип, а просто как удобная замена целой группы
SQL-команд. Тип ~serial~ удобен в тех случаях, когда требуется в какой-либо
столбец вставлять уникальные целые значения, например, значения суррогатного
первичного ключа. Кроме типа ~serial~ существуют еще два аналогичных типа:
~bigserial~ и ~smallserial~. Им фактически, за кадром, соответствуют типы
~bigint~ и ~smallint~.
** Символьные (строковые) типы
Стандартные представители строковых типов — это типы ~character varying(n)~ и
~character(n)~, где параметр указывает максимальное число символов в строке,
которую можно сохранить в столбце такого типа. При работе с многобайтовыми
кодировками символов, например UTF-8, нужно учитывать, что речь идет о символах,
а не о байтах. Если сохраняемая строка символов будет короче, чем указано в
определении типа, то значение типа ~character~ будет дополнено пробелами до
требуемой длины, а значение типа ~character varying~ будет сохранено так, как
есть. Типы ~character varying(n)~ и ~character(n)~ имеют псевдонимы ~varchar(n)~
и ~char(n)~ соответственно.

PostgreSQL дополнительно предлагает еще один символьный тип — ~text~. В столбец
этого типа можно ввести сколь угодно большое значение, конечно, в пределах,
установленных при компиляции исходных текстов СУБД.

Константы символьных типов в SQL-командах заключаются в одинарные кавычки. В том
случае, когда в константе содержится символ одинарной кавычки или обратной косой
черты, их необходимо удваивать.

В том случае, когда таких символов в константе много, все выражение становится
трудно воспринимать. На помощь может прийти использование удвоенного символа
«$». Эти символы выполняют ту же роль, что и одинарные кавычки, когда в них
заключается строковая константа. При использовании символов «$» в качестве
ограничителей уже не нужно удваивать никакие символы, содержащиеся в самой
константе: ни одинарные кавычки, ни символы обратной косой черты.

PostgreSQL предлагает еще одно расширение стандарта SQL — строковые константы в
стиле языка C. Чтобы иметь возможность их использовать, нужно перед начальной
одинарной кавычкой написать символ «E». При использовании C-стиля необходимо
удваивать обратную косую черту, если требуется поместить ее в константу
буквально. А для включения в содержимое константы символа обратной кавычки можно
либо удвоить ее, либо спрятать за обратной косой чертой.
** Типы «дата/время»
Даты обрабатываются в соответствии с григорианским календарем, причем это
делается даже в тех случаях, когда дата относится к тому моменту времени, когда
этот календарь в данной стране еще не был принят.

Начнем рассмотрение с типа ~date~. Рекомендуемый стандартом ISO 8601 формат
ввода дат таков: ~yyyy-mm-dd~, где символы ~y~, ~m~ и ~d~ обозначают цифру года,
месяца и дня соответственно. При выводе значений PostgreSQL использует формат по
умолчанию, если не предписан другой формат. По умолчанию используется формат,
рекомендуемый стандартом ISO 8601: ~yyyy-mm-dd~.

Для получения значения текущей даты служит функция ~current_date~. Ее
особенностью является то, что при ее вызове круглые скобки не используются.
Текущее время выводится с высокой точностью и дополняется числовым значением,
соответствующим локальному часовому поясу, который установлен в конфигурационном
файле сервера.

Если нам требуется вывести дату в другом формате, то для разового преобразования
формата можно использовать функцию ~to_char(date, 'dd-mm-yyyy');~

Для хранения времени суток служат два типа данных: ~time~ и ~time with time
zone~. Первый из них хранит только время суток, а второй — дополнительно — еще и
часовой пояс. Однако документация на PostgreSQL не рекомендует использовать тип
~time with time zone~, поскольку *смещение* (*offset*), соответствующее
конкретному часовому поясу, может зависеть от даты перехода на летнее время и
обратно, но в этом типе дата отсутствует. Время можно вводить не только в
24-часовом формате, но и в 12-часовом, при этом нужно использовать
дополнительные суффиксы ~am~ и ~pm~.

Для получения значения текущего времени служит функция ~current_time~. Она также
вызывается без указания круглых скобок.

В результате объединения типов даты и времени получается интегральный тип —
временная отметка. Этот тип существует в двух вариантах: с учетом часового пояса
— ~timestamp with time zone~, либо без учета часового пояса — ~timestamp~. Для
первого варианта существует сокращенное наименование — ~timestamptz~. Оба типа
занимают один и тот же объем 8 байтов, но значения типа ~timestamptz~ хранятся,
будучи приведенными к нулевому часовому поясу (UTC), а перед выводом приводятся
к часовому поясу пользователя.

Для получения значения текущей временной отметки (т.е. даты и времени в одном
значении) служит функция ~current_timestamp~. Она также вызывается без указания
круглых скобок.

Последним типом является ~interval~, который представляет продолжительность
отрезка времени между двумя моментами времени. Его формат ввода таков: ~quantity
unit [quantity unit ...] direction~. Можно использовать альтернативный формат,
предлагаемый стандартом ISO 8601: ~P [ years-months-days ] [ T hours:minutes:seconds ]~

Здесь ~unit~ означает единицу измерения, а ~quantity~ — количество таких единиц.
В качестве единиц измерения можно использовать следующие: ~microsecond~,
~millisecond~, ~second~, ~minute~, ~hour~, ~day~, ~week~, ~month~, ~year~,
~decade~, ~century~, ~millennium~. Параметр ~direction~ может принимать значение
~ago~ (т.е. «тому назад») либо быть пустым.

Поскольку интервал — это отрезок времени между двумя временными отметками, то
значение этого типа можно получить при вычитании одной временной отметки из
другой.

Значения временных отметок можно усекать с той или иной точностью с помощью
функции ~date_trunc(точность, время)~.

Из значений временных отметок можно с помощью функции ~extract(поле FROM время)~
извлекать отдельные поля, т.е. год, месяц, день, число часов, минут или секунд и
т.д
** Логический тип
Логический (~boolean~) тип может принимать три состояния: истина и ложь, а также
неопределенное состояние, которое можно представить значением ~NULL~. Таким
образом, тип ~boolean~ реализует трехзначную логику.

В качестве истинного состояния могут служить следующие значения: ~TRUE~, ~'t'~,
~'true'~, ~'y'~, ~'yes'~, ~'on'~, ~'1'~.

В качестве ложного состояния могут служить следующие значения: ~FALSE~, ~'f'~,
~'false'~, ~'n'~, ~'no'~, ~'off'~, ~'0'~.
** Массивы
*TODO* продублировать запросы используя Ecto

Массивы могут быть многомерными и могут содержать значения любого из встроенных
типов, а также типов данных, определенных пользователем. Массив в команде
вставки представленв виде строкового литерала с указанием типа данных и
квадратных скобок, означающих массив.

Предположим, что нам необходимо сформировать и сохранить в базе данных в удобной
форме графики работы пилотов авиакомпании, т.е. номера дней недели, когда они
совершают полеты.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE pilots (pilot_name text, schedule integer[]);
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots
         VALUES ('Ivan',  '{1, 3, 5, 6, 7}'::integer[]),
                ('Petr',  '{1, 2, 5, 7}'::integer[]),
                ('Pavel', '{2, 5}'::integer[]),
                ('Boris', '{3, 5, 6}'::integer[]);
#+END_SRC

#+RESULTS:
: INSERT 0 4

Предположим, что руководство компании решило, что каждый пилот должен летать 4
раза в неделю. Значит, нам придется обновить значения в таблице. Пилоту по имени
Boris добавим один день с помощью операции конкатенации ~||~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = schedule || 7
   WHERE pilot_name ='Boris';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {2,5,6}     |
| Petr       | {1,2,5,7}   |

Пилоту по имени Pavel добавим один день в конец списка (массива) с помощью
функции ~array_append~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_append(schedule, 6)
   WHERE pilot_name ='Pavel';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {2,5,6}     |
| Petr       | {1,2,5,7}   |

Ему же добавим один день в начало списка с помощью функции ~array_prepend~
(обратите внимание, что параметры функции поменялись местами):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_prepend(1, schedule)
   WHERE pilot_name = 'Pavel';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    |
|------------+-------------|
| Boris      | {3,5,6,7}   |
| Ivan       | {1,3,5,6,7} |
| Pavel      | {1,2,5,6}   |
| Petr       | {1,2,5,7}   |

У пилота по имени Ivan имеется лишний день в графике. С помощью функции
~array_remove~ удалим из графика пятницу (второй параметр функции указывает
значение элемента массива, а не индекс):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule = array_remove(schedule, 5)
   WHERE pilot_name = 'Ivan';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {1,2,5,7} |

У пилота по имени Petr изменим дни полетов, не изменяя их общего количества.
Воспользуемся индексами для работы на уровне отдельных элементов массива. По
умолчанию нумерация индексов начинается *с единицы*, а не с нуля. При
необходимости ее можно изменить. К элементам одного и того же массива можно
обращаться в предложении ~SET~ по отдельности, как будто это разные столбцы.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule[1] = 2,
         schedule[2] = 3
   WHERE pilot_name = 'Petr';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

А можно было бы, используя *срез* (*slice*) массива, сделать и так:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  UPDATE pilots
     SET schedule[1:2] = ARRAY[2, 3]
   WHERE pilot_name = 'Petr';

  SELECT * FROM pilots ORDER BY pilot_name;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

Теперь продемонстрируем основные операции, которые можно применять к массивам,
выполняя выборки из таблиц.

Функция ~array_position~ возвращает индекс первого вхождения элемента с
указанным значением в массив. Если же такого элемента нет, она возвратит ~NULL~.
Получим список пилотов, летающих по средам:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE array_position(schedule, 3) IS NOT NULL;
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Ivan       | {1,3,6,7} |
| Petr       | {2,3,5,7} |

Оператор ~@>~ означает проверку того факта, что в левом массиве содержатся все
элементы правого массива. Конечно, при этом в левом массиве могут находиться и
другие элементы. Выберем пилотов, летающих по понедельникам и воскресеньям:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE schedule @> '{1, 7}'::integer[];
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Ivan       | {1,3,6,7} |

Еще аналогичный вопрос: кто летает по вторникам и/или по пятницам? Для получения
ответа воспользуемся оператором ~&&~, который проверяет наличие общих элементов
у массивов, т.е. пересекаются ли их множества значений.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE schedule && ARRAY[2, 5];
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Boris      | {3,5,6,7} |
| Pavel      | {1,2,5,6} |
| Petr       | {2,3,5,7} |

Сформулируем вопрос в форме отрицания: кто не летает ни во вторник, ни в
пятницу?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilots
   WHERE NOT (schedule && ARRAY[2, 5]);
#+END_SRC

#+RESULTS:
| pilot_name | schedule  |
|------------+-----------|
| Ivan       | {1,3,6,7} |

Иногда требуется развернуть массив в виде столбца таблицы. В таком случае
поможет функция ~unnest~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT unnest(schedule) AS days_of_week
    FROM pilots
   WHERE pilot_name = 'Ivan';
#+END_SRC

#+RESULTS:
| days_of_week |
|--------------|
|            1 |
|            3 |
|            6 |
|            7 |
** Типы JSON
*TODO* продублировать запросы используя Ecto

Типы JSON предназначены для сохранения в столбцах таблиц базы данных таких
значений, которые представлены в формате /JSON/ (JavaScript Object Notation).
Существует два типа: ~json~ и ~jsonb~. Основное различие между ними заключается
в быстродействии. Если столбец имеет тип ~json~, тогда сохранение значений
происходит быстрее, потому что они записываются в том виде, в котором были
введены. Но при последующем использовании этих значений в качестве операндов или
параметров функций будет каждый раз выполняться их разбор, что замедляет работу.
При использовании типа ~jsonb~ разбор производится однократно, при записи
значения в таблицу. Это несколько замедляет операции вставки строк, в которых
содержатся значения данного типа. Но все последующие обращения к сохраненным
значениям выполняются быстрее, т.к. выполнять их разбор уже не требуется.

Есть еще ряд отличий, в частности, тип ~json~ сохраняет порядок следования
ключей в объектах и повторяющиеся значения ключей, а тип ~jsonb~ этого не
делает. Рекомендуется в приложениях использовать тип ~jsonb~, если только нет
какихто особых аргументов в пользу выбора типа ~json~.

Для иллюстрации использования типов JSON обратимся к тематике авиаперевозок.
Разработчики базы данных авиакомпании получили задание создать специальную
таблицу, в которую будут заноситься сведения о тех видах спорта, которыми
занимается пилот, будет отмечаться наличие у него домашней библиотеки, а также
фиксироваться количество стран, которые он посетил в ходе туристических поездок.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE pilot_hobbies(pilot_name text, hobbies jsonb);
  INSERT INTO pilot_hobbies
    VALUES ('Ivan',  '{"sports": ["футбол", "плавание"], "home_lib": true, "trips": 3}'::jsonb),
           ('Petr',  '{"sports": ["теннис", "плавание"],"home_lib": true, "trips": 2}'::jsonb),
           ('Pavel', '{"sports": ["плавание"], "home_lib": false, "trips": 4}'::jsonb),
           ('Boris', '{"sports": ["футбол", "плавание", "теннис"],"home_lib": true, "trips": 0}'::jsonb);
#+END_SRC

#+RESULTS:
: CREATE TABLE
: INSERT 0 4

Предположим, что нужно сформировать футбольную сборную команду нашей
авиакомпании для участия в турнире. Мы можем выбрать всех футболистов таким
способом:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM pilot_hobbies
   WHERE hobbies @> '{"sports": ["футбол"]}'::jsonb;
#+END_SRC

#+RESULTS:
| pilot_name | hobbies                                                                    |
|------------+----------------------------------------------------------------------------|
| Ivan       | {"trips": 3, "sports": ["футбол", "плавание"], "home_lib": true}           |
| Boris      | {"trips": 0, "sports": ["футбол", "плавание", "теннис"], "home_lib": true} |

Можно было эту задачу решить и таким способом. Операция ~->~ служит для
обращения к конкретному ключу JSON-объекта. В этом решении мы выводим только
информацию о спортивных предпочтениях пилотов:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies -> 'sports' AS sports
    FROM pilot_hobbies
   WHERE hobbies->'sports' @> '["футбол"]'::jsonb;
#+END_SRC

#+RESULTS:
| pilot_name | sports                           |
|------------+----------------------------------|
| Ivan       | ["футбол", "плавание"]           |
| Boris      | ["футбол", "плавание", "теннис"] |

Как можно проверить наличие ключа? Продемонстрируем это:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM pilot_hobbies
   WHERE hobbies ? 'sport';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

А вот ключ ~sports~ присутствует. Выполним ту же проверку:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM pilot_hobbies
   WHERE hobbies ? 'sports';
#+END_SRC

#+RESULTS:
| count |
|-------|
|     4 |

А как выполнять обновление JSON-объектов в строках таблицы? Предположим, что
пилот по имени Boris решил посвятить себя только хоккею. Тогда в базе данных мы
выполним такую операцию:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = hobbies || '{"sports": ["хоккей"]}'
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports results :eval no
  SELECT pilot_name, hobbies
    FROM pilot_hobbies
   WHERE pilot_name = 'Boris';
#+END_SRC

Проверим, что получилось:

#+RESULTS:
| pilot_name | hobbies                                              |
|------------+------------------------------------------------------|
| Boris      | {"trips": 0, "sports": ["хоккей"], "home_lib": true} |

Если впоследствии Boris захочет возобновить занятия футболом, то с помощью
функции ~jsonb_set~ можно будет обновить сведения о нем в таблице:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{sports, 1}', '"футбол"')
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
: UPDATE 1

Второй параметр функции указывает путь в пределах JSON-объекта, куда нужно
добавить новое значение. В данном случае этот путь состоит из имени ключа
(~sports~) и номера добавляемого элемента в массиве видов спорта (номер 1).
Нумерация элементов начинается с нуля. Третий параметр имеет тип ~jsonb~,
поэтому его литерал заключается в одинарные кавычки, а само добавляемое значение
берется в двойные кавычки. В результате получается — ~'"футбол"'~.

Проверим успешность выполнения этой операции:

#+BEGIN_SRC sql :engine postgres :exports results :eval no
  SELECT pilot_name, hobbies
    FROM pilot_hobbies
   WHERE pilot_name = 'Boris';
#+END_SRC

#+RESULTS:
| pilot_name | hobbies                                                        |
|------------+----------------------------------------------------------------|
| Boris      | {"trips": 0, "sports": ["хоккей", "футбол"], "home_lib": true} |
** Контрольные вопросы и задания
*** Вопрос 1
Создайте таблицу, содержащую атрибут типа ~numeric(precision, scale)~. Пусть это
будет таблица, содержащая результаты каких-то измерений. Команда может быть,
например, такой:

src_sql[:exports code]{CREATE TABLE test_numeric(measurement numeric(5, 2),
description text);}

Попробуйте с помощью команды ~INSERT~ продемонстрировать округление вводимого
числа до той точности, которая задана при создании таблицы. Подумайте, какая из
следующих команд вызовет ошибку и почему? Проверьтесвои предположения, выполнив
эти команды.
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9999,
  'Какое-то измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9009, 'Еще
  одно измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.1111, 'И еще
  измерение');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (998.9999, 'И еще
  одно');}

Продемонстрируйте генерирование ошибки при попытке ввода числа, количество цифр
в котором слева от десятичной точки (запятой) превышает допустимое.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP table test_numeric;
  CREATE TABLE test_numeric(measurement numeric(5, 2), description text);
  -- INSERT INTO test_numeric VALUES (999.9999, 'Какое-то измерение');
  INSERT INTO test_numeric VALUES (999.9009, 'Еще одно измерение');
  INSERT INTO test_numeric VALUES (999.1111, 'И еще измерение');
  INSERT INTO test_numeric VALUES (998.9999, 'И еще одно');
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_numeric;
#+END_SRC

#+RESULTS:
| measurement | description        |
|-------------+--------------------|
|      999.90 | Еще одно измерение |
|      999.11 | И еще измерение    |
|      999.00 | И еще одно         |

src_sql[:exports code]{INSERT INTO test_numeric VALUES (999.9999, 'Какое-то
 измерение');} вызывает переполнение типа:

: ERROR:  numeric field overflow
: DETAIL:  A field with precision 5, scale 2 must round to an absolute value less than 10^3.
*** Вопрос 2
Предположим, что возникла необходимость хранить в одном столбце таблицы данные,
представленные с различной точностью. Это могут быть, например, результаты
физических измерений разнородных показателей или различные медицинские
показатели здоровья пациентов (результаты анализов). В таком случае можно
использовать тип ~numeric~ без указания масштаба и точности.

Команда для создания таблицы может быть, например, такой:

src_sql[:exports code]{CREATE TABLE test_numeric(measurement numeric,
description text);}

Если у вас в базе данных уже есть таблица с таким же именем, то можно
предварительно ее удалить с помощью команды:

src_sql[:exports code]{DROP TABLE test_numeric;}

Вставьте в таблицу несколько строк:
- src_sql[:exports code]{INSERT INTO test_numeric VALUES
  (1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (1.5, 'Точность 2
  знака, масштаб 1 знак');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES
  (0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков');}
- src_sql[:exports code]{INSERT INTO test_numeric VALUES (1234567890,
  'Точность 10 знаков, масштаб 0 знаков (целое число)');}

Теперь сделайте выборку из таблицы и посмотрите, что все эти
разнообразныезначения сохранены именно в том виде, как вы их вводили.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP table test_numeric;
  CREATE TABLE test_numeric(measurement numeric, description text);
  INSERT INTO test_numeric VALUES (1234567890.0987654321, 'Точность 20 знаков, масштаб 10 знаков');
  INSERT INTO test_numeric VALUES (1.5, 'Точность 2 знака, масштаб 1 знак');
  INSERT INTO test_numeric VALUES (0.12345678901234567890, 'Точность 21 знак, масштаб 20 знаков');
  INSERT INTO test_numeric VALUES (1234567890, 'Точность 10 знаков, масштаб 0 знаков (целое число)');
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_numeric;
#+END_SRC

#+RESULTS:
|            measurement | description                                        |
|------------------------+----------------------------------------------------|
|  1234567890.0987654321 | Точность 20 знаков, масштаб 10 знаков              |
|                    1.5 | Точность 2 знака, масштаб 1 знак                   |
| 0.12345678901234567890 | Точность 21 знак, масштаб 20 знаков                |
|             1234567890 | Точность 10 знаков, масштаб 0 знаков (целое число) |
*** Вопрос 3
Тип данных ~numeric~ поддерживает специальное значение ~NaN~, которое означает
/not a number/. В документации утверждается, что значение ~NaN~ считается равным
другому значению ~NaN~, а также что значение ~NaN~ считается большим любого
другого «нормального» значения, т.е. ~не-NaN~. Проверьте эти утверждения с
помощью SQL-команды ~SELECT~. В качестве примера приведем команду:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric > 10000;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric = 'NaN'::numeric;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::numeric > 10^99999::numeric;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 4
При работе с числами типов ~real~ и ~double precision~ нужно помнить, что
сравнение двух чисел с плавающей точкой на предмет равенства их значений может
привести к неожиданным результатам. Например, сравним два очень маленьких числа
(они представлены в экспоненциальной форме записи):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '5e-324'::double precision > '4e-324'::double precision;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| f        |

Чтобы понять, почему так получается, выполните еще запрос:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '5e-324'::double precision, '4e-324'::double precision;
#+END_SRC

#+RESULTS:
| float8 | float8 |
|--------+--------|
| 5e-324 | 5e-324 |

Самостоятельно проведите аналогичные эксперименты с очень большими числами,
находящимися на границе допустимого диапазона для чисел типов ~real~ и ~double
precision~.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '1e+308'::double precision, '1.79e+308'::double precision;
#+END_SRC

#+RESULTS:
| float8 |    float8 |
|--------+-----------|
| 1e+308 | 1.79e+308 |
*** Вопрос 5
Типы данных ~real~ и ~double precision~ поддерживают специальные значения
~Infinity~ (бесконечность) и ~−Infinity~ (отрицательная бесконечность).
Проверьте с помощью SQL-команды ~SELECT~ ожидаемые свойства этих значений.
Например, сравните ~Infinity~ с наибольшим значением, которое допускается для
типа ~double precision~ (можно использовать сокращенное написание ~Inf~):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'Inf'::double precision > 1e+308;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '-Inf'::double precision < '5e-324'::double precision;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 6
Типы данных ~real~ и ~double precision~ поддерживают специальное значение ~NaN~,
которое означает «не число» (not a number).

В математике существует такое понятие, как /неопределенность/. В качестве одного
из ее вариантов служит результат операции умножения нуля на бесконечность.
Посмотрите, что выдаст в результате PostgreSQL:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 0.0 * 'Inf'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
|      NaN |

В документации утверждается, что значение ~NaN~ считается равным другому
значению ~NaN~, а также что значение ~NaN~ считается большим любого другого
«нормального» значения, т.е. ~не-NaN~. Проверьте эти утверждения с помощью
SQL-команды ~SELECT~.

Например, сравните значения ~NaN~ и ~Infinity~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::real > 'Inf'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::real = 'NaN'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'NaN'::real > '1e+30'::real;
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 7
Тип ~serial~ может применяться для столбцов, содержащих числовые значения,
которые должны быть уникальными в пределах таблицы, например, идентификаторы
каких-то объектов. В качестве иллюстрации применения типа ~serial~ предложим
таблицу, содержащую наименования улиц и площадей:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  CREATE TABLE test_serial(id serial, name text);
#+END_SRC

#+RESULTS:
: CREATE TABLE

Введите несколько строк. Обратите внимание, что значение для столбца ~id~
указывать не обязательно (и даже не нужно). Но поскольку мы задаем значения не
для всех столбцов, имеющихся в таблице, мы должны указать в команде ~INSERT~ не
только список значений, но и список столбцов. Конечно, в данном простом случае
эти списки состоят лишь из одного элемента.

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO test_serial (name) VALUES ('Вишневая');
  INSERT INTO test_serial (name) VALUES ('Грушевая');
  INSERT INTO test_serial (name) VALUES ('Зеленая');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

Сделайте выборку данных из таблицы, вы увидите, что значения столбца ~id~ имеют
последовательные значения, начиная с 1.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name     |
|----+----------|
|  1 | Вишневая |
|  2 | Грушевая |
|  3 | Зеленая  |

Давайте проведем эксперимент со столбцом ~id~. Выполните команду ~INSERT~, в
которой укажите явное значение столбца ~id~:

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO test_serial (id, name) VALUES (10, 'Прохладная');
#+END_SRC

#+RESULTS:
: INSERT 0 1

А теперь добавьте еще одну строку, но уже не указывая явно значение для
столбца ~id~ (как мы поступали в предыдущих командах):

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO test_serial (name) VALUES ('Луговая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name       |
|----+------------|
|  1 | Вишневая   |
|  2 | Грушевая   |
|  3 | Зеленая    |
| 10 | Прохладная |
|  4 | Луговая    |

Вы увидите, что явное задание значения для столбца ~id~ не влияет на
автоматическое генерирование значений этого столбца.
*** Вопрос 8
Немного усложним определение таблицы из предыдущего задания. Пусть теперь
столбец ~id~ будет первичным ключом этой таблицы.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE test_serial;
  CREATE TABLE test_serial(id serial PRIMARY KEY, name text);
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

Теперь выполните следующие команды для добавления строк в таблицу и удаления
одной строки из нее. Для пошагового управления этим процессом выполняйте выборку
данных из таблицы с помощью команды ~SELECT~ после каждой команды вставки или
удаления.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  INSERT INTO test_serial (name) VALUES ('Вишневая');
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name     |
|----+----------|
|  1 | Вишневая |

Явно зададим значение столбца ~id~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  INSERT INTO test_serial (id, name) VALUES (2, 'Прохладная');
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name       |
|----+------------|
|  1 | Вишневая   |
|  2 | Прохладная |

При выполнении этой команды СУБД выдаст сообщение об ошибке. Почему?

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Грушевая');
#+END_SRC

#+RESULTS:
: ERROR:  duplicate key value violates unique constraint "test_serial_pkey"
: DETAIL:  Key (id)=(2) already exists.

*ОТВЕТ*: команда вставки с явно указанным значением столбца ~id~ не
икрементировала значение ~sequence~ связанного с этим столбцом.

Повторим эту же команду. Теперь все в порядке. Почему?

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Грушевая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

*ОТВЕТ*: откат транзакции не приводит к откату на предыдущее значение
~sequence~.

Добавим еще одну строку.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Зеленая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

А теперь удалим ее же.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM test_serial WHERE id = 4;
#+END_SRC

#+RESULTS:
: DELETE 1

Добавим последнюю строку.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO test_serial (name) VALUES ('Луговая');
#+END_SRC

#+RESULTS:
: INSERT 0 1

Теперь сделаем выборку.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM test_serial;
#+END_SRC

#+RESULTS:
| id | name       |
|----+------------|
|  1 | Вишневая   |
|  2 | Прохладная |
|  3 | Грушевая   |
|  5 | Луговая    |

Вы увидите, что в нумерации образовалась «дыра». Это из-за того, что при
формировании нового значения из последовательности поиск максимального значения,
уже имеющегося в столбце, не выполняется.
*** Вопрос 9
Какой календарь используется в PostgreSQL для работы с датами: юлианский или
григорианский?

*ОТВЕТ*: григорианский
*** Вопрос 10
Каждый тип данных из группы «дата/время» имеет ограничение на минимальное и
максимальное допустимое значение. Найдите в документации в разделе 8.5 «Типы
даты/времени» эти значения и подумайте, почему они таковы.

| Имя                                     | Размер  | Описание                              | Наименьшее значение | Наибольшее значение | Точность                 |
|-----------------------------------------+---------+---------------------------------------+---------------------+---------------------+--------------------------|
| timestamp [ (p) ] [ without time zone ] | 8 байт  | дата и время (без часового пояса)     | 4713 до н. э.       | 294276 н. э.        | 1 микросекунда / 14 цифр |
| timestamp [ (p) ] with time zone        | 8 байт  | дата и время (с часовым поясом)       | 4713 до н. э.       | 294276 н. э.        | 1 микросекунда / 14 цифр |
| date                                    | 4 байта | дата (без времени суток)              | 4713 до н. э.       | 5874897 н. э.       | 1 день                   |
| time [ (p) ] [ without time zone ]      | 8 байт  | время суток (без даты)                | 00:00:00            | 24:00:00            | 1 микросекунда / 14 цифр |
| time [ (p) ] with time zone             | 12 байт | только время суток (с часовым поясом) | 00:00:00+1559       | 24:00:00-1559       | 1 микросекунда / 14 цифр |
| interval [ поля ] [ (p) ]               | 16 байт | временной интервал                    | -178000000 лет      | 178000000 лет       | 1 микросекунда / 14 цифр |
*** Вопрос 11
Типы ~timestamp~, ~time~ и ~interval~ позволяют задать точность ввода и вывода
значений. Точность предписывает количество десятичных цифр в поле секунд.
Проиллюстрируем эту возможность на примере типа ~time~, выполнив три запроса: в
первом запросе вообще не используем параметр точности, во втором назначим его
равным 0, в третьем запросе сделаем его равным 3.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT current_time AS first,
         current_time::time(0) AS second,
         current_time::time(3) AS third;
#+END_SRC

#+RESULTS:
|              first |   second |       third |
|--------------------+----------+-------------|
| 20:20:04.330104+02 | 20:20:04 | 20:20:04.33 |

Выполните подобные команды для типов ~timestamp~ и ~interval~.

Тип ~date~ такой возможности — задавать точность — не имеет. Как вы думаете,
почему?

*ОТВЕТ*:

Тип ~date~ не хранит секунды.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT current_timestamp AS first,
         current_timestamp::timestamptz(0) AS second,
         current_timestamp::timestamptz(3) AS third;
#+END_SRC

#+RESULTS:
| first                         | second                 | third                      |
|-------------------------------+------------------------+----------------------------|
| 2021-04-08 20:23:43.408871+02 | 2021-04-08 20:23:43+02 | 2021-04-08 20:23:43.409+02 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '1 day 15 seconds 12345 milliseconds ago'::interval AS first,
         '1 day 15 seconds 12345 milliseconds ago'::interval(0) AS second,
         '1 day 15 seconds 12345 milliseconds ago'::interval(2) AS third;
#+END_SRC

#+RESULTS:
| first                 | second            | third                |
|-----------------------+-------------------+----------------------|
| -1 days -00:00:27.345 | -1 days -00:00:27 | -1 days -00:00:27.35 |
*** Вопрос 12
Формат ввода и вывода даты можно изменить с помощью конфигурационного параметра
~datestyle~. Значение этого параметра состоит из двух компонентов: первый
управляет форматом вывода даты, а второй регулирует порядок следования составных
частей даты (год, месяц, день) при вводе и выводе. Текущее значение этого
параметра можно узнать с помощью команды ~SHOW~: src_sql[:exports code]{SHOW
datestyle;}

По умолчанию он имеет такое значение:

#+BEGIN_EXAMPLE
asakura=# show datestyle;
 DateStyle
-----------
 ISO, DMY
(1 row)
#+END_EXAMPLE

Продемонстрируем влияние этого параметра на работу с типами данных ~date~ и
~timestamp~. Для экспериментов возьмем дату, в которой число (день) превышает
12, чтобы нельзя было день перепутать с номером месяца. Пусть это будет,
например, 18 мая 2016 г.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '18-05-2016'::date;
#+END_SRC

#+RESULTS:
|       date |
|------------|
| 2016-05-18 |

Попробуем ввести дату в порядке «месяц, день, год»:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT '05-18-2016'::date;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "05-18-2016"
: LINE 1: SELECT '05-18-2016'::date;
:                ^
: HINT:  Perhaps you need a different "datestyle" setting.

В ответ получим сообщение об ошибке. Если бы мы выбрали дату, в которой число
(день) было бы не больше 12, например, 9, то сообщение об ошибке не было бы
сформировано, т.е. мы с такой датой не смогли бы проиллюстрировать влияние
значения ~DMY~ параметра ~datestyle~. Но главное, что в таком случае мы бы
просто не заметили допущенной ошибки.

А вот использовать порядок «год, месяц, день» при вводе можно несмотря на то,
что параметр ~datestyle~ предписывает «день, месяц, год». Порядок «год, месяц,
день» является универсальным, его можно использовать всегда, независимо от
настроек параметра ~datestyle~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '2016-05-18'::date;
#+END_SRC

#+RESULTS:
|       date |
|------------|
| 2016-05-18 |

Продолжим экспериментирование с параметром ~datestyle~. Давайте изменим его
значение. Сделать это можно многими способами, но мы упомянем лишь некоторые:
- зменив его значение в конфигурационном файле ~postgresql.conf~, который
  находится в каталоге ~/usr/local/pgsql/data~;
- назначив переменную системного окружения ~PGDATESTYLE~;
- воспользовавшись командой ~SET~.

Сейчас выберем третий способ, а первые два рассмотрим при выполнении других
заданий. Поскольку параметр ~datestyle~ состоит фактически из двух частей,
которые можно задавать не только обе сразу, но и по отдельности, изменим только
порядок следования составных частей даты, не изменяя формат вывода с ISO на
какой-либо другой.

#+BEGIN_SRC sql :engine postgres :results value verbatim :session datestyle :eval no
  SET datestyle TO 'MDY';
#+END_SRC

#+RESULTS:
: SET

Повторим одну из команд, выполненных ранее. Теперь она должна вызвать ошибку.
Почему?

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :session datestyle :eval no
  SELECT '18-05-2016'::date;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "18-05-2016"
: LINE 1: SELECT '18-05-2016'::date;
:                ^
: HINT:  Perhaps you need a different "datestyle" setting.

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :session datestyle :eval no
  SELECT '18-05-2016'::timestamp;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "18-05-2016"
: LINE 1: SELECT '18-05-2016'::date;
:                ^
: HINT:  Perhaps you need a different "datestyle" setting.

А такая команда, наоборот, теперь будет успешно выполнена:

#+BEGIN_SRC sql :engine postgres :exports both :session datestyle :eval no
  SELECT '05-18-2016'::date;
#+END_SRC

#+RESULTS:
|       date |
|------------|
| 2016-05-18 |

#+BEGIN_SRC sql :engine postgres :exports both :session datestyle :eval no
  SELECT '05-18-2016'::timestamp;
#+END_SRC

#+RESULTS:
|                date |
|---------------------|
| 2016-05-18 00:00:00 |

Теперь приведите настройку параметра ~datestyle~ в исходное состояние:

#+BEGIN_SRC sql :engine postgres :results value verbatim :session datestyle :eval no
  SET datestyle TO DEFAULT;
#+END_SRC

#+RESULTS:
: SET

Самостоятельно выполните команды ~SELECT~, приведенные выше, но замените в них
тип ~date~ на тип ~timestamp~. Вы увидите, что дата в рамках типа ~timestamp~
обрабатывается аналогично типу ~date~.

Сейчас изменим сразу обе части параметра *datestyle*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :session datestyle :eval no
  SET datestyle TO 'Postgres, DMY';
#+END_SRC

#+RESULTS:
: SET

Проверьте полученный результат с помощью команды ~SHOW~.

Самостоятельно выполните команды ~SELECT~, приведенные выше, как для значения
типа ~date~, так и для значения типа ~timestamp~. Обратите внимание, что если
выбран формат Postgres, то порядок следования составных частей даты (день,
месяц, год), заданный в параметре ~datestyle~, используется не только при вводе
значений, но и при выводе. Напомним, что вводом мы считаем команду ~SELECT~, а
выводом — результат ее выполнения, выведенный на экран.

В документации (см. раздел 8.5.2 «Вывод даты/времени») сказано, что формат
вывода даты может принимать значения ISO, Postgres, SQL и German. Первые два
варианта мы уже рассмотрели. Самостоятельно поэкспериментируйте с двумя
оставшимися по той же схеме, по которой вы уже действовали ранее при выполнении
этого задания. Можно воспользоваться и стандартными функциями ~current_date~ и
~current_timestamp~.
*** Вопрос 13
Установить новое значение параметра ~datestyle~ можно с помощью создания
переменной системного окружения ~PGDATESTYLE~. Назначить эту переменную можно в
конфигурационных файлах операционной системы. Но если нам нужно сделать это
только на время текущего сеанса работы клиентской программы, например утилиты
psql, то можно ввести значение этой переменной непосредственно в командной
строке: ~PGDATESTYLE="Postgres" psql -d test -U имя-пользователя~.

Проделайте эти действия, а затем уже из командной строки утилиты psql
проверьте текущее значение параметра ~datestyle~ с помощью команды ~SHOW~.

*ОТВЕТ*:

#+BEGIN_EXAMPLE
$ PGDATESTYLE="Postgres" psql
psql (13.2 (Ubuntu 13.2-1.pgdg20.04+1), server 12.6 (Ubuntu 12.6-1.pgdg20.04+1))
Type "help" for help.

asakura=# show datestyle;
   DateStyle
---------------
 Postgres, DMY
(1 row)

asakura=# SELECT current_timestamp;
          current_timestamp
--------------------------------------
 Thu 08 Apr 20:34:34.440317 2021 CEST
(1 row)

asakura=#
#+END_EXAMPLE
*** Вопрос 14
Назначить значение параметра ~datestyle~ можно в конфигурационном файле
~postgresql.conf~, который находится в каталоге ~/usr/local/pgsql/data~.
Предварительно сохраните текущую (корректно работающую) версию этого файла, а
затем измените в нем значение параметра ~datestyle~, например, на ~Postgres,
YMD~. Перезапустите сервер PostgreSQL, чтобы изменения вступили в силу.

Для проверки полученного результата выполните несколько команд ~SELECT~,
например:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT current_timestamp;
#+END_SRC

*ОТВЕТ*:

#+RESULTS:
| current_timestamp                    |
|--------------------------------------|
| Fri Apr 09 11:03:56.041788 2021 CEST |
*** Вопрос 15
В документации в разделе 9.8 «Функции форматирования данных» представлены
описания множества полезных функций, позволяющих преобразовать в строку данные
других типов, например, ~timestamp~. Одна из таких функций — ~to_char~.

Приведем несколько команд, иллюстрирующих использование этой функции. Ее первым
параметром является форматируемое значение, а вторым — шаблон, описывающий
формат, в котором это значение будет представлено при вводе или выводе. Сначала
попробуйте разобраться, не обращаясь к документации, в том, что означает второй
параметр этой функции в каждой из приведенных команд, а затем проверьте свои
предположения по документации.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'mi:ss');
#+END_SRC

*ОТВЕТ*: минуты, секунды

#+RESULTS:
| to_char |
|---------|
|   07:47 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'dd');
#+END_SRC

*ОТВЕТ*: день

#+RESULTS:
| to_char |
|---------|
|      09 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'yyyy-mm-dd');
#+END_SRC

*ОТВЕТ*: год, месяц, день

#+RESULTS:
|    to_char |
|------------|
| 2021-04-09 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT to_char(current_timestamp, 'dd/mm/yyyy mi:ss');
#+END_SRC

*ОТВЕТ*: американский формат даты и времени

#+RESULTS:
| to_char          |
|------------------|
| 09/04/2021 09:22 |
*** Вопрос 16
При выполнении приведения типа данных производится проверка значения на
допустимость. Попробуйте ввести недопустимое значение даты, например, 29 февраля
в невисокосном году. Получите сообщение об ошибке.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT 'Feb 29, 2015'::date;
#+END_SRC

#+RESULTS:
: ERROR:  date/time field value out of range: "Feb 29, 2015"
: LINE 1: SELECT 'Feb 29, 2015'::date;
*** Вопрос 17
При выполнении приведения типа данных производится проверка значения
надопустимость. Попробуйте ввести недопустимое значение времени, например, с
нарушением формата.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT '21:15:16:22'::time;
#+END_SRC

#+RESULTS:
: ERROR: invalid input syntax for type time: "21:15:16:22"
: LINE 1: SELECT '21:15:16:22'::time;
*** Вопрос 18
Как вы думаете, значение какого типа будет получено при вычитании одной даты
из другой? Сначала попробуйте получить ответ, рассуждая логически, а затем
проверьте на практике в утилите psql.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::date -'2016-09-01'::date);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
|       15 |

*ОТВЕТ*: дни.
*** Вопрос 19
С типами даты и времени можно выполнять различные арифметические операции. Как
правило, их применение является интуитивно понятным. Выполните следующую команду
и проанализируйте результат.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('20:34:35'::time - '19:44:45'::time);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| 00:49:50 |

*ОТВЕТ*: ~interval~

А теперь попробуйте предположить, какой результат будет получен, если в этой
команде знак «минус» заменить на знак «плюс»? Проверьте ваши предположения с
помощью утилиты psql. Подробное описание всех допустимых арифметических операций
с датами и временем приведено в документации в разделе 9.9 «Операторы и функции
даты/времени».

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT ('20:34:35'::time + '19:44:45'::time);
#+END_SRC

#+RESULTS:
: ERROR:  operator is not unique: time without time zone + time without time zone
: LINE 1: SELECT ('20:34:35'::time + '19:44:45'::time);
:                                  ^
: HINT:  Could not choose a best candidate operator. You might need to add explicit type casts.
*** Вопрос 20
Значение типа ~interval~ можно получить при вычитании одной временной отметки из
другой, например:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT (current_timestamp - '2016-01-01'::timestamp) AS new_date;
#+END_SRC

#+RESULTS:
| new_date                  |
|---------------------------|
| 1925 days 14:32:13.783037 |

А что получится, если прибавить интервал к временной отметке? Сначала попробуйте
дать ответ, не прибегая к помощи утилиты psql, а затем проверьте свой ответ с
помощью этой утилиты. Например, прибавим интервал длительностью в 1 месяц к
текущей к временной отметке:

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT (current_timestamp + '1 mon'::interval) AS new_date;
#+END_SRC

#+RESULTS:
| new_date                      |
|-------------------------------|
| 2021-05-09 15:32:57.116552+02 |

В этой команде с помощью ключевого слова ~AS~ мы назначили псевдоним для того
столбца, который будет выведен в результате. Выполните эту же команду, убрав
псевдоним, и найдите отличия.
*** Вопрос 21
Можно с высокой степенью уверенности предположить, что при прибавлении
интервалов к датам и временным отметкам PostgreSQL учитывает тот факт, что
различные месяцы имеют различное число дней. Но как это реализуется на практике?
Например, что получится при прибавлении интервала в 1 месяц к последнему дню
января и к последнему дню февраля? Сначала сделайте обоснованные предположения о
результатах следующих двух команд, а затем проверьте предположения на практике и
проанализируйте полученные результаты:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-01-31'::date +'1 mon'::interval) AS new_date;
#+END_SRC

#+RESULTS:
| new_date            |
|---------------------|
| 2016-02-29 00:00:00 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-02-29'::date +'1 mon'::interval) AS new_date;
#+END_SRC

#+RESULTS:
| new_date            |
|---------------------|
| 2016-03-29 00:00:00 |

*ОТВЕТ*: если количество дней в месяце меньше - то тогда выбирает последний
день. Если больше - оставляет тот же номер дня.
*** Вопрос 22
Форматом ввода и вывода интервалов управляет параметр ~intervalstyle~. Его можно
изменить с помощью способов, аналогичных тем, что были описаны выше для
параметра ~datestyle~. Самостоятельно поэкспериментируйте с различными
значениями параметра ~intervalstyle~ аналогично тому, как вы этоделали с
параметром ~datestyle~. Используйте раздел 8.5 «Типы даты/времени» в
документации. Напомним, что вернуть исходное значение этого параметра в psql
можно с помощью команды:

src_sql[:exports code]{SET intervalstyle TO DEFAULT;}

*TODO* ответить на вопрос
*** Вопрос 23
Выполните следующие две команды и объясните различия в выведенных результатах:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::date - '2015-09-01'::date);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
|      381 |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::timestamp - '2015-09-01'::timestamp);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| 381 days |

*ОТВЕТ*: в первом случае возвращает ~integer~, а во втором ~interval~.
*** Вопрос 24
Выполните следующие две команды и объясните различия в выведенных результатах:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('20:34:35'::time - 1);
#+END_SRC

#+RESULTS:
: ERROR:  operator does not exist: time without time zone - integer
: LINE 1: SELECT ('20:34:35'::time - 1);
:                                  ^
: HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('2016-09-16'::date - 1);
#+END_SRC

#+RESULTS:
|   ?column? |
|------------|
| 2016-09-15 |

Почему при выполнении первой команды возникает ошибка? Как можно модифицировать
эту команду, чтобы ошибка исчезла?

Для получения полной информации обратитесь к разделу 9.9 «Операторы и функции
даты/времени» документации.

*ОТВЕТ*: оператор ~-~ не определен для типа ~time~ и ~integer~. Можно привести к
типу ~interval~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ('20:34:35'::time - '1 hour'::interval);
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| 19:34:35 |
*** Вопрос 25
Значения временных отметок можно усекать с той или иной точностью с помощью
функции ~date_trunc~. Например, с помощью следующей команды можно «отрезать»
дробную часть секунды:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT date_trunc('sec', timestamp '1999-11-27 12:34:56.987654');
#+END_SRC

#+RESULTS:
| date_trunc          |
|---------------------|
| 1999-11-27 12:34:56 |

Напомним, что в данной команде используется операция приведения типа.

Выполните эту команду, последовательно указывая в качестве первого параметра
значения ~microsecond~, ~millisecond~, ~second~, ~minute~, ~hour~, ~day~,
~week~, ~month~, ~year~, ~decade~, ~century~, ~millennium~ (которые обозначают
соответственно микросекунды, миллисекунды, секунды, минуты, часы, дни, недели,
месяцы, годы, десятилетия, века и тысячелетия). Допустимы сокращения ~sec~,
~min~, ~mon~, ~dec~, ~cent~, ~mil~.

Обратите внимание, что результирующее значение получается не путем округления
исходного значения, а именно путем отбрасывания более мелких единиц. При этом
поля времени (часы, минуты и секунды) заменяются нулями, а поля даты (годы,
месяцы и дни) — заменяются цифрами 01. Однако при использовании параметра ~week~
картина получается более интересная.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', date_trunc('microsecond', timestamp '1999-11-27 12:34:56.987654')),
                 ('millisecond', date_trunc('millisecond', timestamp '1999-11-27 12:34:56.987654')),
                 ('second', date_trunc('second', timestamp '1999-11-27 12:34:56.987654')),
                 ('minute', date_trunc('minute', timestamp '1999-11-27 12:34:56.987654')),
                 ('hour', date_trunc('hour', timestamp '1999-11-27 12:34:56.987654')),
                 ('day', date_trunc('day', timestamp '1999-11-27 12:34:56.987654')),
                 ('week', date_trunc('week', timestamp '1999-11-27 12:34:56.987654')),
                 ('month', date_trunc('month', timestamp '1999-11-27 12:34:56.987654')),
                 ('year', date_trunc('year', timestamp '1999-11-27 12:34:56.987654')),
                 ('decade', date_trunc('decade', timestamp '1999-11-27 12:34:56.987654')),
                 ('century', date_trunc('century', timestamp '1999-11-27 12:34:56.987654')),
                 ('millennium', date_trunc('millennium', timestamp '1999-11-27 12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         | trunc                      |
|-------------+----------------------------|
| microsecond | 1999-11-27 12:34:56.987654 |
| millisecond | 1999-11-27 12:34:56.987    |
| second      | 1999-11-27 12:34:56        |
| minute      | 1999-11-27 12:34:00        |
| hour        | 1999-11-27 12:00:00        |
| day         | 1999-11-27 00:00:00        |
| week        | 1999-11-*22* 00:00:00      |
| month       | 1999-11-01 00:00:00        |
| year        | 1999-01-01 00:00:00        |
| decade      | 1990-01-01 00:00:00        |
| century     | 1901-01-01 00:00:00        |
| millennium  | 1001-01-01 00:00:00        |
*** Вопрос 26
Функция ~date_trunc~ может работать не только с данными типа ~timestamp~, но
также и с данными типа ~interval~. Самостоятельно ознакомьтесь с этими
возможностями по документации (см. раздел 9.9 «Операторы и функции
даты/времени»).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', date_trunc('microsecond', interval 'P1999-11-27T12:34:56.987654')),
                 ('millisecond', date_trunc('millisecond', interval 'P1999-11-27T12:34:56.987654')),
                 ('second',      date_trunc('second',      interval 'P1999-11-27T12:34:56.987654')),
                 ('minute',      date_trunc('minute',      interval 'P1999-11-27T12:34:56.987654')),
                 ('hour',        date_trunc('hour',        interval 'P1999-11-27T12:34:56.987654')),
                 ('day',         date_trunc('day',         interval 'P1999-11-27T12:34:56.987654')),
                 ('month',       date_trunc('month',       interval 'P1999-11-27T12:34:56.987654')),
                 ('year',        date_trunc('year',        interval 'P1999-11-27T12:34:56.987654')),
                 ('decade',      date_trunc('decade',      interval 'P1999-11-27T12:34:56.987654')),
                 ('century',     date_trunc('century',     interval 'P1999-11-27T12:34:56.987654')),
                 ('millennium',  date_trunc('millennium',  interval 'P1999-11-27T12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         | trunc                                      |
|-------------+--------------------------------------------|
| microsecond | 1999 years 11 mons 27 days 12:34:56.987654 |
| millisecond | 1999 years 11 mons 27 days 12:34:56.987    |
| second      | 1999 years 11 mons 27 days 12:34:56        |
| minute      | 1999 years 11 mons 27 days 12:34:00        |
| hour        | 1999 years 11 mons 27 days 12:00:00        |
| day         | 1999 years 11 mons 27 days                 |
| month       | 1999 years 11 mons                         |
| year        | 1999 years                                 |
| decade      | 1990 years                                 |
| century     | 1900 years                                 |
| millennium  | 1000 years                                 |

~week~ использовать нельзя:
: ERROR:  interval units "week" not supported because months usually have fractional weeks
*** Вопрос 27
Весьма полезной является функция ~extract~. С ее помощью можно извлечь значение
отдельного поля из временной отметки ~timestamp~. Наименование поля задается в
первом параметре. Эти наименования такие же, что и для функции ~date_trunc~.
Выполните следующую команду

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT extract('microsecond' FROM timestamp '1999-11-27 12:34:56.123459');
#+END_SRC

#+RESULTS:
| date_part |
|-----------|
|  56123459 |

Она выводит не просто значение поля микросекунд, т.е. 123459, а дополнительно
преобразует число секунд в микросекунды и добавляет значение поля микросекунд.

Выполните эту команду, последовательно указывая в качестве первого параметра
значения ~microsecond~, ~millisecond~, ~second~, ~minute~, ~hour~, ~day~,
~week~, ~month~, ~year~, ~decade~, ~century~, ~millennium~. Можно использовать
сокращения этих наименований, которые приведены в предыдущем задании.

Обратите внимание, что в ряде случаев выводится не просто конкретное поле
(фрагмент) из временной отметки, а некоторый продукт переработки этого поля.
Например, если в качестве первого параметра функции ~extract~ в вышеприведенной
команде указать ~cent~ (век), то мы получим в ответ не 19 (что и было бы
буквальным значением поля «век»), а 20, поскольку 1999 год принадлежит
двадцатому веку.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', extract('microsecond' FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('millisecond', extract('millisecond' FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('second',      extract('second'      FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('minute',      extract('minute'      FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('hour',        extract('hour'        FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('day',         extract('day'         FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('week',        extract('week'        FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('month',       extract('month'       FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('year',        extract('year'        FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('decade',      extract('decade'      FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('century',     extract('century'     FROM timestamp '1999-11-27 12:34:56.987654')),
                 ('millennium',  extract('millennium'  FROM timestamp '1999-11-27 12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         |     trunc |
|-------------+-----------|
| microsecond |  56987654 |
| millisecond | 56987.654 |
| second      | 56.987654 |
| minute      |        34 |
| hour        |        12 |
| day         |        27 |
| week        |      *47* |
| month       |        11 |
| year        |      1999 |
| decade      |       199 |
| century     |      *20* |
| millennium  |         2 |
*** Вопрос 28
Функция ~extract~ может работать не только с данными типа ~timestamp~, но также
и с данными типа ~interval~. Самостоятельно ознакомьтесь с этими возможностями
по документации (см. раздел 9.9 «Операторы и функции даты/времени»).

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM (VALUES
                 ('microsecond', extract('microsecond' FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('millisecond', extract('millisecond' FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('second',      extract('second'      FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('minute',      extract('minute'      FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('hour',        extract('hour'        FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('day',         extract('day'         FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('month',       extract('month'       FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('year',        extract('year'        FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('decade',      extract('decade'      FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('century',     extract('century'     FROM interval 'P1999-11-27T12:34:56.987654')),
                 ('millennium',  extract('millennium'  FROM interval 'P1999-11-27T12:34:56.987654'))) AS foo(res, trunc);
#+END_SRC

#+RESULTS:
| res         |     trunc |
|-------------+-----------|
| microsecond |  56987654 |
| millisecond | 56987.654 |
| second      | 56.987654 |
| minute      |        34 |
| hour        |        12 |
| day         |        27 |
| month       |        11 |
| year        |      1999 |
| decade      |       199 |
| century     |        19 |
| millennium  |         1 |

~week~ использовать нельзя:
: ERROR:  interval units "week" not supported
*** Вопрос 29
В тексте главы мы создавали таблицу с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE databases(is_open_source boolean, dbms_name text);
#+END_SRC

#+RESULTS:
: CREATE TABLE

и заполняли ее данными.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO databases VALUES (TRUE, 'PostgreSQL');
  INSERT INTO databases VALUES (FALSE, 'Oracle');
  INSERT INTO databases VALUES (TRUE, 'MySQL');
  INSERT INTO databases VALUES (FALSE, 'MS SQL Server');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

Как вы думаете, являются ли все приведенные ниже команды равнозначными в
смысле результатов, получаемых с их помощью?

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT * FROM databases WHERE NOT is_open_source;
  SELECT * FROM databases WHERE is_open_source <> 'yes';
  SELECT * FROM databases WHERE is_open_source <> 't';
  SELECT * FROM databases WHERE is_open_source <> '1';
  SELECT * FROM databases WHERE is_open_source <>  1;
#+END_SRC

*ОТВЕТ*: нет, см. ниже

: ERROR:  operator does not exist: boolean <> integer
: LINE 1: SELECT * FROM databases WHERE is_open_source <> 1;
:                                                     ^
: HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
*** Вопрос 30
Обратимся к таблице, создаваемой с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE test_bool(a boolean, b text);
#+END_SRC

#+RESULTS:
: CREATE TABLE

Как вы думаете, какие из приведенных ниже команд содержат ошибку?

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO test_bool VALUES ( TRUE, 'yes' );

  -- ERROR:  column "yes" does not exist
  INSERT INTO test_bool VALUES (  yes, 'yes' );

  INSERT INTO test_bool VALUES ('yes', true  );
  INSERT INTO test_bool VALUES ('yes', TRUE  );
  INSERT INTO test_bool VALUES (  '1', 'true');

  -- ERROR:  column "a" is of type boolean but expression is of type integer
  INSERT INTO test_bool VALUES (    1, 'true');

  INSERT INTO test_bool VALUES (  't', 'true');

  -- ERROR:  column "truth" does not exist
  INSERT INTO test_bool VALUES (  't', truth );

  INSERT INTO test_bool VALUES ( true, true  );
  INSERT INTO test_bool VALUES (1::boolean,   'true');
  INSERT INTO test_bool VALUES (111::boolean, 'true');
#+END_SRC

Проверьте свои предположения практически, выполнив эти команды.
*** Вопрос 31
Пусть в таблице ~birthdays~ хранятся даты рождения какой-то группы людей.
Создайте эту таблицу с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE birthdays(person text NOT NULL, birthday date NOT NULL);
#+END_SRC

#+RESULTS:
: CREATE TABLE

Добавьте в нее несколько строк, например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO birthdays VALUES ('Ken Thompson', '1955-03-23');
  INSERT INTO birthdays VALUES ('Ben Johnson', '1971-03-19');
  INSERT INTO birthdays VALUES ('Andy Gibson', '1987-08-12');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

Давайте выберем из таблицы ~birthdays~ строки для всех людей, родившихся в
каком-то конкретном месяце, например, в марте:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM birthdays
   WHERE extract('mon' FROM birthday) = 3;
#+END_SRC

#+RESULTS:
| person       |   birthday |
|--------------+------------|
| Ken Thompson | 1955-03-23 |
| Ben Johnson  | 1971-03-19 |

В этой команде в вызове функции ~extract~ имеет место неявное приведение типов,
т.к. ее вторым параметром должно быть значение типа ~timestamp~. Полагаться на
неявное приведение типов можно не всегда.

Если нам потребуется выяснить, кто из этих людей достиг возраста, скажем, 40
лет на момент выполнения запроса, то команда может быть такой (в последнем
столбце показана дата достижения возраста 40 лет):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *,
         birthday + '40 years'::interval
    FROM birthdays
   WHERE birthday + '40 years'::interval < current_timestamp;
#+END_SRC

#+RESULTS:
| person       |   birthday | ?column?            |
|--------------+------------+---------------------|
| Ken Thompson | 1955-03-23 | 1995-03-23 00:00:00 |
| Ben Johnson  | 1971-03-19 | 2011-03-19 00:00:00 |

Можно заменить ~current_timestamp~ на ~current_date~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *,
         birthday + '40 years'::interval
    FROM birthdays
   WHERE birthday + '40 years'::interval < current_date;
#+END_SRC

#+RESULTS:
| person       |   birthday | ?column?            |
|--------------+------------+---------------------|
| Ken Thompson | 1955-03-23 | 1995-03-23 00:00:00 |
| Ben Johnson  | 1971-03-19 | 2011-03-19 00:00:00 |

А вот если мы захотим определить точный возраст каждого человека на текущий
момент времени, то как получить этот результат? Первый вариант таков:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *,
         (current_date::timestamp - birthday::timestamp)::interval
    FROM birthdays;
#+END_SRC

#+RESULTS:
| person       |   birthday | interval   |
|--------------+------------+------------|
| Ken Thompson | 1955-03-23 | 24128 days |
| Ben Johnson  | 1971-03-19 | 18288 days |
| Andy Gibson  | 1987-08-12 | 12298 days |

Этот вариант не дает результата, представленного в удобной форме: он показывает
возраст в днях, а для пересчета числа дней в число лет нужны дополнительные
действия. Хотя, наверное, возможны ситуации, когда требуется определить возраст
именно в днях.

В PostgreSQL предусмотрена специальная функция, позволяющая решить нашу задачу
простым способом. Самостоятельно найдите ее описание в документации (см. раздел
9.9 «Операторы и функции даты/времени») и напишите команду с её использованием.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *, age(birthday::timestamp) FROM birthdays;
#+END_SRC

#+RESULTS:
| person       |   birthday | age                   |
|--------------+------------+-----------------------|
| Ken Thompson | 1955-03-23 | 66 years 21 days      |
| Ben Johnson  | 1971-03-19 | 50 years 25 days      |
| Andy Gibson  | 1987-08-12 | 33 years 8 mons 1 day |
*** Вопрос 32
Изучая приемы работы с массивами, можно, как и в других случаях, пользоваться
способностью команды ~SELECT~ обходиться без создания таблиц. Покажем лишь два
примера.

Для объединения (конкатенации) массивов служит функция ~array_cat~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_cat(ARRAY[1, 2, 3], ARRAY[3, 5]);
#+END_SRC

#+RESULTS:
| array_cat   |
|-------------|
| {1,2,3,3,5} |

Удалить из массива элементы, имеющие указанное значение, можно таким образом с
помощью функции ~array_remove~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_remove(ARRAY[2, 3, 4], 3);
#+END_SRC

#+RESULTS:
| array_remove |
|--------------|
| {2,4}        |

Для работы с массивами предусмотрено много различных функций и операторов,
представленных в разделе документации 9.18 «Функции и операторы для работы с
массивами». Самостоятельно ознакомьтесь с ними, используя описанную технологию
работы с командой ~SELECT~.

*ОТВЕТ*:

~array_ndims~ возвращает число размерностей массива:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_ndims(ARRAY[ARRAY[1, 2, 3], ARRAY[4, 4, 4]]);
#+END_SRC

#+RESULTS:
| array_ndims |
|-------------|
|           2 |

~array_dims~ возвращает текстовое представление размерностей массива:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_dims(ARRAY[ARRAY[1, 2, 3], ARRAY[4, 4, 4]]);
#+END_SRC

#+RESULTS:
| array_dims |
|------------|
| [1:2][1:3] |

~array_position(anyarray, anyelement [, int])~ возвращает позицию первого
вхождения второго аргумента в массиве, начиная с элемента, выбираемого третьим
аргументом, либо с первого элемента (массив должен быть одномерным):

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
#+END_SRC

#+RESULTS:
| array_position |
|----------------|
|              2 |

~array_to_string(anyarray, text [, text])~ выводит элементы массива через
заданный разделитель и позволяет определить замену для значения NULL:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*');
#+END_SRC

#+RESULTS:
| array_to_string |
|-----------------|
| 1,2,3,*,5       |
*** Вопрос 33
В разделе документации 8.15 «Массивы» сказано, что массивы могут быть
многомерными и в них могут содержаться значения любых типов. Давайте сначала
рассмотрим одномерные массивы текстовых значений.

Предположим, что пилоты авиакомпании имеют возможность высказывать свои
пожелания насчет конкретных блюд, из которых должен состоять их обед во время
полета. Для учета пожеланий пилотов необходимо модифицировать таблицу ~pilots~,
с которой мы работали в разделе 4.5.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS pilots;
  CREATE TABLE pilots(pilot_name text, schedule integer[], meal text[]);
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

Добавим строки в таблицу:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots VALUES ('Ivan',  '{1, 3, 5, 6, 7}'::integer[], '{"сосиска", "макароны", "кофе"}'::text[]),
                            ('Petr',  '{1, 2, 5, 7}'::integer [],   '{"котлета", "каша", "кофе"}'::text[]),
                            ('Pavel', '{2, 5}'::integer[],          '{"сосиска", "каша", "кофе"}'::text[]),
                            ('Boris', '{3, 5, 6}'::integer[],       '{"котлета", "каша", "чай"}'::text[]);
#+END_SRC

#+RESULTS:
: INSERT 0 4

Обратите внимание, что каждое из текстовых значений, включаемых в литерал
массива, заключается в двойные кавычки, а в качестве типа данных указывается
~text[]~.

Вот что получилось:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM pilots;
#+END_SRC

#+RESULTS:
| pilot_name | schedule    | meal                    |
|------------+-------------+-------------------------|
| Ivan       | {1,3,5,6,7} | {сосиска,макароны,кофе} |
| Petr       | {1,2,5,7}   | {котлета,каша,кофе}     |
| Pavel      | {2,5}       | {сосиска,каша,кофе}     |
| Boris      | {3,5,6}     | {котлета,каша,чай}      |

Давайте получим список пилотов, предпочитающих на обед сосиски:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM pilots WHERE meal[1] = 'сосиска';
#+END_SRC

#+RESULTS:
| pilot_name | schedule    | meal                    |
|------------+-------------+-------------------------|
| Ivan       | {1,3,5,6,7} | {сосиска,макароны,кофе} |
| Pavel      | {2,5}       | {сосиска,каша,кофе}     |

Предположим, что руководство авиакомпании решило, что пища пилотов должна быть
разнообразной. Оно позволило им выбрать свой рацион на каждый из четырех дней
недели, в которые пилоты совершают полеты. Для нас это решение руководства
выливается в необходимость модифицировать таблицу, а именно: столбец ~meal~
теперь будет содержать двумерные массивы. Определение этого столбца станет
таким: ~meal text[][]~.

Задание. Создайте новую версию таблицы и соответственно измените команду
~INSERT~, чтобы в ней содержались литералы двумерных массивов. Они будут
выглядеть примерно так:

: '{ { "сосиска", "макароны", "кофе" },
:    { "котлета", "каша", "кофе" },
:    { "сосиска", "каша", "кофе" },
:    { "котлета", "каша", "чай" } }'::text[][]

Сделайте ряд выборок и обновлений строк в этой таблице. Для обращения к
элементам двумерного массива нужно использовать два индекса. Не забывайте, что
по умолчанию номера индексов начинаются с единицы.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS pilots;
  CREATE TABLE pilots(pilot_name text, schedule integer[], meal text[][]);
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

Добавим строки в таблицу:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO pilots
  VALUES (
         'Ivan', '{1, 3, 5, 6, 7}'::integer[],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);

  INSERT INTO pilots
  VALUES (
         'Petr', '{1, 2, 5, 7}'::integer [],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);

  INSERT INTO pilots
  VALUES (
         'Pavel', '{2, 5}'::integer[],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);

  INSERT INTO pilots
  VALUES (
         'Boris', '{3, 5, 6}'::integer[],
         '{ { "сосиска", "макароны", "кофе" },
            { "котлета", "каша", "кофе" },
            { "сосиска", "каша", "кофе" },
            { "котлета", "каша", "чай" } }'::text[][]);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM pilots WHERE meal[1][1] = 'сосиска';
#+END_SRC

#+RESULTS:
| pilot_name | schedule    | meal                                                                                 |
|------------+-------------+--------------------------------------------------------------------------------------|
| Ivan       | {1,3,5,6,7} | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
| Petr       | {1,2,5,7}   | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
| Pavel      | {2,5}       | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
| Boris      | {3,5,6}     | {{сосиска,макароны,кофе},{котлета,каша,кофе},{сосиска,каша,кофе},{котлета,каша,чай}} |
*** Вопрос 34
В тексте раздела 4.6 мы выполняли обновление JSON-объекта с помощью функции
~jsonb_set~: добавляли значение в массив. Для обновления скалярных значений,
например, по ключу ~trips~, можно сделать так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{trips}', '10')
   WHERE pilot_name = 'Pavel';
#+END_SRC

#+RESULTS:
: UPDATE 1

Второй параметр функции — это путь в пределах JSON-объекта. Он теперь
представляет собой лишь имя ключа. Однако его необходимо заключить в фигурные
скобки. Третий параметр — это новое значение. Хотя оно числовое, но все равно
требуется записать его в одинарных кавычках.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies->'trips' AS trips
    FROM pilot_hobbies;
#+END_SRC

#+RESULTS:
| pilot_name | trips |
|------------+-------|
| Ivan       |     3 |
| Petr       |     2 |
| Boris      |     0 |
| Pavel      |    10 |

Задание. Самостоятельно выполните изменение значения по ключу ~home_lib~ в одной
из строк таблицы.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE pilot_hobbies
     SET hobbies = jsonb_set(hobbies, '{home_lib}', 'false')
   WHERE pilot_name = 'Ivan';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT pilot_name,
         hobbies->'home_lib' AS home_lib
    FROM pilot_hobbies;
#+END_SRC

#+RESULTS:
| pilot_name | home_lib |
|------------+----------|
| Petr       | true     |
| Boris      | true     |
| Pavel      | false    |
| Ivan       | false    |
*** Вопрос 35
Изучая приемы работы с типами JSON, можно, как и в случае с массивами,
пользоваться способностью команды ~SELECT~ обходиться без создания таблиц.

Покажем лишь один пример. Добавить новый ключ и соответствующее ему
значения в уже существующий объект можно оператором ~||~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT '{"sports": "hockey"}'::jsonb || '{"trips": 5}'::jsonb;
#+END_SRC

#+RESULTS:
| ?column?                         |
|----------------------------------|
| {"trips": 5, "sports": "hockey"} |

Для работы с типами JSON предусмотрено много различных функций и операторов,
представленных в разделе документации 9.15 «Функции и операторы JSON».
Самостоятельно ознакомьтесь с ними, используя описанную технологию работы с
командой ~SELECT~.

*TODO* ответить на вопрос
*** Вопрос 36
Объекты JSON в разных строках таблицы могут иметь различные наборы ключей.
Добавьте дополнительный ключ и соответствующее ему значение в JSON-объект
какой-нибудь строки таблицы ~pilots~. Используйте оператор ~||~.

*TODO* ответить на вопрос
*** Вопрос 37
Объекты JSON позволяют не только добавлять в них новые ключи, но также и удалять
из них ключи существующие. Удалите один из ключей из JSON-объекта какой-нибудь
строки таблицы ~pilots~. Соответствующее ему значение будет также удалено, т.к.
без ключа оно не может существовать. Воспользуйтесь оператором ~-~.

*TODO* ответить на вопрос
* Основы языка определения данных
** Значения по умолчанию и ограничения целостности
Итак, начнем созначений по умолчанию. При работе с базами данных нередко
возникают ситуации, когда то или иное значение является типичным для какого-то
конкретного столбца. В команде ~CREATE TABLE~ мы можем отразить этот факт с
помощью ключевого слова ~DEFAULT~: src_sql[:exports code]{mark numeric(1)
DEFAULT 5, ...}

Теперь перейдем к рассмотрению различных видов *ограничений* (*constraints*).

Первым будето *граничение CHECK*. Для его создания используется ключевое слово
~CHECK~, за которым следует выражение в круглых скобках, содержащее одно или
несколько условий, налагаемых на атрибуты таблицы. Это ограничение бывает двух
видов: уровня атрибута и уровня таблицы. Различие между ними только в
синтаксическом оформлении: в обоих случаях в выражении могут содержаться
обращения не только к одному, но и к нескольким атрибутам таблицы. В первом
случае ограничение ~CHECK~ является частью определения одного конкретного
атрибута, а во втором случае оно записывается как самостоятельный элемент
определения таблицы.

src_sql[:exports code]{term numeric(1) CHECK (term = 1 OR term = 2), ...}

Каждое ограничение имеет имя. Мы можем задать его сами с помощью ключевого слова
~CONSTRAINT~. Если же мы этого не сделаем, тогда СУБД сформирует имя
автоматически. Когда мы задаем имя сами, мы можем выбрать его с учетом сути
налагаемых ограничений, с позиции предметной области. Если же это имя формирует
СУБД, оно будет сформировано «механически», т.к. СУБД не знает ни сути этих
ограничений, ни специфики предметной области.

src_sql[:exports code]{mark numeric(1), CONSTRAINT valid_mark CHECK (mark >= 3
AND mark <= 5), ...}

Следующим видом ограничений, который мы рассмотрим, будет *ограничение NOT
NULL*. Оно означает, что в столбце таблицы, на который наложено это ограничение,
должны обязательно присутствовать какие-либо определенные значения. Оно
функционально эквивалентно ограничению src_sql[:exports code]{CHECK (column_name
IS NOT NULL)}, но в PostgreSQL создание явного ограничения ~NOT NULL~ является
более эффективным подходом.

Еще один вид ограничений — это *ограничение уникальности UNIQUE*. При добавлении
ограничения уникальности автоматически создается индекс на основе B-дерева для
поддержки этого ограничения. Такое ограничение, наложенное на конкретный
столбец, означает, что все значения, содержащиеся в этом столбце в различных
строках таблицы, должны быть уникальными, т.е. не должны повторяться.

src_sql[:exports code]{record_book numeric(5) UNIQUE, ...}

src_sql[:exports code]{record_book numeric(5), CONSTRAINT unique_record_book
UNIQUE (record_book), ...}

Ограничение уникальности может включать в себя и несколько столбцов. В этом
случае уникальной должна быть уже комбинация их значений.

src_sql[:exports code]{doc_ser numeric(4), doc_num numeric(6), CONSTRAINT
unique_passport UNIQUE (doc_ser, doc_num), ...}

Переходим к *первичным ключам*. Как мы уже говорили ранее, этот ключ является
уникальным идентификатором строк в таблице. Ключ может быть как простым, т.е.
включать только один атрибут, так и составным, т.е. включать более одного
атрибута. При этом в отличие от уникального ключа, определяемого с помощью
*ограничения UNIQUE*, атрибуты, входящие в состав первичного ключа, не могут
иметь значений ~NULL~. Первичный ключ является частью метаданных, его наличие
позволяет другим таблицам использовать его в качестве уникального идентификатора
строк в данной таблице. Это удобно, например, при создании внешних ключей. При
добавлении первичного ключа автоматически создается индекс на основе B-дерева
для поддержки этого ограничения. В таблице может быть любое число ограничений
~UNIQUE~, дополненных ограничением ~NOT NULL~, но первичный ключ может быть
только один.

src_sql[:exports code]{record_book numeric(5) PRIMARY KEY, ...}

А можно сделать это и в виде отдельного ограничения:

src_sql[:exports code]{record_book numeric(5), PRIMARY KEY (record_book), ...}

В случае создания составного первичного ключа имена столбцов, входящих в его
состав, перечисляются в выражении ~PRIMARY KEY~ через запятую: src_sql[:exports
code]{PRIMARY KEY (column1, column2, ...), ...}

Завершаем наш обзор различных видов ограничений рассмотрением такого важного
понятия, как *внешний ключ* (*foreign key*). Внешние ключи являются средством
поддержания так называемой *ссылочной целостности* (*referential integrity*)
между связанными таблицами. Таблица «Успеваемость» будет *ссылающейся*
(*referencing*), а таблица «Студенты» — *ссылочной* (*referenced*). Обратите
внимание, что внешний ключ ссылающейся таблицы ссылается на первичный ключ
ссылочной таблицы. Допускается ссылка и на уникальный ключ, не являющийся
первичным. В данном контексте для описания отношений между таблицами можно
сказать, что таблица ~students~ является *главной*,а таблица ~progress~ —
*подчиненной*.

src_sql[:exports code]{record_book numeric(5) REFERENCES students (record_book),
...}

Поскольку внешний ключ в нашем примере ссылается на первичный ключ, можно
использовать сокращенную форму записи этого ограничения, не указывая список
атрибутов:

src_sql[:exports code]{record_book numeric(5) REFERENCES students, ...}

Можно определить внешний ключ и в форме ограничения уровня таблицы:

src_sql[:exports code]{record_book numeric(5), FOREIGN KEY (record_boook)
REFERENCES students (record_book), ...}

Конечно, число атрибутов и их типы данных во внешнем ключе ссылающейся таблицы и
в первичном ключе ссылочной таблицы должны быть согласованы. Ограничению
внешнего ключа можно присвоить наименование, как и любому другому ограничению, с
помощью ключевого слова ~CONSTRAINT~.

При наличии связей между таблицами, организованных с помощью внешних ключей,
необходимо придерживаться определенной политики при выполнении операций удаления
и обновления строк в ссылочных таблицах — тех, на которые ссылаются другие
таблицы.

Возможны несколько вариантов.
1. Удаление связанных строк. Эта операция называется *каскадным удалением*, и
   для ее реализации в определение внешнего ключа добавляются ключевые слова
   src_sql[:exports code]{ON DELETE CASCADE}.
2. Запрет удаления строки из таблицы. Для реализации такой политики в
   определение внешнего ключа добавляются ключевые слова ~ON DELETE RESTRICT~
   или ~ON DELETE NO ACTION~. Если в определении внешнего ключа не предписано
   конкретное действие, то по умолчанию используется ~NO ACTION~. Отличие между
   этими двумя вариантами лишь в том, что при использовании ~NO ACTION~ можно
   отложить проверку выполнения ограничения на более поздний срок в рамках
   транзакции, а в случае ~RESTRICT~ проверка выполняется немедленно.
3. Присваивание атрибутам внешнего ключа в строках таблицы значения ~NULL~ - ~ON
   DELETE SET NULL~. Для реализации этого подхода необходимо, чтобы на атрибуты
   внешнего ключа не было наложено ограничение ~NOT NULL~.
4. Присваивание атрибутам внешнего ключа значения по умолчанию (~DEFAULT~), если
   оно, конечно, было предписано при создании таблицы. Оформляется этот вариант
   так ~ON DELETE SET DEFAULT~. Важно учитывать, что если в ссылочной таблице
   нет строки с тем же значением ключевого атрибута, которое было предписано во
   фразе ~DEFAULT~ при создании ссылающейся таблицы, то будет иметь место
   нарушение ограничения ссылочной целостности и операция удаления не будет
   выполнена.

При выполнении операции ~UPDATE~ используются эти же варианты подходов
поотношению к обеспечению ссылочной целостности. Аналогом каскадного удаления
является каскадное обновление: ~ON UPDATE CASCADE~.
** Модификация таблиц
Модифицировать таблицы приходится по различным причинам. В этом случае на помощь
приходит команда ~ALTER TABLE~.

Она предусматривает, наверное, все ситуации, которые могут возникнуть в реальной
работе. Например, может возникнуть необходимость добавить новый столбец в
таблицу — команда ~ALTER TABLE~ имеет для этого фразу ~ADD COLUMN~. Возможна и
обратная ситуация, когда нужно удалить столбец из таблицы — для этого есть фраза
~DROP COLUMN~. Если нужно добавить ограничение, то помогут фразы ~ADD CHECK~ и
~ADD CONSTRAINT~. Если потребовался внешний ключ, то можно добавить и его.

Предположим, что нам понадобилось иметь в базе данных сведения о крейсерской
скорости полета всех моделей самолетов, которые эксплуатируются в нашей
авиакомпании.

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE airports
    ADD COLUMN speed integer NOT NULL CHECK (speed >= 300);

  -- аналогично трем следующим командам
  ALTER TABLE aircrafts ADD COLUMN speed integer;
  ALTER TABLE aircrafts ALTER COLUMN speed SET NOT NULL;
  ALTER TABLE aircrafts ADD CHECK (speed >= 300);
#+END_SRC

Если необходимость наличия того или иного ограничения отпадет, его можно
удалить:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE aircrafts ALTER COLUMN speed DROP NOT NULL;
  ALTER TABLE aircrafts DROP CONSTRAINT aircrafts_speed_check;
#+END_SRC

Если мы решим не усложнять нашу базу данных дополнительной информацией, то можем
удалить и столбец. Конечно, вовсе не обязательно предварительно удалять
ограничения, наложенные на этот столбец.

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE aircrafts DROP COLUMN speed;
#+END_SRC

Еще одна полезная возможность команды ~ALTER TABLE~ — изменение типа данных для
какого-либо столбца:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE airports
    ALTER COLUMN longitude SET DATA TYPE numeric(5, 2),
    ALTER COLUMN latitude  SET DATA TYPE numeric(5, 2);
#+END_SRC

Но если исходный и целевой типы данных относятся к разным группам, тогда
потребуются некоторые дополнительные усилия с нашей стороны. Для реализации
такой задачи служит фраза ~USING~ команды ~ALTER TABLE~.

#+BEGIN_SRC sql :engine postgres :eval no
   ALTER TABLE seats
     -- в таблице есть ограничение, которое завязано на строковый тип,
     -- поэтому его нужно удалать
     DROP CONSTRAINT seats_fare_conditions_check,
     ALTER COLUMN fare_conditions SET DATA TYPE integer
       USING ( CASE WHEN fare_conditions = 'Economy'  THEN 1
                    WHEN fare_conditions = 'Business' THEN 2
                    ELSE 3 END
       );
#+END_SRC

Внешний ключ можно добавить такой командой:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE seats
    ADD FOREIGN KEY (fare_conditions) REFERENCES fare_conditions (fare_conditions_code);
#+END_SRC

А столбец переименовать такой:

#+BEGIN_SRC sql :engine postgres :eval no
   ALTER TABLE seats
  RENAME COLUMN fare_conditions TO fare_conditions_code;
#+END_SRC

А ограничение можно переименовать вот так:

#+BEGIN_SRC sql :engine postgres :eval no
   ALTER TABLE seats
  RENAME CONSTRAINT seats_fare_conditions_fkey TO seats_fare_conditions_code_fkey;
#+END_SRC

Добавить ограничение уникальности по столбцу возможно так:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE fare_conditions ADD UNIQUE (fare_conditions_name);
#+END_SRC
** Представления
Чтобы избежать необходимости многократного формирования сложных запросов, можно
использовать так называемые *представления* (*views*). Если речь идет о выборке
данных, то представления практически неотличимы от таблиц с точки зрения
обращения к ним в командах ~SELECT~. В отличие от таблиц, представления не
содержат данных. При каждом обращении к представлению в команде ~SELECT~ данные
выбираются из таблиц, на основе которых это представление создано.

Давайте создадим простое представление.

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE VIEW seats_by_fare_cond (code, fare_cond, num_seats)
    AS
    SELECT aircraft_code,
           fare_conditions,
           count(*)
      FROM seats
     GROUP BY aircraft_code, fare_conditions
     ORDER BY aircraft_code, fare_conditions;
#+END_SRC

СУБД PostgreSQL предлагает свое расширение команды ~CREATE VIEW~, а именно —
фразу ~OR REPLACE~. Если представление уже существует, то можно его не удалять,
а просто заменить новой версией. Однако нужно помнить о том, что при создании
новой версии представления (без явного удаления старой с помощью команды ~DROP
VIEW~) должны оставаться неизменными имена столбцов представления. Если же
выхотите изменить имя хотя бы одного столбца, то сначала нужно удалить
представление с помощью команды ~DROP VIEW~, а уже затем создать его заново.

PostgreSQL предлагает свое расширение — так называемое материализованное
представление. Упрощенный синтаксис команды ~CREATE MATERIALIZED VIEW~,
предназначенной для создания материализованных представлений похож на синтаксис
создания обычного представления.

В момент выполнения команды создания материализованного представления оно
заполняется данными, но только если в команде не было фразы ~WITH NO DATA~. Если
же она была включена в команду, тогда в момент своего создания представление
остается пустым, а для заполнения его данными нужно использовать команду
~REFRESH MATERIALIZED VIEW~.

Материализованное представление очень похоже на обычную таблицу. Однако оно
отличается от таблицы тем, что не только сохраняет данные, но также запоминает
запрос, с помощью которого эти данные были собраны.

Подводя итог раздела, назовем положительные стороны использования представлений.
1. Упрощение разграничения полномочий пользователей на доступ к хранимым данным.
2. Упрощение запросов к базе данных.
3. Снижение зависимости прикладных программ от изменений структуры таблиц базы
   данных.
4. Снижение времени выполнения сложных запросов за счет использования
   материализованных представлений. Одним из недостатков является то, что их
   необходимо своевременно обновлять с помощью команды ~REFRESH~, чтобы они
   содержали актуальные данные.
** Схемы базы данных
Схема — это логический фрагмент базы данных, в котором могут содержаться
различные объекты: таблицы, представления, индексы и др. В базе данных
обязательно есть хотя бы одна схема. При создании базы данных в ней
автоматически создается схема с именем ~public~.

В каждой базе данных может содержаться более одной схемы. Их имена должны быть
уникальными в пределах конкретной базы данных. Имена объектов базы данных
(таблиц, представлений, последовательностей и др.) должны быть уникальными в
пределах конкретной схемы, но в разных схемах имена объектов могут повторяться.
Таким образом, можно сказать, что схема образует так называемое *пространство
имен*.

Если в базе данных создано более одной схемы, то доступ к объектам, содержащимся
в конкретной схеме, можно организовать разными способами. Первый заключаетсяв
том, чтобы имена объектов предварять именем схемы.

Другой способ заключается в том, чтобы одну из схем сделать текущей. Среди
параметров времени исполнения, которые предусмотрены в конфигурации сервера
PostgreSQL, есть параметр ~search_path~. Он содержит имена схем, которые
PostgreSQL просматривает при поиске конкретного объекта базы данных, когда имя
схемы в команде не указано. Посмотреть значение этого параметра можно с помощью
команды ~SHOW search_path;~.

Чтобы изменить порядок просмотра схем при поиске объектов в базе данных, нужно
воспользоваться командой ~SET search_path = public, ...;~. При этом первой в
списке схем следует указать именно ту, которую СУБД должна просматривать первой.
Эта схема и станет текущей. Конечно, такой список может состоять и всего из
одной схемы.

При создании объектов базы данных, например таблиц, необходимо учитывать
следующее: если имя схемы в команде не указано, то объект будет создан в текущей
схеме. Если же вы хотите создать объект в конкретной схеме, которая не является
текущей, то нужно указать ее имя перед именем создаваемого объекта, разделив их
точкой.
** Контрольные вопросы и задания
*** Вопрос 1
При использовании значений по умолчанию с ключевым словом ~DEFAULT~ возможны и
ситуации, когда типичным будет не конкретное значение данных, а способ его
получения. Например, если мы захотим фиксировать в каждой строке таблицы
«Студенты» имя пользователя базы данных, добавившего эту строку в таблицу, тогда
необходимо в определение таблицы добавить еще один столбец. Этот столбец по
умолчанию будет получать значение, возвращаемое функцией ~current_user~.

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),
    who_adds_row text DEFAULT current_user, -- добавленный столбец
    PRIMARY KEY (record_book)
  );
#+END_SRC

Эта функция — ~current_user~ — будет вызываться не при создании таблицы, а при
вставке каждой строки. При этом в команде ~INSERT~ не требуется указывать
значение для столбца ~who_adds_row~, поскольку функция ~current_user~ будет
вызываться самой СУБД PostgreSQL:

#+BEGIN_SRC sql :engine postgres :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);
#+END_SRC

Давайте пойдем дальше и пожелаем фиксировать не только имя пользователя базы
данных, добавившего строку в таблицу, но также и момент времени, когда это было
сделано.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE TABLE students(
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),
    who_adds_row text DEFAULT current_user,
    inserted_at timestamptz DEFAULT current_timestamp,
    PRIMARY KEY (record_book)
  );

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);
#+END_SRC

#+RESULTS:
| CREATE TABLE |
|--------------|
| INSERT 0 1   |

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num | who_adds_row | inserted_at                   |
|-------------+----------------------+---------+---------+--------------+-------------------------------|
|       12300 | Иванов Иван Иванович |     402 |  543281 | asakura      | 2021-04-15 18:25:37.350046+02 |
*** Вопрос 2
Посмотрите, какие ограничения уже наложены на атрибуты таблицы ~progress~.
Воспользуйтесь командой ~\d~ утилиты psql. А теперь предложите для этой таблицы
ограничение уровня таблицы.

В качестве примера рассмотрим такой вариант. Добавьте в таблицу ~progress~ еще
один атрибут — «Форма проверки знаний» (~test_form~), который может принимать
только два значения: «экзамен» или «зачет». Тогда набор допустимых значений
атрибута ~mark~ будет зависеть от того, экзамен или зачет предусмотрены по
данной дисциплине. Если предусмотрен экзамен, тогда допускаются значения 3, 4,
5, если зачет — тогда 0 (не зачтено) или 1 (зачтено).

Не забудьте, что значения ~NULL~ для атрибутов ~test_form~ и ~mark~ не
допускаются.

Новое ограничение может быть таким:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE progress
    ADD CHECK (
      ( test_form = 'экзамен' AND mark IN (3, 4, 5) )
      OR
      ( test_form = 'зачет'   AND mark IN (0, 1) )
    );
#+END_SRC

Проверьте, как будет работать новое ограничение в модифицированной таблице
~progress~. Для этого выполните команды ~INSERT~, как удовлетворяющие
ограничению, так и нарушающие его.

В таблице уже было ограничение на допустимые значения атрибута ~mark~. Как вы
думаете, не будет ли оно конфликтовать с новым ограничением? Проверьте эту
гипотезу. Если ограничения конфликтуют, тогда удалите старое ограничение и снова
попробуйте добавить строки в таблицу.

Подумайте, какое еще ограничение уровня таблицы можно предложить для этой
таблицы?

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :eval no
  CREATE TABLE IF NOT EXISTS progress (
    record_book numeric(5) NOT NULL,
    subject text NOT NULL,
    acad_year text NOT NULL,
    term numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5
  );

  ALTER TABLE progress
    ADD COLUMN test_form text NOT NULL;

  ALTER TABLE progress
    ADD CHECK (
      ( test_form = 'экзамен' AND mark IN (3, 4, 5) )
      OR
      ( test_form = 'зачет'   AND mark IN (0, 1) )
    );
#+END_SRC

#+RESULTS:
: CREATE TABLE
: ALTER TABLE
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :eval no
  INSERT INTO progress (record_book, subject, acad_year, term, mark, test_form)
    VALUES (12300, 'DBA', 'first', 1, 5, 'экзамен');
#+END_SRC

#+RESULTS:
: INSERT 0 1

Да, конфликтует, нужно удалить:

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE progress
    DROP CONSTRAINT progress_mark_check;

  INSERT INTO progress (record_book, subject, acad_year, term, mark, test_form)
    VALUES (12300, 'DBA', 'first', 1, 1, 'зачет');
#+END_SRC

#+RESULTS:
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark | test_form |
|-------------+---------+-----------+------+------+-----------|
|       12300 | DBA     | first     |    1 |    5 | экзамен   |
|       12300 | DBA     | first     |    1 |    1 | зачет     |
*** Вопрос 3
В определении таблицы ~progress~ на атрибуты ~term~ и ~mark~ наложены как
ограничения ~CHECK~, так и ограничение ~NOT NULL~. Возникает вопрос: не является
ли ограничение ~NOT NULL~ избыточным? Ведь в ограничении ~CHECK~ явно указаны
допустимые значения.

Проверьте гипотезу об избыточности ограничения ~NOT NULL~ в данном случае. Для
этого модифицируйте таблицу, убрав ограничение ~NOT NULL~, и попробуйте добавить
в нее строку с отсутствующим значением атрибута ~term~ (или ~mark~).

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :eval no
  ALTER TABLE progress ALTER COLUMN term DROP NOT NULL;

  INSERT INTO progress (record_book, subject, acad_year, mark, test_form)
    VALUES (12300, 'DBA', 'first', 1, 'зачет');
#+END_SRC

#+RESULTS:
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

Ограничение ~NOT NULL~ не было избыточным, так как ограничение явно не проверяло
на ~NULL~.

#+RESULTS:
| record_book | subject | acad_year | term | mark | test_form |
|-------------+---------+-----------+------+------+-----------|
|       12300 | DBA     | first     |    1 |    5 | экзамен   |
|       12300 | DBA     | first     |    1 |    1 | зачет     |
|       12300 | DBA     | first     |      |    1 | зачет     |
*** Вопрос 4
В определении таблицы ~progress~ для атрибута ~mark~ не только задано
ограничение ~CHECK~, но и установлено значение по умолчанию с помощью ключевого
слова ~DEFAULT~:

#+BEGIN_SRC sql :engine postgres :eval no
  ...
  mark numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,
  ...
#+END_SRC

Как вы думаете, что будет, если в ограничении ~DEFAULT~ мы «случайно» допустим
ошибку, написав ~DEFAULT 6~? Если в команде ~INSERT~ не указать значение для
атрибута ~mark~, то на каком этапе эта ошибка будет выявлена: уже на этапе
создания таблицы или только при вставке строки в нее? Вот эта команда может быть
вам полезной для проверки гипотезы, посколькув ней отсутствует передаваемое
значение для атрибута ~mark~:

#+BEGIN_SRC sql :engine postgres :eval no
  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);
#+END_SRC

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS progress;

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 6
  );
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);
#+END_SRC

#+RESULTS:
: ERROR:  new row for relation "progress" violates check constraint "progress_mark_check"
: DETAIL:  Failing row contains (12300, Физика, 2016/2017, 1, 6).

Ошибка будет выявлена на этапе вставки строки в таблицу.
*** Вопрос 5
В стандарте SQL сказано, что при наличии ограничения уникальности, включающего
один или более столбцов, все же возможны повторяющиеся значения этих столбцов в
разных строках, но лишь в том случае, если это значения ~NULL~. PostgreSQL
придерживается такого же подхода.

Модифицируйте определение таблицы ~students~, добавив ограничение уникальности
по двум столбцам: ~doc_ser~ и ~doc_num~. А затем проверьте выше приведенное
утверждение, добавив в таблицу не только строки, содержащие конкретные значения
этих двух столбцов, но также и по две строки, имеющие следующие свойства:
- одинаковые значения столбца ~doc_ser~ и ~NULL~-значения столбца ~doc_num~;
- ~NULL~-значения столбца ~doc_num~ и столбца ~doc_ser~.

Подобные вещи возможны, так как ~NULL~-значения не считаются совпадающими. Это
можно проверить с помощью команды: src_sql[:exports code]{SELECT (null =
null);}. Она даст пустой результат (т.е. ~NULL~).

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE IF EXISTS students;

  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),
    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );
#+END_SRC

#+RESULTS:
: DROP TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12301, 'Иванов Иван Иванович', 0402, NULL);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12302, 'Иванов Иван Иванович', 0402, NULL);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12303, 'Иванов Иван Иванович', NULL, NULL);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12304, 'Иванов Иван Иванович', NULL, NULL);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num |
|-------------+----------------------+---------+---------|
|       12300 | Иванов Иван Иванович |     402 |  543281 |
|       12301 | Иванов Иван Иванович |     402 |         |
|       12302 | Иванов Иван Иванович |     402 |         |
|       12303 | Иванов Иван Иванович |         |         |
|       12304 | Иванов Иван Иванович |         |         |
*** Вопрос 6
Модифицируйте определения таблиц ~students~ и ~progress~. В таблице ~students~ в
качестве первичного ключа назначьте комбинацию атрибутов ~doc_ser~ и ~doc_num~,
а в таблице ~progress~ соответствующим образом измените определение внешнего
ключа.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE students(
    record_book numeric(5) NOT NULL UNIQUE,
    name        text       NOT NULL,
    doc_ser     numeric(4),
    doc_num     numeric(6),

    PRIMARY KEY (doc_ser, doc_num)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Обратите внимание, что для атрибутов ~doc_ser~ и ~doc_num~ можно не указывать
ограничение ~NOT NULL~: они входят в состав первичного ключа, а в нем
~NULL~-значения не допускаются, поэтому ограничение ~NOT NULL~ фактически
подразумевается при включении атрибута в состав первичного ключа.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE progress(
    doc_ser   numeric(4),
    doc_num   numeric(6),
    subject   text       NOT NULL,
    acad_year text       NOT NULL,
    term      numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark      numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,

    FOREIGN KEY (doc_ser, doc_num)
      REFERENCES students (doc_ser, doc_num)
      ON DELETE CASCADE
      ON UPDATE CASCADE
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

Теперь и первичный, и внешний ключи — составные. Проверьте их действие, добавив
несколько строк в каждую таблицу.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d students
#+END_SRC

#+RESULTS:
#+begin_example
                   Table "public.students"
   Column    |     Type     | Collation | Nullable | Default
-------------+--------------+-----------+----------+---------
 record_book | numeric(5,0) |           | not null |
 name        | text         |           | not null |
 doc_ser     | numeric(4,0) |           | not null |
 doc_num     | numeric(6,0) |           | not null |
Indexes:
    "students_pkey" PRIMARY KEY, btree (doc_ser, doc_num)
    "students_record_book_key" UNIQUE CONSTRAINT, btree (record_book)
Referenced by:
    TABLE "progress" CONSTRAINT "progress_doc_ser_doc_num_fkey" FOREIGN KEY (doc_ser, doc_num) REFERENCES students(doc_ser, doc_num) ON UPDATE CASCADE ON DELETE CASCADE

#+end_example

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d progress
#+END_SRC

#+RESULTS:
#+begin_example
                  Table "public.progress"
  Column   |     Type     | Collation | Nullable | Default
-----------+--------------+-----------+----------+---------
 doc_ser   | numeric(4,0) |           |          |
 doc_num   | numeric(6,0) |           |          |
 subject   | text         |           | not null |
 acad_year | text         |           | not null |
 term      | numeric(1,0) |           | not null |
 mark      | numeric(1,0) |           | not null | 5
Check constraints:
    "progress_mark_check" CHECK (mark >= 3::numeric AND mark <= 5::numeric)
    "progress_term_check" CHECK (term = 1::numeric OR term = 2::numeric)
Foreign-key constraints:
    "progress_doc_ser_doc_num_fkey" FOREIGN KEY (doc_ser, doc_num) REFERENCES students(doc_ser, doc_num) ON UPDATE CASCADE ON DELETE CASCADE

#+end_example

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (doc_ser, doc_num, subject, acad_year, term)
    VALUES (0402, 543281, 'Физика', '2016/2017', 1);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num |
|-------------+----------------------+---------+---------|
|       12300 | Иванов Иван Иванович |     402 |  543281 |
*** Вопрос 7
Модифицируйте определение таблицы ~progress~, а если потребуется, то и
определение таблицы ~students~, чтобы изучить все варианты реагирования СУБД на
обновление строк в ссылочной таблице, в данном случае — ~students~.
Последовательно изменяйте определение внешнего ключа таблицы ~progress~,
испробовав варианты ~ON UPDATE CASCADE~, ~ONUPDATE RESTRICT~, ~ON UPDATE SET
NULL~ и ~ON UPDATE SET DEFAULT~. Для получения информативной картины введите
несколько строк в обе таблицы, а затем выполняйте операцию ~UPDATE~, подбирая
значения ключевых атрибутов таким образом, чтобы вызвать ожидаемую реакцию СУБД.

Учтите, что при использовании фразы ~ON UPDATE SET DEFAULT~ необходимо, чтобы,
во-первых, с помощью ключевого слова ~DEFAULT~ было установлено значение по
умолчанию для атрибута внешнего ключа в ссылающейся таблице, а во-вторых, это
значение по умолчанию все равно должно присутствовать в одной из строк ссылочной
таблицы. Как вы считаете, с учетом сказанного, возможно ли использование ~ON
UPDATE SET DEFAULT~ в нашем случае?

Попробуйте обосновать или, наоборот, опровергнуть целесообразность использования
каждой из этих политик — ~CASCADE~, ~RESTRICT~, ~SET NULL~ и ~SETDEFAULT~ — при
выполнении операции ~UPDATE~ в реальной информационной системе, предназначенной
для учета успеваемости студентов.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE progress;
  DROP TABLE students;

  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5
  );
#+END_SRC

#+RESULTS:
: DROP TABLE
: DROP TABLE
: CREATE TABLE
: CREATE TABLE

*ON DELETE NO ACTION*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE NO ACTION;

  DELETE FROM students;
#+END_SRC

#+RESULTS:
: DELETE 0
: DELETE 0
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE

: ERROR:  update or delete on table "students" violates foreign key constraint "progress_record_book_fkey" on table "progress"
: DETAIL:  Key (record_book)=(12300) is still referenced from table "progress".

*ON DELETE RESTRICT*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;

  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE RESTRICT;

  DELETE FROM students;
#+END_SRC

#+RESULTS:
: ALTER TABLE
: DELETE 1
: DELETE 1
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE

: ERROR:  update or delete on table "students" violates foreign key constraint "progress_record_book_fkey" on table "progress"
: DETAIL:  Key (record_book)=(12300) is still referenced from table "progress".

*ON DELETE SET DEFAULT*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;

  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (1, 'John Doe', 1, 1);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ALTER COLUMN record_book SET DEFAULT 1;

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE SET DEFAULT;

  DELETE FROM students WHERE record_book != 1;

  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;

  ALTER TABLE progress
    ALTER COLUMN record_book DROP DEFAULT;
#+END_SRC

#+RESULTS:
#+begin_example
ALTER TABLE
DELETE 1
DELETE 1
INSERT 0 1
INSERT 0 1
INSERT 0 1
ALTER TABLE
ALTER TABLE
DELETE 1
ALTER TABLE
ALTER TABLE
#+end_example

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|
|           1 | Физика  | 2016/2017 |    1 |    5 |

*ON DELETE SET NULL*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ALTER COLUMN record_book DROP NOT NULL;

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE SET NULL;

  DELETE FROM students;

  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;
#+END_SRC

#+RESULTS:
: DELETE 1
: DELETE 1
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE
: ALTER TABLE
: DELETE 1
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|
|             | Физика  | 2016/2017 |    1 |    5 |

*ON DELETE CASCADE*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  ALTER TABLE progress
    ALTER COLUMN record_book SET NOT NULL;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON DELETE CASCADE;

  DELETE FROM students;

  ALTER TABLE progress
    DROP CONSTRAINT progress_record_book_fkey;
#+END_SRC

#+RESULTS:
: DELETE 1
: DELETE 0
: ALTER TABLE
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE
: DELETE 1
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|

*ON UPDATE CASCADE*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM progress;
  DELETE FROM students;

  ALTER TABLE progress
    ALTER COLUMN record_book SET NOT NULL;

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  ALTER TABLE progress
    ADD CONSTRAINT progress_record_book_fkey
    FOREIGN KEY (record_book) REFERENCES students (record_book)
    ON UPDATE CASCADE;

  UPDATE students SET record_book = 1;
#+END_SRC

#+RESULTS:
: DELETE 0
: DELETE 0
: ALTER TABLE
: INSERT 0 1
: INSERT 0 1
: ALTER TABLE
: UPDATE 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject | acad_year | term | mark |
|-------------+---------+-----------+------+------|
|           1 | Физика  | 2016/2017 |    1 |    5 |
*** Вопрос 8
В таблице ~progress~ есть атрибут ~subject~. Это текстовый атрибут. Одинаковые
наименования учебных дисциплин записываются в таблицу ~progress~ многократно.
Создайте еще одну таблицу — ~subjects~, в которой будет два атрибута:
~subject_id~ и ~subject~. Тип данных первого из них будет ~integer~, а второго —
~text~. В качестве первичного ключа будет служить ~subject_id~, а второй атрибут
будет уникальным. Введите в новую таблицу две три строки для различных учебных
дисциплин.

Модифицируйте таблицу ~progress~, заменив атрибут ~subject~ на ~subject_id~. Тип
данных нового атрибута будет ~integer~. Поскольку тип данных изменится, то для
замены первоначальных значений, хранящихся в этом столбце, на новые придется
использовать конструкцию ~USING~ (о ней говорится в тексте главы).

Добавьте в определение таблицы ~progress~ еще один внешний ключ, который будет
ссылаться на таблицу ~subjects~. В составе этого внешнего ключа будет только
один атрибут — ~subject_id~. Мы видим, что таблица может иметь больше одного
внешнего ключа. Таким образом, структура связей в реальной базе данных может
оказаться весьма сложной.

Теперь введите несколько строк и в таблицу ~progress~, учитывая ее связь с новой
таблицей ~subjects~.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,

    FOREIGN KEY (record_book) REFERENCES students (record_book)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE subjects (
    subject_id integer,
    subject    text NOT NULL,

    PRIMARY KEY (subject_id),
    UNIQUE (subject)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  INSERT INTO progress (record_book, subject, acad_year, term)
    VALUES (12300, 'Физика', '2016/2017', 1);

  INSERT INTO subjects (subject_id, subject)
    VALUES (1, 'Физика'),
           (2, 'Математика');
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1
: INSERT 0 2

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval n
  ALTER TABLE progress
    RENAME COLUMN subject TO subject_id;

  ALTER TABLE progress
    ALTER COLUMN subject_id SET DATA TYPE integer
      USING ( CASE WHEN subject_id = 'Физика' THEN 1
                   WHEN subject_id = 'Математика' THEN 2
                   ELSE NULL END
      );
#+END_SRC

#+RESULTS:
: ALTER TABLE
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject_id | acad_year | term | mark |
|-------------+------------+-----------+------+------|
|       12300 |          1 | 2016/2017 |    1 |    5 |

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE progress
    ADD FOREIGN KEY (subject_id) REFERENCES subjects (subject_id);

  INSERT INTO progress (record_book, subject_id, acad_year, term)
    VALUES (12300, 2, '2016/2017', 2);
#+END_SRC

#+RESULTS:
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE progress;
#+END_SRC

#+RESULTS:
| record_book | subject_id | acad_year | term | mark |
|-------------+------------+-----------+------+------|
|       12300 |          1 | 2016/2017 |    1 |    5 |
|       12300 |          2 | 2016/2017 |    2 |    5 |
*** Вопрос 9
В таблице ~students~ есть текстовый атрибут ~name~, на который наложено
ограничение ~NOT NULL~. Как вы думаете, что будет, если при вводе новой строки в
эту таблицу дать атрибуту ~name~ в качестве значения пустую строку? Например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, '', 0402, 543281);
#+END_SRC

Наверное, проектируя эту таблицу, мы хотели бы все же, чтобы пустые строки в
качестве значения атрибута ~name~ не проходили в базу данных? Какое решение вы
можете предложить? Видимо, нужно добавить ограничение ~CHECK~ для столбца
~name~. Если вы еще не изучили команду ~ALTER TABLE~, то удалите таблицу
~students~ и создайте ее заново с учетом нового ограничения, а если вы уже
познакомились с командой ~ALTER TABLE~, то сделайте так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE students ADD CHECK (name <> '');
#+END_SRC

Добавив ограничение, попробуйте теперь вставить в таблицу ~students~ строку
(~row~), в которой значение атрибута ~name~ было бы пустой строкой (~string~).

Давайте продолжим эксперименты и предложим в качестве значения атрибута ~name~
строку, содержащую сначала один пробел, а потом — два пробела.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students VALUES (12346, ' ', 0406, 112233);
  INSERT INTO students VALUES (12347, '  ', 0407, 112234);
#+END_SRC

Для того чтобы «увидеть» эти пробелы в выборке, сделаем так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT *, length(name) FROM students;
#+END_SRC

Оказывается, эти невидимые значения имеют ненулевую длину. Что делать, чтобы не
допустить таких значений-невидимок? Один из способов: возложить проверку таких
ситуаций на прикладную программу. А что можно сделать на уровне определения
таблицы ~students~? Какое ограничение нужно предложить? В разделе 9.4
документации «Строковые функции и операторы» есть функция ~trim~. Попробуйте
воспользоваться ею. Если вы еще не изучили команду ~ALTER TABLE~, то удалите
таблицу ~students~ и создайте ее заново с учетом нового ограничения, а если уже
познакомились с ней, то сделайте так:

src_sql[:exports code]{ALTER TABLE students ADD CHECK (...);}

Есть ли подобные слабые места в таблице ~progress~?

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  CREATE TABLE progress (
    record_book numeric(5) NOT NULL,
    subject     text       NOT NULL,
    acad_year   text       NOT NULL,
    term        numeric(1) NOT NULL CHECK (term = 1 OR term = 2),
    mark        numeric(1) NOT NULL CHECK (mark >= 3 AND mark <= 5) DEFAULT 5,

    FOREIGN KEY (record_book) REFERENCES students (record_book)
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE
: CREATE TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, '', 0402, 543281);
#+END_SRC

#+RESULTS:
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name | doc_ser | doc_num |
|-------------+------+---------+---------|
|       12300 |      |     402 |  543281 |

*ОТВЕТ*: пустая строка не равняятся ~NULL~.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM students;
  ALTER TABLE students ADD CHECK (name <> '');
#+END_SRC

#+RESULTS:
: DELETE 1
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  INSERT INTO students VALUES (12346, ' ', 0406, 112233);
  INSERT INTO students VALUES (12347, '  ', 0407, 112234);
#+END_SRC

#+RESULTS:
: INSERT 0 1
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *, length(name) FROM students;
#+END_SRC

#+RESULTS:
| record_book | name | doc_ser | doc_num | length |
|-------------+------+---------+---------+--------|
|       12346 |      |     406 |  112233 |      1 |
|       12347 |      |     407 |  112234 |      2 |

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DELETE FROM students;
  ALTER TABLE students ADD CHECK (trim(name) <> '');
#+END_SRC

#+RESULTS:
: DELETE 2
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  INSERT INTO students VALUES (12346, ' ', 0406, 112233);
  INSERT INTO students VALUES (12347, '  ', 0407, 112234);
#+END_SRC

#+RESULTS:
: ERROR:  new row for relation "students" violates check constraint "students_name_check1"
: DETAIL:  Failing row contains (12346,  , 406, 112233).

*ОТВЕТ*: В таблице ~progress~ подобные слабые места. Можно защититься так:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval n
  ALTER TABLE progress
    ADD CHECK (trim(subject) <> ''),
    ADD CHECK (trim(acad_year) <> '');
#+END_SRC

#+RESULTS:
: ALTER TABLE
*** Вопрос 10
В таблице ~students~ атрибут ~doc_ser~ имеет числовой тип, однако в сериях таких
документов могут встречаться лидирующие нули, которые в числовых столбцах не
сохраняются. Например, при записи значения серии «0402» первый ноль не
сохранится. Модифицируйте таблицу ~students~, заменив числовой тип данных на
символьный, например, ~character~. Как вы думаете, эта операция пройдет без
затруднений или они все же возможны? Проверьте ваши предположения, выполнив
модификацию.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value vebatim :eval no
  CREATE TABLE students (
    record_book numeric(5) NOT NULL,
    name text NOT NULL,
    doc_ser numeric(4),
    doc_num numeric(6),

    PRIMARY KEY (record_book),
    UNIQUE (doc_ser, doc_num)
  );

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12300, 'Иванов Иван Иванович', 0402, 543281);

  ALTER TABLE students
    ALTER COLUMN doc_ser SET DATA TYPE char(4);

  INSERT INTO students (record_book, name, doc_ser, doc_num)
    VALUES (12301, 'Иванов Иван Иванович', '0402', 543281);
#+END_SRC

#+RESULTS:
: CREATE TABLE
: INSERT 0 1
: ALTER TABLE
: INSERT 0 1

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  TABLE students;
#+END_SRC

#+RESULTS:
| record_book | name                 | doc_ser | doc_num |
|-------------+----------------------+---------+---------|
|       12300 | Иванов Иван Иванович |     402 |  543281 |
|       12301 | Иванов Иван Иванович |    0402 |  543281 |
*** Вопрос 11
В таблице ~flights~ есть ограничение, которое регулирует соотношения значений
фактического времени вылета и фактического времени прилета. Как вы думаете, не
является ли выражение ~actual_arrival IS NOT NULL~ во второй части условного
оператора ~OR~ избыточным?

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE TABLE flights (
    ...
    CHECK ( actual_arrival IS NULL OR
           ( actual_departure IS NOT NULL AND
             actual_arrival IS NOT NULL AND
             actual_arrival > actual_departure
           )
    ),
    ...
#+END_SRC

Проверьте ваши предположения на практике. Для этого сначала удалите существующее
ограничение с помощью команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE flights DROP CONSTRAINT имя-ограничения;
#+END_SRC

Как определить имя этого ограничения? С помощью команды ~\d flights~ получите
описание таблицы ~flights~, а в нем есть названия всех ограничений. Затем
создайте это же ограничение, но в модифицированном виде:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE flights
    ADD CHECK ( actual_arrival IS NULL OR
               ( actual_departure IS NOT NULL AND
                 actual_arrival > actual_departure
               )
    );
#+END_SRC

Попробуйте добавить в таблицу ~flights~ две-три строки, подбирая такие значения
атрибутов ~actual_departure~ и ~actual_arrival~, чтобы проверить все возможные
исходы этих проверок. Конечно, вместо добавления новых строк можно
модифицировать одну и ту же строку с помощью команды ~UPDATE~.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d flights
#+END_SRC

#+RESULTS:
#+begin_example
                               Table "public.flights"
         Column         |           Type           | Collation | Nullable | Default
------------------------+--------------------------+-----------+----------+---------
 flight_id              | integer                  |           | not null |
 flight_no              | character(6)             |           | not null |
 scheduled_departure    | timestamp with time zone |           | not null |
 scheduled_arrival      | timestamp with time zone |           | not null |
 departure_airport_code | character(3)             |           | not null |
 arrival_airport_code   | character(3)             |           | not null |
 status                 | character varying(20)    |           | not null |
 aircraft_code          | character(3)             |           | not null |
 actual_departure       | timestamp with time zone |           |          |
 actual_arrival         | timestamp with time zone |           |          |
Indexes:
    "flights_pkey" PRIMARY KEY, btree (flight_id)
    "flights_flight_no_scheduled_departure_index" UNIQUE CONSTRAINT, btree (flight_no, scheduled_departure)
Check constraints:
    "flights_actual_arrival_time_check" CHECK (actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure)
    "flights_arrival_time_check" CHECK (scheduled_arrival > scheduled_departure)
    "flights_status_check" CHECK (status::text = ANY (ARRAY['On Time'::text, 'Delayed'::text, 'Departed'::text, 'Arrived'::text, 'Scheduled'::text, 'Cancelled'::text]))
Foreign-key constraints:
    "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    "flights_arrival_airport_code_fkey" FOREIGN KEY (arrival_airport_code) REFERENCES airports(airport_code)
    "flights_departure_airport_code_fkey" FOREIGN KEY (departure_airport_code) REFERENCES airports(airport_code)
Referenced by:
    TABLE "ticket_flights" CONSTRAINT "ticket_flights_flight_id_fkey" FOREIGN KEY (flight_id) REFERENCES flights(flight_id)

#+end_example

*TODO* ответить на вопрос
*** Вопрос 12
Команда ~ALTER TABLE~ позволяет переименовать таблицу. Например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE table_name RENAME TO new_table_name;
#+END_SRC

Поскольку в командах создания таблиц базы данных «Авиаперевозки» мы не указывали
имена ограничений для первичных и внешних ключей, то их имена были сформированы
автоматически самой СУБД. Как вы думаете, получили ли эти ограничения новые
имена после переименования таблицы?

Проверьте ваши предположения, выполнив такую операцию с одной из таблиц базы
данных «Авиаперевозки», имеющих внешние ключи.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval n
  ALTER TABLE flights RENAME TO полёты;
#+END_SRC

#+RESULTS:
: ALTER TABLE

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d полёты
#+END_SRC

#+RESULTS:
#+begin_example
                               Table "public.полёты"
         Column         |           Type           | Collation | Nullable | Default
------------------------+--------------------------+-----------+----------+---------
 flight_id              | integer                  |           | not null |
 flight_no              | character(6)             |           | not null |
 scheduled_departure    | timestamp with time zone |           | not null |
 scheduled_arrival      | timestamp with time zone |           | not null |
 departure_airport_code | character(3)             |           | not null |
 arrival_airport_code   | character(3)             |           | not null |
 status                 | character varying(20)    |           | not null |
 aircraft_code          | character(3)             |           | not null |
 actual_departure       | timestamp with time zone |           |          |
 actual_arrival         | timestamp with time zone |           |          |
Indexes:
    "flights_pkey" PRIMARY KEY, btree (flight_id)
    "flights_flight_no_scheduled_departure_index" UNIQUE CONSTRAINT, btree (flight_no, scheduled_departure)
Check constraints:
    "flights_actual_arrival_time_check" CHECK (actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure)
    "flights_arrival_time_check" CHECK (scheduled_arrival > scheduled_departure)
    "flights_status_check" CHECK (status::text = ANY (ARRAY['On Time'::text, 'Delayed'::text, 'Departed'::text, 'Arrived'::text, 'Scheduled'::text, 'Cancelled'::text]))
Foreign-key constraints:
    "flights_aircraft_code_fkey" FOREIGN KEY (aircraft_code) REFERENCES aircrafts(aircraft_code)
    "flights_arrival_airport_code_fkey" FOREIGN KEY (arrival_airport_code) REFERENCES airports(airport_code)
    "flights_departure_airport_code_fkey" FOREIGN KEY (departure_airport_code) REFERENCES airports(airport_code)
Referenced by:
    TABLE "ticket_flights" CONSTRAINT "ticket_flights_flight_id_fkey" FOREIGN KEY (flight_id) REFERENCES "полёты"(flight_id)
#+end_example

Ограничения новые имена не получат. Их нужно переименовать вручную.
*** Вопрос 13
И представление ~flights_v~, и материализованное представление ~routes~
построены на основе таблиц ~flights~ и ~airports~. Логично предположить, что при
каскадном удалении, например, таблицы «Аэропорты», представление «Рейсы» будет
также удалено, поскольку при удалении базовой таблицы этому представлению просто
неоткуда будет брать данные.

А что вы можете предположить насчет материализованного представления «Маршруты»:
будет ли оно также удалено или нет? Ведь оно уже содержит данные, в отличие от
обычного представления. Так ли, условно говоря, сильна его связь с таблицами, на
основе которых оно сконструировано?

Проведите необходимые эксперименты, начав с команды

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE airports;
#+END_SRC

Если вам потребуется восстановить все объекты базы данных, то вы всегда сможете
воспользоваться файлом ~demo_small.sql~ и просто повторить процедуру
развертывания учебной базы данных, которая описана в главе 2. Поэтому смело
экспериментируйте с таблицами и представлениями.

*ОТВЕТ*

#+BEGIN_SRC sql :engine postgres :results value verbatim :exports both :eval no
  DROP TABLE airports;
#+END_SRC

#+RESULTS:
: ERROR:  cannot drop table airports because other objects depend on it
: DETAIL:  view flights_v depends on table airports
: view routes depends on table airports
: constraint flights_arrival_airport_code_fkey on table "полёты" depends on table airports
: constraint flights_departure_airport_code_fkey on table "полёты" depends on table airports
: HINT:  Use DROP ... CASCADE to drop the dependent objects too.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  DROP TABLE airports CASCADE;
#+END_SRC

#+RESULTS:
: DROP TABLE

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  \a
  \d routes
#+END_SRC

#+RESULTS:
: error: Did not find any relation named "routes".
*** Вопрос 14
Представления (~views~) могут быть обновляемыми. Это значит, что можно с помощью
команд ~INSERT~, ~UPDATE~ и ~DELETE~, применяемых к представлению, внести
изменения в таблицу, лежащую в основе этого представления.

Самостоятельно ознакомьтесь с этим вопросом с помощью документации (см. описание
команды ~CREATE VIEW~) и, создав простое представление над одной из таблиц базы
данных «Авиаперевозки», выполните несколько команд с целью внесения изменений в
эту таблицу.

*TODO* ответить на вопрос
*** Вопрос 15
Определение таблицы можно изменить с помощью команды ~ALTER TABLE~. Аналогичные
команды существуют и для изменения представлений и материализованных
представлений: ~ALTER VIEW~ и ~ALTER MATERIALIZED VIEW~. Самостоятельно
ознакомьтесь с их возможностями с помощью документации.

*TODO* ответить на вопрос
*** Вопрос 16
Как вы думаете, при изменении данных в таблицах, на основе которых
сконструировано материализованное представление, содержимое этого представления
тоже синхронно изменяется или нет?

Если содержимое материализованного представления изменяется синхронно с базовыми
таблицами, то продемонстрируйте это. Если же оно остается неизменным, то
покажите, как его синхронизировать с базовыми таблицами.

*ОТВЕТ*

Требуется ручная инициализация синхронизации следующей командой:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  REFRESH MATERIALIZED VIEW routes;
#+END_SRC
*** Вопрос 17
Представления могут быть, условно говоря, вертикальными и горизонтальными. При
создании вертикального представления в список его столбцов включается лишь часть
столбцов базовой таблицы (таблиц). Например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE VIEW airports_names AS
    SELECT airport_code, airport_name, city
      FROM airports;

  SELECT * FROM airports_names;
#+END_SRC

В горизонтальное представление включаются не все строки базовой таблицы
(таблиц), а производится их отбор с помощью фраз ~WHERE~ или ~HAVING~.

Например:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  CREATE VIEW siberian_airports AS
    SELECT * FROM airports WHERE city = 'Новосибирск' OR city = 'Кемерово';

  SELECT * FROM siberian_airports;
#+END_SRC

Конечно, вполне возможен и смешанный вариант, когда ограничивается как список
столбцов, так и множество строк при создании представления.

Подумайте, какие представления было бы целесообразно создать для нашей базы
данных «Авиаперевозки». Необходимо учесть наличие различных групп пользователей,
например: пилоты, диспетчеры, пассажиры, кассиры.

Создайте представления и проверьте их в работе.

*TODO* ответить на вопрос
*** Вопрос 18
Предположим, что нам понадобилось иметь в базе данных сведения о технических
характеристиках самолетов, эксплуатируемых в авиакомпании. Пусть это будут такие
сведения, как число членов экипажа (пилоты), тип двигателей и их количество.

Следовательно, необходимо добавить новый столбец в таблицу ~aircrafts~. Дадим
ему имя ~specifications~, а в качестве типа данных выберем ~jsonb~. Если
впоследствии потребуется добавить и другие характеристики, то мы сможем это
сделать, не модифицируя определение таблицы.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  ALTER TABLE aircrafts ADD COLUMN specifications jsonb;
#+END_SRC

Добавим сведения для модели самолета /Airbus A320-200/:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  UPDATE aircrafts
     SET specifications = '{ "crew": 2,"engines": { "type": "IAE V2500","num": 2}}'::jsonb
   WHERE aircraft_code = '320';
#+END_SRC

Посмотрим, что получилось:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT model, specifications FROM aircrafts WHERE aircraft_code = '320';
#+END_SRC

Можно посмотреть только сведения о двигателях:

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT model, specifications->'engines' AS engines
    FROM aircrafts
   WHERE aircraft_code = '320';
#+END_SRC

Чтобы получить еще более детальные сведения, например, о типе двигателей, нужно
учитывать, что созданный JSON-объект имеет сложную структуру: он содержит
вложенный JSON-объект. Поэтому нужно использовать оператор ~#>~ для указания
пути доступа к ключу второго уровня.

#+BEGIN_SRC sql :engine postgres :results value verbatim :eval no
  SELECT model, specifications#>'{ engines, type }'
    FROM aircrafts
   WHERE aircraft_code = '320';
#+END_SRC

*Задание*: Подумайте, какие еще таблицы было бы целесообразно дополнить
столбцами типа json/jsonb. Вспомните, что, например, в таблице ~tickets~ уже
есть столбец такого типа — ~contact_data~. Выполните модификации таблиц и
измените в них одну-две строки для проверки правильности ваших решений.

*TODO* ответить на вопрос
* Запросы
** Дополнительные возможности команды SELECT
Начнем с различных условий отбора строк в предложении ~WHERE~. Эти условия могут
конструироваться с использованием следующих операторов сравнения: ~=~, ~<>~,
~>~, ~>=~, ~<~, ~<=~.

Для начала поставим перед собой такую задачу: выбрать все самолеты компании
/Airbus/. В этом нам поможет оператор поиска шаблонов ~LIKE~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE model LIKE 'Airbus%';
#+END_SRC

#+RESULTS:
| aircraft_code | model           | range |
|---------------+-----------------+-------|
|           320 | Airbus A320-200 |  5700 |
|           321 | Airbus A321-200 |  5600 |
|           319 | Airbus A319-100 |  6700 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    where: like(a.model, "Airbus%"),
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], like(a.model, "Airbus%"))
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 19:09:40.292 [debug] QUERY OK source="aircrafts" db=0.6ms idle=214.5ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."model" LIKE 'Airbus%') []
: >>> :
: [
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700}
: ]

Шаблон в операторе ~LIKE~ всегда покрывает всю анализируемую строку. Если по
тому столбцу, к которому применяется оператор ~LIKE~, создан индекс для
ускорения доступа к данным, то при наличии символа ~%~ в начале шаблона этот
индекс использоваться не будет. Символ ~%~ имет специальное значение. Он
соответствует любой последовательности символов, т.е. вместо него могут быть
подставлены любые символы в любом количестве, а может и не быть подставлено ни
одного символа.

Конечно, существует и оператор ~NOT LIKE~. Например, если мы захотим узнать,
какими самолетами, кроме машин компаний /Airbus/ и /Boeing/, располагает наша
авиакомпания, то придется усложнить условие:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT *
    FROM aircrafts
   WHERE model NOT LIKE 'Airbus%'
     AND model NOT LIKE 'Boeing%';
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi Superjet-100 |  3000 |
| CN1           | Cessna 208 Caravan  |  1200 |
| CR2           | Bombardier CRJ-200  |  2700 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    where: not like(a.model, "Airbus%") and not like(a.model, "Boeing%"),
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], not like(a.model, "Airbus%") and not like(a.model, "Boeing%"))
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 19:12:27.019 [debug] QUERY OK source="aircrafts" db=0.9ms idle=1567.3ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (NOT (a0."model" LIKE 'Airbus%') AND NOT (a0."model" LIKE 'Boeing%')) []
: >>> :
: [
:   %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
: ]

Кроме символа ~%~ в шаблоне может использоваться и символ подчеркивания — ~_~,
который соответствует в точности одному любому символу. В качестве примера
найдем в таблице ~airports~ те из них, которые имеют названия длиной 12
символов.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM airports WHERE airport_name LIKE '____________';
#+END_SRC

#+RESULTS:
| airport_code | airport_name | city | coordinates                           | timezone           |
|--------------+--------------+------+---------------------------------------+--------------------|
| URJ          | Uray Airport | Uraj | (64.82669830322266,60.10329818725586) | Asia/Yekaterinburg |
| OSW          | Orsk Airport | Orsk | (58.59560012817383,51.0724983215332)  | Asia/Yekaterinburg |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    where: like(a.airport_name, "____________"),
    select: map(a, [:airport_code, :airport_name, :city])

  # macro example
  Airport
  |> where([a], like(a.airport_name, "____________"))
  |> select([a], map(a, [:airport_code, :airport_name, :city]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 19:15:26.943 [debug] QUERY OK source="airports" db=0.5ms idle=1248.9ms
: SELECT a0."airport_code", a0."airport_name", a0."city" FROM "airports" AS a0 WHERE (a0."airport_name" LIKE '____________') []
: >>> :
: [
:   %{airport_code: "URJ", airport_name: "Uray Airport", city: "Uraj"},
:   %{airport_code: "OSW", airport_name: "Orsk Airport", city: "Orsk"}
: ]

Существует ряд операторов для работы с *регулярными выражениями* POSIX. Эти
операторы имеют больше возможностей, чем оператор ~LIKE~. Для того чтобы
выбрать, например, самолеты компаний /Airbus/ и /Boeing/, можно сделать так:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE model ~ '^(A|Boe)';
#+END_SRC

#+RESULTS:
| aircraft_code | model           | range |
|---------------+-----------------+-------|
|           773 | Boeing 777-300  | 11100 |
|           763 | Boeing 767-300  |  7900 |
|           320 | Airbus A320-200 |  5700 |
|           321 | Airbus A321-200 |  5600 |
|           319 | Airbus A319-100 |  6700 |
|           733 | Boeing 737-300  |  4200 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    where: fragment("? ~ ?", a.model, "^(A|Boe)"),
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], fragment("? ~ ?", a.model, "^(A|Boe)"))
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 19:22:22.195 [debug] QUERY OK source="aircrafts" db=0.6ms idle=1556.2ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."model" ~ '^(A|Boe)') []
: >>> :
: [
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200}
: ]

Оператор ~~~ ищет совпадение с шаблоном с учетом регистра символов. Для
инвертирования смысла оператора ~~~ нужно перед ним добавить знак ~!~. В
качестве примера отыщем модели самолетов, которые не завершаются числом 300.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE model !~ '300$';
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
| SU9           | Sukhoi Superjet-100 |  3000 |
| 320           | Airbus A320-200     |  5700 |
| 321           | Airbus A321-200     |  5600 |
| 319           | Airbus A319-100     |  6700 |
| CN1           | Cessna 208 Caravan  |  1200 |
| CR2           | Bombardier CRJ-200  |  2700 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    where: fragment("? !~ ?", a.model, "300$"),
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], fragment("? !~ ?", a.model, "300$"))
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 19:25:45.382 [debug] QUERY OK source="aircrafts" db=0.3ms idle=1727.9ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."model" !~ '300$') []
: >>> :
: [
:   %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700}
: ]

В качестве замены традиционных операторов сравнения могут использоваться
предикаты сравнения, которые ведут себя так же, как и операторы, но имеют другой
синтаксис.

Давайте ответим на вопрос: какие самолеты имеют дальность полета в диапазоне от
3000 км до 6000 км? Ответ получим с помощью предиката ~BETWEEN~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts WHERE range BETWEEN 3000 AND 6000;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           SU9 | Sukhoi Superjet-100 |  3000 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           733 | Boeing 737-300      |  4200 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    where: fragment("? BETWEEN ? AND ?", a.range, 3000, 6000),
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> where([a], fragment("? BETWEEN ? AND ?", a.range, 3000, 6000))
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 10:51:08.244 [debug] QUERY OK source="aircrafts" db=1.6ms decode=2.9ms queue=4.8ms idle=856.4ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 WHERE (a0."range" BETWEEN 3000 AND 6000) []
: >>> :
: [
:   %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200}
: ]

При выборке данных можно проводить вычисления и получать в результирующей
таблице вычисляемые столбцы. Если мы захотим представить дальность полета не
только в километрах, но и в милях, то нужно вычислить это выражение и для
удобства присвоить новому столбцу псевдоним с помощью ключевого слова ~AS~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, range, range / 1.609 AS miles FROM aircrafts;
#+END_SRC

#+RESULTS:
| model               | range |                 miles |
|---------------------+-------+-----------------------|
| Boeing 777-300      | 11100 | 6898.6948415164698571 |
| Boeing 767-300      |  7900 | 4909.8819142324425109 |
| Sukhoi Superjet-100 |  3000 | 1864.5121193287756370 |
| Airbus A320-200     |  5700 | 3542.5730267246737104 |
| Airbus A321-200     |  5600 | 3480.4226227470478558 |
| Airbus A319-100     |  6700 | 4164.0770665009322561 |
| Boeing 737-300      |  4200 | 2610.3169670602858919 |
| Cessna 208 Caravan  |  1200 |  745.8048477315102548 |
| Bombardier CRJ-200  |  2700 | 1678.0609073958980733 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    select: map(a, [:model, :range]),
    select_merge: %{miles: fragment("? / 1.609", a.range)}

  # marco example
  Aircraft
  |> select([a], map(a, [:model, :range]))
  |> select_merge([a], %{miles: fragment("? / 1.609", a.range)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 10:52:53.985 [debug] QUERY OK source="aircrafts" db=3.0ms idle=610.1ms
: SELECT a0."model", a0."range", a0."range" / 1.609 FROM "aircrafts" AS a0 []
: >>> :
: [
:   %{miles: Decimal.new("6898.6948415164698571"), model: "Boeing 777-300", range: 11100},
:   %{miles: Decimal.new("4909.8819142324425109"), model: "Boeing 767-300", range: 7900},
:   %{miles: Decimal.new("1864.5121193287756370"), model: "Sukhoi Superjet-100", range: 3000},
:   %{miles: Decimal.new("3542.5730267246737104"), model: "Airbus A320-200", range: 5700},
:   %{miles: Decimal.new("3480.4226227470478558"), model: "Airbus A321-200", range: 5600},
:   %{miles: Decimal.new("4164.0770665009322561"), model: "Airbus A319-100", range: 6700},
:   %{miles: Decimal.new("2610.3169670602858919"), model: "Boeing 737-300", range: 4200},
:   %{miles: Decimal.new("745.8048477315102548"), model: "Cessna 208 Caravan", range: 1200},
:   %{miles: Decimal.new("1678.0609073958980733"), model: "Bombardier CRJ-200", range: 2700}
: ]

По всей вероятности, такая высокая точность представления значений в милях не
требуется, поэтому мы можем уменьшить ее до разумного предела в два десятичных
знака:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, range, round(range / 1.609, 2) AS miles FROM aircrafts;
#+END_SRC

#+RESULTS:
| model               | range |   miles |
|---------------------+-------+---------|
| Boeing 777-300      | 11100 | 6898.69 |
| Boeing 767-300      |  7900 | 4909.88 |
| Sukhoi Superjet-100 |  3000 | 1864.51 |
| Airbus A320-200     |  5700 | 3542.57 |
| Airbus A321-200     |  5600 | 3480.42 |
| Airbus A319-100     |  6700 | 4164.08 |
| Boeing 737-300      |  4200 | 2610.32 |
| Cessna 208 Caravan  |  1200 |  745.80 |
| Bombardier CRJ-200  |  2700 | 1678.06 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    select: map(a, [:model, :range]),
    select_merge: %{miles: fragment("round(? / 1.609, 2)", a.range)}

  # macro example
  Aircraft
  |> select([a], map(a, [:model, :range]))
  |> select_merge([a], %{miles: fragment("round(? / 1.609, 2)", a.range)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 10:55:58.879 [debug] QUERY OK source="aircrafts" db=0.4ms idle=1506.2ms
: SELECT a0."model", a0."range", round(a0."range" / 1.609, 2) FROM "aircrafts" AS a0 []
: >>> :
: [
:   %{miles: Decimal.new("6898.69"), model: "Boeing 777-300", range: 11100},
:   %{miles: Decimal.new("4909.88"), model: "Boeing 767-300", range: 7900},
:   %{miles: Decimal.new("1864.51"), model: "Sukhoi Superjet-100", range: 3000},
:   %{miles: Decimal.new("3542.57"), model: "Airbus A320-200", range: 5700},
:   %{miles: Decimal.new("3480.42"), model: "Airbus A321-200", range: 5600},
:   %{miles: Decimal.new("4164.08"), model: "Airbus A319-100", range: 6700},
:   %{miles: Decimal.new("2610.32"), model: "Boeing 737-300", range: 4200},
:   %{miles: Decimal.new("745.80"), model: "Cessna 208 Caravan", range: 1200},
:   %{miles: Decimal.new("1678.06"), model: "Bombardier CRJ-200", range: 2700}
: ]

Вопрос *упорядочевания строк* при выводе решается с помощью ~ORDER BY~: можно
задать не только возрастающий, но также и убывающий порядок сортировки. Если
непринять специальных мер, то СУБД не гарантирует никакого конкретного порядка
строк в результирующей выборке.

Например, если мы захотим разместить самолеты в порядке убывания дальности их
полета, то нужно сделать так:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT * FROM aircrafts ORDER BY range DESC;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | range |
|---------------+---------------------+-------|
|           773 | Boeing 777-300      | 11100 |
|           763 | Boeing 767-300      |  7900 |
|           319 | Airbus A319-100     |  6700 |
|           320 | Airbus A320-200     |  5700 |
|           321 | Airbus A321-200     |  5600 |
|           733 | Boeing 737-300      |  4200 |
|           SU9 | Sukhoi Superjet-100 |  3000 |
|           CR2 | Bombardier CRJ-200  |  2700 |
|           CN1 | Cessna 208 Caravan  |  1200 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    order_by: [desc: a.range],
    select: map(a, [:aircraft_code, :model, :range])

  # macro example
  Aircraft
  |> order_by([a], desc: a.range)
  |> select([a], map(a, [:aircraft_code, :model, :range]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 10:57:56.495 [debug] QUERY OK source="aircrafts" db=1.2ms idle=1121.6ms
: SELECT a0."aircraft_code", a0."model", a0."range" FROM "aircrafts" AS a0 ORDER BY a0."range" DESC []
: >>> :
: [
:   %{aircraft_code: "773", model: "Boeing 777-300", range: 11100},
:   %{aircraft_code: "763", model: "Boeing 767-300", range: 7900},
:   %{aircraft_code: "319", model: "Airbus A319-100", range: 6700},
:   %{aircraft_code: "320", model: "Airbus A320-200", range: 5700},
:   %{aircraft_code: "321", model: "Airbus A321-200", range: 5600},
:   %{aircraft_code: "733", model: "Boeing 737-300", range: 4200},
:   %{aircraft_code: "SU9", model: "Sukhoi Superjet-100", range: 3000},
:   %{aircraft_code: "CR2", model: "Bombardier CRJ-200", range: 2700},
:   %{aircraft_code: "CN1", model: "Cessna 208 Caravan", range: 1200}
: ]

В таблице ~airports~ есть столбец ~timezone~. Давайте посмотрим, в каких
различных часовых поясах располагаются аэропорты. Если сделать традиционную
выборку, то мы получим список значений, среди которых будет много повторяющихся:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT timezone FROM airports;
#+END_SRC

#+RESULTS:
| timezone           |
|--------------------|
| Asia/Yakutsk       |
| Asia/Yakutsk       |
| Asia/Vladivostok   |
| Asia/Kamchatka     |
| Asia/Sakhalin      |
| Asia/Vladivostok   |
| Europe/Moscow      |
| Europe/Kaliningrad |
| Asia/Novokuznetsk  |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Samara      |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Samara      |
| Europe/Moscow      |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Asia/Krasnoyarsk   |
| Asia/Irkutsk       |
| Asia/Krasnoyarsk   |
| Europe/Moscow      |
| Europe/Volgograd   |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Asia/Yekaterinburg |
| Asia/Krasnoyarsk   |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Asia/Yakutsk       |
| Asia/Vladivostok   |
| Asia/Anadyr        |
| Europe/Moscow      |
| Asia/Krasnoyarsk   |
| Asia/Novokuznetsk  |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Europe/Samara      |
| Europe/Moscow      |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Samara      |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Asia/Irkutsk       |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Samara      |
| Asia/Krasnoyarsk   |
| Asia/Yekaterinburg |
| Europe/Moscow      |
| Asia/Krasnoyarsk   |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Moscow      |
| Asia/Yekaterinburg |
| Asia/Yekaterinburg |
| Asia/Novosibirsk   |
| Europe/Moscow      |
| Asia/Omsk          |
| Europe/Moscow      |
| Europe/Moscow      |
| Europe/Volgograd   |
| Asia/Yakutsk       |
| Asia/Magadan       |
| Asia/Chita         |
| Asia/Irkutsk       |
| Asia/Irkutsk       |
| Asia/Irkutsk       |
| Europe/Moscow      |
| Asia/Krasnoyarsk   |
| Asia/Krasnoyarsk   |
| Europe/Moscow      |
| Asia/Yakutsk       |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    select: map(a, [:timezone])

  # macro example
  Airport
  |> select([a], map(a, [:timezone]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 10:59:51.989 [debug] QUERY OK source="airports" db=1.3ms idle=1615.4ms
: SELECT a0."timezone" FROM "airports" AS a0 []
: >>> :
: [
:   %{timezone: "Asia/Yakutsk"},
:   %{timezone: "Asia/Yakutsk"},
:   %{timezone: "Asia/Vladivostok"},
:   %{timezone: "Asia/Kamchatka"},
:   %{timezone: "Asia/Sakhalin"},
:   %{timezone: "Asia/Vladivostok"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Kaliningrad"},
:   %{timezone: "Asia/Novokuznetsk"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Samara"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Samara"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Asia/Krasnoyarsk"},
:   %{timezone: "Asia/Irkutsk"},
:   %{timezone: "Asia/Krasnoyarsk"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Volgograd"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Asia/Krasnoyarsk"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Asia/Yakutsk"},
:   %{timezone: "Asia/Vladivostok"},
:   %{timezone: "Asia/Anadyr"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Asia/Krasnoyarsk"},
:   %{timezone: "Asia/Novokuznetsk"},
:   %{timezone: "Europe/Moscow"},
:   %{...},
:   ...
: ]

Для того чтобы оставить в выборке только неповторяющиеся значения, служит
ключевое слово ~DISTINCT~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  -- столбец, по значениям которого будут упорядочены строки,
  -- указан не с помощью его имени, а с помощью
  -- его порядкового номера в предложении SELECT
  SELECT DISTINCT timezone FROM airports ORDER BY 1;
#+END_SRC

#+RESULTS:
| timezone           |
|--------------------|
| Asia/Anadyr        |
| Asia/Chita         |
| Asia/Irkutsk       |
| Asia/Kamchatka     |
| Asia/Krasnoyarsk   |
| Asia/Magadan       |
| Asia/Novokuznetsk  |
| Asia/Novosibirsk   |
| Asia/Omsk          |
| Asia/Sakhalin      |
| Asia/Vladivostok   |
| Asia/Yakutsk       |
| Asia/Yekaterinburg |
| Europe/Kaliningrad |
| Europe/Moscow      |
| Europe/Samara      |
| Europe/Volgograd   |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    distinct: true,
    order_by: selected_as(:timezone),
    select: %{timezone: selected_as(a.timezone, :timezone)}

  # macro example
  Airport
  |> distinct(true)
  |> order_by(selected_as(:timezone))
  |> select([a], %{timezone: selected_as(a.timezone, :timezone)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 11:02:34.047 [debug] QUERY OK source="airports" db=1.5ms idle=1673.2ms
: SELECT DISTINCT a0."timezone" AS "timezone" FROM "airports" AS a0 ORDER BY "timezone" []
: >>> :
: [
:   %{timezone: "Asia/Anadyr"},
:   %{timezone: "Asia/Chita"},
:   %{timezone: "Asia/Irkutsk"},
:   %{timezone: "Asia/Kamchatka"},
:   %{timezone: "Asia/Krasnoyarsk"},
:   %{timezone: "Asia/Magadan"},
:   %{timezone: "Asia/Novokuznetsk"},
:   %{timezone: "Asia/Novosibirsk"},
:   %{timezone: "Asia/Omsk"},
:   %{timezone: "Asia/Sakhalin"},
:   %{timezone: "Asia/Vladivostok"},
:   %{timezone: "Asia/Yakutsk"},
:   %{timezone: "Asia/Yekaterinburg"},
:   %{timezone: "Europe/Kaliningrad"},
:   %{timezone: "Europe/Moscow"},
:   %{timezone: "Europe/Samara"},
:   %{timezone: "Europe/Volgograd"}
: ]

Если мы поставим задачу найти три самых восточных аэропорта, то для ее решения
подошел бы такой алгоритм: отсортировать строки в таблице по убыванию значений
столбца ~longitude~ и включить в выборку только первые три строки. Для того
чтобы ограничить число строк, включаемых в результирующую выборку, служит
предложение ~LIMIT~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT airport_name, city, coordinates[0] AS longitude
    FROM airports
   ORDER BY longitude DESC
   LIMIT 3;
#+END_SRC

#+RESULTS:
| airport_name     | city          |          longitude |
|------------------+---------------+--------------------|
| Ugolny Airport   | Anadyr        | 177.74099731445312 |
| Yelizovo Airport | Petropavlovsk | 158.45399475097656 |
| Sokol Airport    | Magadan       | 150.72000122070312 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    order_by: [desc: selected_as(:longitude)],
    limit: 3,
    select: map(a, [:airport_name, :city]),
    select_merge: %{longitude: selected_as(fragment("?[0]", a.coordinates), :longitude)}

  # macro example
  Airport
  |> order_by([a], desc: selected_as(:longitude))
  |> limit(3)
  |> select([a], map(a, [:airport_name, :city]))
  |> select_merge([a], %{longitude: selected_as(fragment("?[0]", a.coordinates), :longitude)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 16:49:32.424 [debug] QUERY OK source="airports" db=1.5ms idle=495.2ms
: SELECT a0."airport_name", a0."city", a0."coordinates"[0] AS "longitude" FROM "airports" AS a0 ORDER BY "longitude" DESC LIMIT 3 []
: >>> :
: [
:   %{airport_name: "Ugolny Airport", city: "Anadyr", longitude: 177.74099731445312},
:   %{airport_name: "Yelizovo Airport", city: "Petropavlovsk", longitude: 158.45399475097656},
:   %{airport_name: "Sokol Airport", city: "Magadan", longitude: 150.72000122070312}
: ]

А как найти еще три аэропорта, которые находятся немного западнее первой тройки,
т.е. занимают места с четвертого по шестое? Нужно пропустить три первые строки,
прежде чем начать вывод. Для пропуска строк служит предложение ~OFFSET~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT airport_name, city, coordinates[0] AS longitude
    FROM airports
   ORDER BY longitude DESC
   LIMIT 3
  OFFSET 3;
#+END_SRC

#+RESULTS:
| airport_name               | city               |          longitude |
|----------------------------+--------------------+--------------------|
| Yuzhno-Sakhalinsk Airport  | Yuzhno-Sakhalinsk  | 142.71800231933594 |
| Komsomolsk-on-Amur Airport | Komsomolsk-on-Amur |  136.9340057373047 |
| Khabarovsk-Novy Airport    | Khabarovsk         |    135.18800354004 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    order_by: [desc: selected_as(:longitude)],
    limit: 3,
    offset: 3,
    select: map(a, [:airport_name, :city]),
    select_merge: %{longitude: selected_as(fragment("?[0]", a.coordinates), :longitude)}

  # macro example
  Airport
  |> order_by([a], desc: selected_as(:longitude))
  |> limit(3)
  |> offset(3)
  |> select([a], map(a, [:airport_name, :city]))
  |> select_merge([a], %{longitude: selected_as(fragment("?[0]", a.coordinates), :longitude)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 16:54:48.656 [debug] QUERY OK source="airports" db=0.2ms queue=0.2ms idle=1816.4ms
: SELECT a0."airport_name", a0."city", a0."coordinates"[0] AS "longitude" FROM "airports" AS a0 ORDER BY "longitude" DESC LIMIT 3 OFFSET 3 []
: >>> :
: [
:   %{airport_name: "Yuzhno-Sakhalinsk Airport", city: "Yuzhno-Sakhalinsk", longitude: 142.71800231933594},
:   %{airport_name: "Komsomolsk-on-Amur Airport", city: "Komsomolsk-on-Amur", longitude: 136.9340057373047},
:   %{airport_name: "Khabarovsk-Novy Airport", city: "Khabarovsk", longitude: 135.18800354004}
: ]

В дополнение к вычисляемым столбцам, когда выводимые значения получают путем
вычислений, при выборке данных из таблиц можно использовать *условные
выражения*, позволяющие вывести то или иное значение в зависимости от условий.

В таблице ~aircrafts~ есть столбец ~range~. Мы можем дополнить вывод данных из
этой таблицы столбцом ~aircraft type~, имея в виду принадлежность каждого
самолета к классу дальнемагистральных, среднемагистральных или
ближнемагистральных судов.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT model, range,
    CASE WHEN range < 2000 THEN 'Close range'
         WHEN range < 5000 THEN 'Middle range'
         ELSE 'Long range'
     END AS type
    FROM aircrafts
   ORDER BY model;
#+END_SRC

#+RESULTS:
| model               | range | type         |
|---------------------+-------+--------------|
| Airbus A319-100     |  6700 | Long range   |
| Airbus A320-200     |  5700 | Long range   |
| Airbus A321-200     |  5600 | Long range   |
| Boeing 737-300      |  4200 | Middle range |
| Boeing 767-300      |  7900 | Long range   |
| Boeing 777-300      | 11100 | Long range   |
| Bombardier CRJ-200  |  2700 | Middle range |
| Cessna 208 Caravan  |  1200 | Close range  |
| Sukhoi Superjet-100 |  3000 | Middle range |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  case_expr =
    dynamic(
      [q],
      fragment(
        """
        CASE WHEN ? < 2000 THEN 'Close range'
        WHEN ? < 5000 THEN 'Middle range'
        ELSE 'Long range'
        END
        """,
        q.range,
        q.range
      )
    )

  from a in Aircraft,
    order_by: a.model,
    select: map(a, [:model, :range]),
    select_merge: ^%{type: case_expr}

  # macro example
  Aircraft
  |> order_by([a], a.model)
  |> select([a], map(a, [:model, :range]))
  |> select_merge([a], ^%{type: case_expr})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 17:16:38.591 [debug] QUERY OK source="aircrafts" db=0.5ms idle=1544.3ms
: SELECT a0."model", a0."range", CASE WHEN a0."range" < 2000 THEN 'Close range' WHEN a0."range" < 5000 THEN 'Middle range' ELSE 'Long range' END FROM "aircrafts" AS a0 ORDER BY a0."model" []
: >>> :
: [
:   %{model: "Airbus A319-100", range: 6700, type: "Long range"},
:   %{model: "Airbus A320-200", range: 5700, type: "Long range"},
:   %{model: "Airbus A321-200", range: 5600, type: "Long range"},
:   %{model: "Boeing 737-300", range: 4200, type: "Middle range"},
:   %{model: "Boeing 767-300", range: 7900, type: "Long range"},
:   %{model: "Boeing 777-300", range: 11100, type: "Long range"},
:   %{model: "Bombardier CRJ-200", range: 2700, type: "Middle range"},
:   %{model: "Cessna 208 Caravan", range: 1200, type: "Close range"},
:   %{model: "Sukhoi Superjet-100", range: 3000, type: "Middle range"}
: ]
** Соединения
В тех случаях, когда информации, содержащейся в одной таблице, недостаточно для
получения требуемого результата, используют *соединение* (*join*) таблиц.
Покажем способ выполнения соединения на примере следующего запроса: выбрать все
места, предусмотренные компоновкой салона самолета /Cessna 208 Caravan/. Данная
команда иллюстрирует *соединение двух таблиц на основе равенства значений
атрибутов*.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT a.aircraft_code,
         a.model,
         s.seat_no,
         s.fare_conditions
    FROM seats AS s
         JOIN aircrafts AS a
             ON s.aircraft_code = a.aircraft_code
   WHERE a.model ~ '^Cessna'
   ORDER BY s.seat_no;
#+END_SRC

#+RESULTS:
| aircraft_code | model              | seat_no | fare_conditions |
|---------------+--------------------+---------+-----------------|
| CN1           | Cessna 208 Caravan | 1A      | Economy         |
| CN1           | Cessna 208 Caravan | 1B      | Economy         |
| CN1           | Cessna 208 Caravan | 2A      | Economy         |
| CN1           | Cessna 208 Caravan | 2B      | Economy         |
| CN1           | Cessna 208 Caravan | 3A      | Economy         |
| CN1           | Cessna 208 Caravan | 3B      | Economy         |
| CN1           | Cessna 208 Caravan | 4A      | Economy         |
| CN1           | Cessna 208 Caravan | 4B      | Economy         |
| CN1           | Cessna 208 Caravan | 5A      | Economy         |
| CN1           | Cessna 208 Caravan | 5B      | Economy         |
| CN1           | Cessna 208 Caravan | 6A      | Economy         |
| CN1           | Cessna 208 Caravan | 6B      | Economy         |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from s in Seat,
    join: a in assoc(a, :aircraft),
    where: fragment("? ~ ?", a.model, "^Cessna"),
    order_by: s.seat_no,
    select_merge: map(a, [:aircraft_code, :model]),
    select_merge: map(s, [:seat_no, :fare_conditions])

  # macro example
  Seat
  |> join(:inner, [s], a in assoc(a, :aircraft))
  |> where([s, a], fragment("? ~ ?", a.model, "^Cessna"))
  |> order_by([s], s.seat_no)
  |> select_merge([s, a], map(a, [:aircraft_code, :model]))
  |> select_merge([s], map(s, [:seat_no, :fare_conditions]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 17:52:00.180 [debug] QUERY OK source="seats" db=1.3ms idle=1481.0ms
: SELECT s0."seat_no", s0."fare_conditions", a1."aircraft_code", a1."model", s0."seat_no", s0."fare_conditions" FROM "seats" AS s0 INNER JOIN "aircrafts" AS a1 ON s0."aircraft_code" = a1."aircraft_code" WHERE (a1."model" ~ '^Cessna') ORDER BY s0."seat_no" []
: [
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "1A"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "1B"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "2A"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "2B"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "3A"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "3B"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "4A"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "4B"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "5A"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "5B"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "6A"},
:   %{aircraft_code: "CN1", fare_conditions: "Economy", model: "Cessna 208 Caravan", seat_no: "6B"}
: ]

Псевдонимы удобны в тех случаях, когда в соединяемых таблицах есть одноименные
атрибуты. В таких случаях в списке атрибутов, следующих за ключевым словом
~SELECT~, необходимо указывать либо имя таблицы, из которой выбирается значение
этого атрибута, либо ее псевдоним, но псевдоним может быть коротким, что удобнее
при написании команды. Псевдоними атрибут соединяются символом ~.~. Псевдонимы
используются и в предложениях ~WHERE~, ~GROUP BY~, ~ORDER BY~, ~HAVING~, т.е. во
всех частях команды ~SELECT~.

Изучая язык SQL вообще и способы выполнения соединений в частности, нужно иметь
в виду, что результатом любых реляционных операций над отношениями (таблицами,
представлениями) также является отношение. Поэтому такие операции можно
произвольно комбинировать друг с другом.

В соединении одна и та же таблица может участвовать дважды, т.е. формировать
соединение таблицы с самой собой. В качестве примера рассмотрим запрос для
создания представления ~flights_v~:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  \x
  SELECT f.flight_id,
         f.flight_no,
         f.scheduled_departure,
         timezone(dep.timezone, f.scheduled_departure) AS scheduled_departure_local,
         f.scheduled_arrival,
         timezone(arr.timezone, f.scheduled_arrival) AS scheduled_arrival_local,
         f.scheduled_arrival - f.scheduled_departure AS scheduled_duration,
         f.departure_airport_code,
         dep.airport_name AS departure_airport_name,
         dep.city AS departure_city,
         f.arrival_airport_code,
         arr.airport_name AS arrival_airport_name,
         arr.city AS arrival_city,
         f.status,
         f.aircraft_code,
         f.actual_departure,
         timezone(dep.timezone, f.actual_departure) AS actual_departure_local,
         f.actual_arrival,
         timezone(arr.timezone, f.actual_arrival) AS actual_arrival_local,
         f.actual_arrival - f.actual_departure AS actual_duration
    FROM flights f,
         airports dep,
         airports arr
   WHERE f.departure_airport_code = dep.airport_code
     AND f.arrival_airport_code = arr.airport_code
   LIMIT 1;
#+END_SRC

#+RESULTS:
| flight_id                 | 2880                             |
|---------------------------+----------------------------------|
| flight_no                 | PG0216                           |
| scheduled_departure       | 2017-09-14 13:10:00+02           |
| scheduled_departure_local | 2017-09-14 14:10:00              |
| scheduled_arrival         | 2017-09-14 14:15:00+02           |
| scheduled_arrival_local   | 2017-09-14 16:15:00              |
| scheduled_duration        | 01:05:00                         |
| departure_airport_code    | DME                              |
| departure_airport_name    | Domodedovo International Airport |
| departure_city            | Moscow                           |
| arrival_airport_code      | KUF                              |
| arrival_airport_name      | Kurumoch International Airport   |
| arrival_city              | Samara                           |
| status                    | Scheduled                        |
| aircraft_code             | 763                              |
| actual_departure          | NULL                             |
| actual_departure_local    | NULL                             |
| actual_arrival            | NULL                             |
| actual_arrival_local      | NULL                             |
| actual_duration           | NULL                             |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  timezone = fn airport, field ->
    dynamic(
      [{^airport, a}, flight: f],
      fragment("timezone(?, ?)", a.timezone, field(f, ^field))
    )
  end

  from f in Flight,
    as: :flight,
    join: dep in assoc(f, :departure_airport),
    as: :departure_airport,
    join: arr in assoc(f, :arrival_airport),
    as: :arrival_airport,
    limit: 1,
    select_merge:
      map(f, [
        :actual_arrival,
        :actual_departure,
        :aircraft_code,
        :arrival_airport_code,
        :departure_airport_code,
        :flight_id,
        :flight_no,
        :scheduled_arrival,
        :scheduled_departure,
        :status
      ]),
    select_merge: %{
      scheduled_duration: f.scheduled_arrival - f.scheduled_departure,
      actual_duration: f.actual_arrival - f.actual_departure
    },
    select_merge: map(dep, [:airport_name, :city]),
    select_merge: map(arr, [:airport_name, :city]),
    select_merge:
      ^%{
        scheduled_departure_local: timezone.(:departure_airport, :scheduled_departure),
        scheduled_arrival_local: timezone.(:arrival_airport, :scheduled_arrival),
        actual_departure_local: timezone.(:departure_airport, :actual_departure),
        actual_arrival_local: timezone.(:arrival_airport, :actual_arrival)
      }
  # macro example
  from(Flight, as: :flight)
  |> join(:inner, [f], dep in assoc(f, :departure_airport), as: :departure_airport)
  |> join(:inner, [f], arr in assoc(f, :arrival_airport), as: :arrival_airport)
  |> limit(1)
  |> select_merge(
    [f],
    map(f, [
      :actual_arrival,
      :actual_departure,
      :aircraft_code,
      :arrival_airport_code,
      :departure_airport_code,
      :flight_id,
      :flight_no,
      :scheduled_arrival,
      :scheduled_departure,
      :status
    ])
  )
  |> select_merge([f], %{
    scheduled_duration: f.scheduled_arrival - f.scheduled_departure,
    actual_duration: f.actual_arrival - f.actual_departure
  })
  |> select_merge([departure_airport: dep], map(dep, [:airport_name, :city]))
  |> select_merge([arrival_airport: arr], map(arr, [:airport_name, :city]))
  |> select_merge(
    ^%{
      scheduled_departure_local: timezone.(:departure_airport, :scheduled_departure),
      scheduled_arrival_local: timezone.(:arrival_airport, :scheduled_arrival),
      actual_departure_local: timezone.(:departure_airport, :actual_departure),
      actual_arrival_local: timezone.(:arrival_airport, :actual_arrival)
    }
  )
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 19:40:02.203 [debug] QUERY OK source="flights" db=1.2ms queue=0.8ms idle=33.2ms
: SELECT f0."actual_arrival", f0."actual_departure", f0."aircraft_code", f0."arrival_airport_code", f0."departure_airport_code", f0."flight_id", f0."flight_no", f0."scheduled_arrival", f0."scheduled_departure", f0."status", f0."scheduled_arrival" - f0."scheduled_departure", f0."actual_arrival" - f0."actual_departure", a1."airport_name", a1."city", a2."airport_name", a2."city", timezone(a2."timezone", f0."actual_arrival"), timezone(a1."timezone", f0."actual_departure"), timezone(a2."timezone", f0."scheduled_arrival"), timezone(a1."timezone", f0."scheduled_departure") FROM "flights" AS f0 INNER JOIN "airports" AS a1 ON a1."airport_code" = f0."departure_airport_code" INNER JOIN "airports" AS a2 ON a2."airport_code" = f0."arrival_airport_code" LIMIT 1 []
: >>> :
: [
:   %{
:     actual_arrival: nil,
:     actual_arrival_local: nil,
:     actual_departure: nil,
:     actual_departure_local: nil,
:     actual_duration: nil,
:     aircraft_code: "763",
:     airport_name: "Kurumoch International Airport",
:     arrival_airport_code: "KUF",
:     city: "Samara",
:     departure_airport_code: "DME",
:     flight_id: 2880,
:     flight_no: "PG0216",
:     scheduled_arrival: ~U[2017-09-14 12:15:00Z],
:     scheduled_arrival_local: ~N[2017-09-14 16:15:00.000000],
:     scheduled_departure: ~U[2017-09-14 11:10:00Z],
:     scheduled_departure_local: ~N[2017-09-14 14:10:00.000000],
:     scheduled_duration: %Postgrex.Interval{
:       months: 0,
:       days: 0,
:       secs: 3900,
:       microsecs: 0
:     },
:     status: "Scheduled"
:   }
: ]

Рассмотрев этот пример, вновь обратимся к соединениям такого типа и покажем три
способа выполнения *соединения таблицы с самой собой*, отличающиеся
синтаксически, но являющиеся функционально эквивалентными.

Наш запрос-иллюстрациядолжен выяснить: сколько всего маршрутов нужно было бы
сформировать, если бы требовалось соединить каждый город со всеми остальными
городами?

Первый вариант запроса использует обычное перечисление имен таблиц в предложении
~FROM~, т.е. формирует *декартово произведение таблиц* — все попарные комбинации
строк из двух таблиц.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM airports a1, airports a2
   WHERE a1.city <> a2.city;
#+END_SRC

#+RESULTS:
| count |
|-------|
| 10704 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a1 in Airport,
    join: a2 in Airport,
    where: a1.city != a2.city

  # macro example
  Airport
  |> join(:inner, [a1], a2 in Airport)
  |> where([a1, a2], a1.city != a2.city)
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 18:30:17.937 [debug] QUERY OK source="airports" db=2.6ms idle=1347.8ms
: SELECT count(*) FROM "airports" AS a0 INNER JOIN "airports" AS a1 ON TRUE WHERE (a0."city" != a1."city") []
: >>> : 10704

Во втором варианте запроса мы используем *соединение таблиц на основе
неравенства значений атрибутов*.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM airports a1
         JOIN airports a2
             ON a1.city <> a2.city;
#+END_SRC

#+RESULTS:
| count |
|-------|
| 10704 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a1 in Airport,
    join: a2 in Airport,
    on: a1.city != a2.city

  # macro example
  Airport
  |> join(:inner, [a1], a2 in Airport, on: a1.city != a2.city)
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 20:00:20.340 [debug] QUERY OK source="airports" db=1.4ms idle=350.3ms
: SELECT count(*) FROM "airports" AS a0 INNER JOIN "airports" AS a1 ON a0."city" != a1."city" []
: >>> : 10704

Третий вариант предусматривает *явное использование декартова произведения
таблиц*. Для этого служит предложение ~CROSS JOIN~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM airports a1
         CROSS JOIN airports a2
   WHERE a1.city <> a2.city;
#+END_SRC

#+RESULTS:
| count |
|-------|
| 10704 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a1 in Airport,
    cross_join: a2 in Airport,
    where: a1.city != a2.city

  # macro example
  Airport
  |> join(:cross, [a1], a2 in Airport)
  |> where([a1, a2], a1.city != a2.city)
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 17:21:07.691 [debug] QUERY OK source="airports" db=1.4ms queue=0.5ms idle=29.0ms
: SELECT count(*) FROM "airports" AS a0 CROSS JOIN "airports" AS a1 WHERE (a0."city" != a1."city") []
: >>> : 10704

С точки зрения СУБД эти три варианта эквивалентны. Для них PostgreSQL выберет
один и тот же план (порядок) выполнения запроса.

Теперь обратимся к так называемым *внешним соединениям*. Зададимся вопросом:
сколько маршрутов обслуживают самолеты каждого типа?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT r.aircraft_code, a.model, count(*) AS num_routes
    FROM routes r
         JOIN aircrafts a
             ON r.aircraft_code = a.aircraft_code
   GROUP BY 1, 2
   ORDER BY 3 DESC;
#+END_SRC

#+RESULTS:
| aircraft_code | model               | num_routes |
|---------------+---------------------+------------|
|           CR2 | Bombardier CRJ-200  |        232 |
|           CN1 | Cessna 208 Caravan  |        170 |
|           SU9 | Sukhoi Superjet-100 |        158 |
|           319 | Airbus A319-100     |         46 |
|           733 | Boeing 737-300      |         36 |
|           321 | Airbus A321-200     |         32 |
|           763 | Boeing 767-300      |         26 |
|           773 | Boeing 777-300      |         10 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from r in Route,
    join: a in assoc(r, :aircraft),
    group_by: [a.aircraft_code, a.model],
    order_by: [desc: selected_as(:num_routes)],
    select: map(a, [:aircraft_code, :model]),
    select_merge: %{num_routes: selected_as(count(), :num_routes)}

  # macro example
  Route
  |> join(:inner, [r], a in assoc(r, :aircraft))
  |> group_by([r, a], [a.aircraft_code, a.model])
  |> order_by(desc: selected_as(:num_routes))
  |> select([r, a], map(a, [:aircraft_code, :model]))
  |> select_merge(%{num_routes: selected_as(count(), :num_routes)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 18:35:19.011 [debug] QUERY OK source="routes" db=160.1ms idle=1264.4ms
: SELECT a1."aircraft_code", a1."model", count(*) AS "num_routes" FROM "routes" AS r0 INNER JOIN "aircrafts" AS a1 ON a1."aircraft_code" = r0."aircraft_code" GROUP BY a1."aircraft_code", a1."model" ORDER BY "num_routes" DESC []
: >>> :
: [
:   %{aircraft_code: "CR2", count: 232, model: "Bombardier CRJ-200"},
:   %{aircraft_code: "CN1", count: 170, model: "Cessna 208 Caravan"},
:   %{aircraft_code: "SU9", count: 158, model: "Sukhoi Superjet-100"},
:   %{aircraft_code: "319", count: 46, model: "Airbus A319-100"},
:   %{aircraft_code: "733", count: 36, model: "Boeing 737-300"},
:   %{aircraft_code: "321", count: 32, model: "Airbus A321-200"},
:   %{aircraft_code: "763", count: 26, model: "Boeing 767-300"},
:   %{aircraft_code: "773", count: 10, model: "Boeing 777-300"}
: ]

Обратите внимание, что таблица ~aircrafts~ содержит 9 моделей, а в этой выборке
лишь 8 строк. Значит, какая-то модель самолета не участвует в выполнении рейсов.
Как ее выявить? В данном запросе используется левое внешнее соединение — об этом
говорит предложение ~LEFT OUTER JOIN~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT a.aircraft_code AS a_code,
         a.model,
         r.aircraft_code AS r_code,
         count(r.aircraft_code) AS num_routes
    FROM aircrafts a
         LEFT OUTER JOIN routes r
             ON r.aircraft_code = a.aircraft_code
   GROUP BY 1, 2, 3
   ORDER BY 4 DESC;
#+END_SRC

#+RESULTS:
| a_code | model               | r_code | num_routes |
|--------+---------------------+--------+------------|
|    CR2 | Bombardier CRJ-200  |    CR2 |        232 |
|    CN1 | Cessna 208 Caravan  |    CN1 |        170 |
|    SU9 | Sukhoi Superjet-100 |    SU9 |        158 |
|    319 | Airbus A319-100     |    319 |         46 |
|    733 | Boeing 737-300      |    733 |         36 |
|    321 | Airbus A321-200     |    321 |         32 |
|    763 | Boeing 767-300      |    763 |         26 |
|    773 | Boeing 777-300      |    773 |         10 |
|    320 | Airbus A320-200     |   NULL |          0 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Aircraft,
    left_join: r in assoc(a, :routes),
    group_by: [a.aircraft_code, a.model, r.aircraft_code],
    order_by: [desc: selected_as(:num_routes)],
    select: %{a_code: a.aircraft_code, model: a.model},
    select_merge: %{r_code: r.aircraft_code},
    select_merge: %{num_routes: selected_as(count(r.aircraft_code), :num_routes)}

  # macro example
  Aircraft
  |> join(:left, [a], r in assoc(a, :routes))
  |> group_by([a, r], [a.aircraft_code, a.model, r.aircraft_code])
  |> order_by(desc: selected_as(:num_routes))
  |> select([a], %{a_code: a.aircraft_code, model: a.model})
  |> select_merge([a, r], %{r_code: r.aircraft_code})
  |> select_merge([a, r], %{num_routes: selected_as(count(r.aircraft_code), :num_routes)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 18:47:54.974 [debug] QUERY OK source="aircrafts" db=152.2ms queue=0.5ms idle=1233.2ms
: SELECT a0."aircraft_code", a0."model", r1."aircraft_code", count(r1."aircraft_code") AS "num_routes" FROM "aircrafts" AS a0 LEFT OUTER JOIN "routes" AS r1 ON r1."aircraft_code" = a0."aircraft_code" GROUP BY a0."aircraft_code", a0."model", r1."aircraft_code" ORDER BY "num_routes" DESC []
: >>> :
: [
:   %{a_code: "CR2", model: "Bombardier CRJ-200", num_routes: 232, r_code: "CR2"},
:   %{a_code: "CN1", model: "Cessna 208 Caravan", num_routes: 170, r_code: "CN1"},
:   %{a_code: "SU9", model: "Sukhoi Superjet-100", num_routes: 158, r_code: "SU9"},
:   %{a_code: "319", model: "Airbus A319-100", num_routes: 46, r_code: "319"},
:   %{a_code: "733", model: "Boeing 737-300", num_routes: 36, r_code: "733"},
:   %{a_code: "321", model: "Airbus A321-200", num_routes: 32, r_code: "321"},
:   %{a_code: "763", model: "Boeing 767-300", num_routes: 26, r_code: "763"},
:   %{a_code: "773", model: "Boeing 777-300", num_routes: 10, r_code: "773"},
:   %{a_code: "320", model: "Airbus A320-200", num_routes: 0, r_code: nil}
: ]

В качестве базовой таблицы выбирается таблица ~aircrafts~, указанная в запросе
слева от предложения ~LEFT OUTER JOIN~, и для каждой строки, находящейся в ней,
из таблицы ~routes~ подбираются строки, в которых значение атрибута
~aircraft_code~ такое же, как и в текущей строке таблицы ~aircrafts~. Если в
таблице ~routes~ нет ни одной соответствующей строки, то при отсутствии ключевых
слов ~LEFT OUTER~ результирующая комбинированная строка просто не будет
сформирована и не попадетв выборку. Но при наличии ключевых слов ~LEFT OUTER~
результирующая строка все равно будет сформирована.

Кроме левого внешнего соединения существует также и правое внешнее соединение —
~RIGHT OUTER JOIN~. В этом случае в качестве базовой выбирается таблица, имя
которой указано справа отпредложения ~RIGHT OUTER JOIN~, а механизм получения
результирующих строк в случае, когда для строки базовой таблицы не находится
пары во второй таблице, точно такой же, как и для левого внешнего соединения.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT a.aircraft_code AS a_code,
         a.model,
         r.aircraft_code AS r_code,
         count(r.aircraft_code) AS num_routes
    FROM routes r
         RIGHT OUTER JOIN aircrafts a
             ON r.aircraft_code = a.aircraft_code
   GROUP BY 1, 2, 3
   ORDER BY 4 DESC;
#+END_SRC

#+RESULTS:
| a_code | model               | r_code | num_routes |
|--------+---------------------+--------+------------|
|    CR2 | Bombardier CRJ-200  |    CR2 |        232 |
|    CN1 | Cessna 208 Caravan  |    CN1 |        170 |
|    SU9 | Sukhoi Superjet-100 |    SU9 |        158 |
|    319 | Airbus A319-100     |    319 |         46 |
|    733 | Boeing 737-300      |    733 |         36 |
|    321 | Airbus A321-200     |    321 |         32 |
|    763 | Boeing 767-300      |    763 |         26 |
|    773 | Boeing 777-300      |    773 |         10 |
|    320 | Airbus A320-200     |   NULL |          0 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from r in Route,
    right_join: a in Aircraft,
    on: r.aircraft_code == a.aircraft_code,
    group_by: [a.aircraft_code, a.model, r.aircraft_code],
    order_by: [desc: selected_as(:num_routes)],
    select: %{a_code: a.aircraft_code, model: a.model},
    select_merge: %{r_code: r.aircraft_code},
    select_merge: %{num_routes: selected_as(count(r.aircraft_code), :num_routes)}

  # macro example
  Route
  |> join(:right, [r], a in Aircraft, on: r.aircraft_code == a.aircraft_code)
  |> group_by([r, a], [a.aircraft_code, a.model, r.aircraft_code])
  |> order_by(desc: selected_as(:num_routes))
  |> select([r, a], map(a, [:aircraft_code, :model]))
  |> select_merge([r, a], map(r, [:aircraft_code]))
  |> select_merge([r, a], %{num_routes: selected_as(count(r.aircraft_code), :num_routes)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 18:52:19.438 [debug] QUERY OK source="routes" db=150.6ms queue=0.6ms idle=1699.6ms
: SELECT a1."aircraft_code", a1."model", r0."aircraft_code", count(r0."aircraft_code") AS "num_routes" FROM "routes" AS r0 RIGHT OUTER JOIN "aircrafts" AS a1 ON r0."aircraft_code" = a1."aircraft_code" GROUP BY a1."aircraft_code", a1."model", r0."aircraft_code" ORDER BY "num_routes" DESC []
: >>> :
: [
:   %{a_code: "CR2", model: "Bombardier CRJ-200", num_routes: 232, r_code: "CR2"},
:   %{a_code: "CN1", model: "Cessna 208 Caravan", num_routes: 170, r_code: "CN1"},
:   %{a_code: "SU9", model: "Sukhoi Superjet-100", num_routes: 158, r_code: "SU9"},
:   %{a_code: "319", model: "Airbus A319-100", num_routes: 46, r_code: "319"},
:   %{a_code: "733", model: "Boeing 737-300", num_routes: 36, r_code: "733"},
:   %{a_code: "321", model: "Airbus A321-200", num_routes: 32, r_code: "321"},
:   %{a_code: "763", model: "Boeing 767-300", num_routes: 26, r_code: "763"},
:   %{a_code: "773", model: "Boeing 777-300", num_routes: 10, r_code: "773"},
:   %{a_code: "320", model: "Airbus A320-200", num_routes: 0, r_code: nil}
: ]

Комбинацией этих двух видов внешних соединений является *полное внешнее
соединение* — ~FULL OUTER JOIN~. В этом случае в выборку включаются строки из
левой таблицы, для которых не нашлось соответствующих строк в правой таблице, и
строки из правой таблицы, длякоторых не нашлось соответствующих строк в левой
таблице.

В практической работе при выполнении выборок зачастую выполняются
*многотабличные запросы*, включающие три таблицы и более. В качестве примера
рассмотрим такую задачу: определить число пассажиров, не пришедших на
регистрацию билетов и, следовательно, не вылетевших в пункт назначения.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM ticket_flights t
         JOIN flights f
             ON t.flight_id = f.flight_id
         LEFT OUTER JOIN boarding_passes b
             ON t.ticket_no = b.ticket_no
                AND t.flight_id = b.flight_id
   WHERE f.actual_departure IS NOT NULL
         AND b.flight_id IS NULL;
#+END_SRC

#+RESULTS:
| count |
|-------|
|     0 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from tf in TicketFlights,
    join: f in assoc(tf, :flight),
    left_join: b in BoardingPass,
    on: tf.ticket_no == b.ticket_no and tf.flight_id == b.flight_id,
    # is_nill(b.flight) - позволяет выявить те строки, где не нашлось посадочного билета
    where: not is_nil(f.actual_departure) and is_nil(b.flight_id)

  # macro example
  TicketFlights
  |> join(:inner, [t], f in assoc(t, :flight))
  |> join(:left, [t], b in BoardingPass,
    on: t.ticket_no == b.ticket_no and t.flight_id == b.flight_id
  )
  |> where([t, f, b], not is_nil(f.actual_departure) and is_nil(b.flight_id))
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
: 20:13:09.606 [debug] QUERY OK source="ticket_flights" db=1887.9ms decode=0.8ms queue=0.6ms idle=1.5ms
: SELECT count(*) FROM "ticket_flights" AS t0 INNER JOIN "flights" AS f1 ON f1."flight_id" = t0."flight_id" LEFT OUTER JOIN "boarding_passes" AS b2 ON (t0."ticket_no" = b2."ticket_no") AND (t0."flight_id" = b2."flight_id") WHERE (NOT (f1."actual_departure" IS NULL) AND (b2."flight_id" IS NULL)) []
: >>> : 0

Чтобы все же удостовериться в работоспособности следующего запроса, можно в
таблице ~boarding_passes~ изменить в одной строке номер места таким образом,
чтобы этот пассажир переместился из салона экономического класса в салон
бизнес-класса.

#+BEGIN_SRC sql :engine postgres :exports :results value verbatim both :eval no
  UPDATE boarding_passes
     SET seat_no = '1A'
   WHERE flight_id = 2 AND seat_no = '17A';
#+END_SRC

#+RESULTS:
: UPDATE 1

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from b in BoardingPass,
    where: b.flight_id == 2 and b.seat_no == "17A",
    update: [set: [seat_no: "1A"]]

  # macro example
  BoardingPass
  |> where([b], b.flight_id == 2 and b.seat_no == "17A")
  |> update(set: [seat_no: "1A"])
  |> Repo.update_all([])
#+END_SRC

#+RESULTS:
: 20:13:09.620 [debug] QUERY OK source="boarding_passes" db=7.9ms queue=1.1ms idle=1900.1ms
: UPDATE "boarding_passes" AS b0 SET "seat_no" = '1A' WHERE ((b0."flight_id" = 2) AND (b0."seat_no" = '17A')) []
: >>> : {1, nil}

В качестве примера рассмотрим такую задачу: определить число пассажиров, не
пришедших на регистрацию билетов и, следовательно, не вылетевших в пункт
назначения.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  \x
  SELECT f.flight_no,
         f.scheduled_departure,
         f.flight_id,
         f.departure_airport_code,
         f.arrival_airport_code,
         f.aircraft_code,
         t.passenger_name,
         tf.fare_conditions AS fc_was,
         s.fare_conditions AS fc_should_be,
         b.seat_no
    FROM boarding_passes b
         JOIN ticket_flights tf
             ON b.ticket_no = tf.ticket_no
                AND b.flight_id = tf.flight_id
         JOIN tickets t
             ON tf.ticket_no = t.ticket_no
         JOIN flights f
             ON tf.flight_id = f.flight_id
         JOIN seats s
             ON b.seat_no = s.seat_no
                AND f.aircraft_code = s.aircraft_code
   WHERE tf.fare_conditions <> s.fare_conditions
   ORDER BY f.flight_no, f.scheduled_departure;
#+END_SRC

#+RESULTS:
| flight_no              | PG0404                 |
|------------------------+------------------------|
| scheduled_departure    | 2017-06-13 18:05:00+02 |
| flight_id              | 2                      |
| departure_airport_code | DME                    |
| arrival_airport_code   | LED                    |
| aircraft_code          | 321                    |
| passenger_name         | RAVIL GRIGOREV         |
| fc_was                 | Economy                |
| fc_should_be           | Business               |
| seat_no                | 1A                     |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from b in BoardingPass,
    join: tf in TicketFlights,
    on: b.ticket_no == tf.ticket_no and b.flight_id == tf.flight_id,
    join: t in assoc(tf, :ticket),
    join: f in assoc(tf, :flight),
    join: s in Seat,
    on: b.seat_no == s.seat_no and f.aircraft_code == s.aircraft_code,
    where: tf.fare_conditions != s.fare_conditions,
    order_by: [f.flight_no, f.scheduled_departure],
    select:
      map(f, [
        :flight_no,
        :scheduled_departure,
        :flight_id,
        :departure_airport_code,
        :arrival_airport_code,
        :aircraft_code
      ]),
    select_merge: map(t, [:passenger_name]),
    select_merge: map(tf, [:fare_conditions]),
    select_merge: map(s, [:fare_conditions]),
    select_merge: map(b, [:seat_no])

  # macro example
  BoardingPass
  |> from(as: :boarding_pass)
  |> join(:inner, [boarding_pass: bp], tf in TicketFlights,
    as: :ticket_flights,
    on: bp.ticket_no == tf.ticket_no and bp.flight_id == tf.flight_id
  )
  |> join(:inner, [ticket_flights: tf], t in assoc(tf, :ticket), as: :ticket)
  |> join(:inner, [ticket_flights: tf], f in assoc(tf, :flight), as: :flight)
  |> join(:inner, [boarding_pass: bp, flight: f], s in Seat,
    as: :seat,
    on: bp.seat_no == s.seat_no and f.aircraft_code == s.aircraft_code
  )
  |> where([ticket_flights: tf, seat: s], tf.fare_conditions != s.fare_conditions)
  |> order_by([flight: f], [f.flight_no, f.scheduled_departure])
  |> select(
    [flight: f],
    map(f, [
      :flight_no,
      :scheduled_departure,
      :flight_id,
      :departure_airport_code,
      :arrival_airport_code,
      :aircraft_code
    ])
  )
  |> select_merge([ticket: t], map(t, [:passenger_name]))
  |> select_merge([ticket_flights: tf], map(tf, [:fare_conditions]))
  |> select_merge([seat: s], map(s, [:fare_conditions]))
  |> select_merge([boarding_pass: bp], map(bp, [:seat_no]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 09:10:02.114 [debug] QUERY OK source="boarding_passes" db=2516.0ms queue=0.6ms idle=1278.3ms
: SELECT b0."seat_no", f3."flight_no", f3."scheduled_departure", f3."flight_id", f3."departure_airport_code", f3."arrival_airport_code", f3."aircraft_code", t2."passenger_name", t1."fare_conditions", s4."fare_conditions" FROM "boarding_passes" AS b0 INNER JOIN "ticket_flights" AS t1 ON (b0."ticket_no" = t1."ticket_no") AND (b0."flight_id" = t1."flight_id") INNER JOIN "tickets" AS t2 ON t2."ticket_no" = t1."ticket_no" INNER JOIN "flights" AS f3 ON f3."flight_id" = t1."flight_id" INNER JOIN "seats" AS s4 ON (b0."seat_no" = s4."seat_no") AND (f3."aircraft_code" = s4."aircraft_code") WHERE (t1."fare_conditions" != s4."fare_conditions") ORDER BY f3."flight_no", f3."scheduled_departure" []
: >>> :
: [
:   %{
:     aircraft_code: "321",
:     arrival_airport_code: "LED",
:     departure_airport_code: "DME",
:     fare_conditions: "Business",
:     flight_id: 2,
:     flight_no: "PG0404",
:     passenger_name: "RAVIL GRIGOREV",
:     scheduled_departure: ~U[2017-06-13 16:05:00Z],
:     seat_no: "1A"
:   }
: ]

В предложении ~FROM~ можно использовать виртуальные таблицы, сформированные с
помощью ключевого слова ~VALUES~. Предположим, что для выработки финансовой
стратегии нашей авиакомпании требуется распределение количества бронирований по
диапазонам сумм с шагом в 100 тысяч рублей.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT r.min_sum, r.max_sum, count(b.*)
    FROM bookings b
         RIGHT OUTER JOIN ( VALUES (      0,  100000), ( 100000,  200000),
                                   ( 200000,  300000), ( 300000,  400000),
                                   ( 400000,  500000), ( 500000,  600000),
                                   ( 600000,  700000), ( 700000,  800000),
                                   ( 800000,  900000), ( 900000, 1000000),
                                   (1000000, 1100000), (1100000, 1200000),
                                   (1200000, 1300000)) AS r (min_sum, max_sum)
             ON b.total_amount >= r.min_sum
                AND b.total_amount < r.max_sum
   GROUP BY r.min_sum, r.max_sum
   ORDER BY r.min_sum;
#+END_SRC

#+RESULTS:
| min_sum | max_sum |   count |
|---------+---------+---------|
|       0 |  100000 | 1589446 |
|  100000 |  200000 |  380085 |
|  200000 |  300000 |   95943 |
|  300000 |  400000 |   26883 |
|  400000 |  500000 |   10588 |
|  500000 |  600000 |    5474 |
|  600000 |  700000 |    1948 |
|  700000 |  800000 |     453 |
|  800000 |  900000 |     174 |
|  900000 | 1000000 |      90 |
| 1000000 | 1100000 |      19 |
| 1100000 | 1200000 |       4 |
| 1200000 | 1300000 |       2 |

#+BEGIN_SRC elixir :exports both :eval no
  defmodule Queries09 do
    ranges = [
      {0, 100_000},
      {100_000, 200_000},
      {200_000, 300_000},
      {300_000, 400_000},
      {400_000, 500_000},
      {500_000, 600_000},
      {600_000, 700_000},
      {700_000, 800_000},
      {800_000, 900_000},
      {900_000, 1_000_000},
      {1_000_000, 1_100_000},
      {1_100_000, 1_200_000},
      {1_200_000, 1_300_000}
    ]

    values =
      ranges
      |> Enum.map_join(", ", fn {min_sum, max_sum} -> "(#{min_sum}, #{max_sum})" end)
      |> then(&"SELECT * FROM (VALUES #{&1}) AS values (min_sum, max_sum)")

    def query() do
      Booking
      |> with_cte("values", as: fragment(unquote(values)))
      |> join(:right, [b], v in "values",
        on: b.total_amount >= v.min_sum and b.total_amount < v.max_sum
      )
      |> group_by([b, v], [v.min_sum, v.max_sum])
      |> order_by([b, v], v.min_sum)
      |> select([b, v], map(v, [:min_sum, :max_sum]))
      |> select_merge([b, v], %{count: selected_as(count(b), :count)})
    end
  end

  Repo.all(Queries09.query())
#+END_SRC

#+RESULTS:
: 09:22:41.195 [debug] QUERY OK source="bookings" db=3243.7ms queue=3.2ms idle=628.7ms
: WITH "values" AS (SELECT * FROM (VALUES (0, 100000), (100000, 200000), (200000, 300000), (300000, 400000), (400000, 500000), (500000, 600000), (600000, 700000), (700000, 800000), (800000, 900000), (900000, 1000000), (1000000, 1100000), (1100000, 1200000), (1200000, 1300000)) AS values (min_sum, max_sum)) SELECT v1."min_sum", v1."max_sum", count(b0) AS "count" FROM "bookings" AS b0 RIGHT OUTER JOIN "values" AS v1 ON (b0."total_amount" >= v1."min_sum") AND (b0."total_amount" < v1."max_sum") GROUP BY v1."min_sum", v1."max_sum" ORDER BY v1."min_sum" []
: >>> :
: [
:   %{count: 1589446, max_sum: 100000, min_sum: 0},
:   %{count: 380085, max_sum: 200000, min_sum: 100000},
:   %{count: 95943, max_sum: 300000, min_sum: 200000},
:   %{count: 26883, max_sum: 400000, min_sum: 300000},
:   %{count: 10588, max_sum: 500000, min_sum: 400000},
:   %{count: 5474, max_sum: 600000, min_sum: 500000},
:   %{count: 1948, max_sum: 700000, min_sum: 600000},
:   %{count: 453, max_sum: 800000, min_sum: 700000},
:   %{count: 174, max_sum: 900000, min_sum: 800000},
:   %{count: 90, max_sum: 1000000, min_sum: 900000},
:   %{count: 19, max_sum: 1100000, min_sum: 1000000},
:   %{count: 4, max_sum: 1200000, min_sum: 1100000},
:   %{count: 2, max_sum: 1300000, min_sum: 1200000}
: ]

В команде ~SELECT~ предусмотрены средства для выполнения операций с выборками,
как с множествами, а именно:
- ~UNION~ для вычисления объединения множеств строк из двух выборок;
- ~INTERSECT~ для вычисления пересечения множеств строк из двух выборок;
- ~EXCEPT~ для вычисления разности множеств строк из двух выборок.

Запросы должны возвращать одинаковое число столбцов, типы данных у столбцов
также должны совпадать.

Начнем с операции *объединения множеств строк* — ~UNION~. Строка включается в
итоговое множество (выборку), если она присутствует хотя бы в одном из них.
Строки-дубликаты в результирующее множество не включаются. Для их включениянужно
использовать ~UNION ALL~.

Вопрос: в какие города можно улететь либо из Москвы, либо из Санкт-Петербурга?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT arrival_city
    FROM routes
   WHERE departure_city = 'Moscow'

  UNION

  SELECT arrival_city
    FROM routes
   WHERE departure_city = 'St. Petersburg'
   ORDER BY arrival_city;
#+END_SRC

#+RESULTS:
| arrival_city      |
|-------------------|
| Abakan            |
| Anadyr            |
| Anapa             |
| Arkhangelsk       |
| Astrakhan         |
| Barnaul           |
| Belgorod          |
| Beloyarsky        |
| Beslan            |
| Bratsk            |
| Bryansk           |
| Bugulma           |
| Cheboksary        |
| Chelyabinsk       |
| Cherepovets       |
| Elista            |
| Gelendzhik        |
| Gorno-Altaysk     |
| Grozny            |
| Irkutsk           |
| Izhevsk           |
| Kaliningrad       |
| Kaluga            |
| Kazan             |
| Kemorovo          |
| Khabarovsk        |
| Khanty-Mansiysk   |
| Kirov             |
| Krasnodar         |
| Krasnoyarsk       |
| Kurgan            |
| Kursk             |
| Lipetsk           |
| Magnetiogorsk     |
| Makhachkala       |
| Mineralnye Vody   |
| Mirnyj            |
| Moscow            |
| Murmansk          |
| Nadym             |
| Nalchik           |
| Naryan-Mar        |
| Nefteyugansk      |
| Neryungri         |
| Nizhnevartovsk    |
| Nizhniy Novgorod  |
| Norilsk           |
| Novosibirsk       |
| Novy Urengoy      |
| Noyabrsk          |
| Nyagan            |
| Omsk              |
| Orenburg          |
| Orsk              |
| Penza             |
| Perm              |
| Petropavlovsk     |
| Petrozavodsk      |
| Pskov             |
| Rostov            |
| Salekhard         |
| Samara            |
| Saransk           |
| Saratov           |
| Sochi             |
| Sovetskiy         |
| Stavropol         |
| St. Petersburg    |
| Syktyvkar         |
| Tambow            |
| Tomsk             |
| Tyumen            |
| Ufa               |
| Ulan-ude          |
| Ulyanovsk         |
| Uraj              |
| Usinsk            |
| Vladivostok       |
| Volgograd         |
| Vorkuta           |
| Voronezh          |
| Yakutia           |
| Yakutsk           |
| Yaroslavl         |
| Yekaterinburg     |
| Yoshkar-Ola       |
| Yuzhno-Sakhalinsk |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  base_query =
    from r in Route,
      where: r.departure_city == "St. Petersburg",
      select: map(r, [:arrival_city])

  union_query =
    from r in Route,
      where: r.departure_city == "Moscow",
      union: ^base_query,
      select: map(r, [:arrival_city])

  from u in subquery(union_query),
    select: u.arrival_city,
    order_by: u.arrival_city

  # macro example
  base_query =
    Route
    |> where([r], r.departure_city == "St. Petersburg")
    |> select([r], map(r, [:arrival_city]))

  union_query =
    Route
    |> where([r], r.departure_city == "Moscow")
    |> union(^base_query)
    |> select([r], map(r, [:arrival_city]))

  union_query
  |> subquery()
  |> order_by([u], u.arrival_city)
  |> select([u], u.arrival_city)
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 21:10:12.141 [debug] QUERY OK db=299.7ms decode=1.0ms queue=1.1ms idle=2.5ms
: SELECT s0."arrival_city" FROM (SELECT sr0."arrival_city" AS "arrival_city" FROM "routes" AS sr0 WHERE (sr0."departure_city" = 'Moscow') UNION (SELECT r0."arrival_city" FROM "routes" AS r0 WHERE (r0."departure_city" = 'St. Petersburg'))) AS s0 ORDER BY s0."arrival_city" []
: >>> :
: ["Abakan", "Anadyr", "Anapa", "Arkhangelsk", "Astrakhan", "Barnaul", "Belgorod",
:  "Beloyarsky", "Beslan", "Bratsk", "Bryansk", "Bugulma", "Cheboksary",
:  "Chelyabinsk", "Cherepovets", "Elista", "Gelendzhik", "Gorno-Altaysk",
:  "Grozny", "Irkutsk", "Izhevsk", "Kaliningrad", "Kaluga", "Kazan", "Kemorovo",
:  "Khabarovsk", "Khanty-Mansiysk", "Kirov", "Krasnodar", "Krasnoyarsk", "Kurgan",
:  "Kursk", "Lipetsk", "Magnetiogorsk", "Makhachkala", "Mineralnye Vody",
:  "Mirnyj", "Moscow", "Murmansk", "Nadym", "Nalchik", "Naryan-Mar",
:  "Nefteyugansk", "Neryungri", "Nizhnevartovsk", "Nizhniy Novgorod", "Norilsk",
:  "Novosibirsk", "Novy Urengoy", "Noyabrsk", ...]

Рассмотрим операцию *пересечения множеств строк* — ~INTERSECT~. Строка
включается в итоговое множество (выборку), если она присутствует в каждом из
них. Строки-дубликаты в результирующее множество не включаются. Для их включения
нужно использовать ~INTERSECT ALL~.

Вопрос: в какие города можно улететь как из Москвы, так и из Санкт-Петербурга?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT arrival_city
    FROM routes
   WHERE departure_city = 'Moscow'

  INTERSECT

  SELECT arrival_city
    FROM routes
   WHERE departure_city = 'St. Petersburg'
   ORDER BY arrival_city;
#+END_SRC

#+RESULTS:
| arrival_city     |
|------------------|
| Cheboksary       |
| Elista           |
| Kazan            |
| Khabarovsk       |
| Kirov            |
| Neryungri        |
| Nizhnevartovsk   |
| Nizhniy Novgorod |
| Noyabrsk         |
| Orenburg         |
| Sovetskiy        |
| Tambow           |
| Tyumen           |
| Vorkuta          |
| Voronezh         |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  base_query =
    from r in Route,
    where: r.departure_city == "St. Petersburg",
    select: map(r, [:arrival_city])

  intersect_query =
    from r in Route,
    where: r.departure_city == "Moscow",
    intersect: ^base_query,
    select: map(r, [:arrival_city])

  from u in subquery(intersect_query),
    order_by: u.arrival_city,
    select: u.arrival_city

  # macro example
  base_query =
    Route
    |> where([r], r.departure_city == "St. Petersburg")
    |> select([r], map(r, [:arrival_city]))

  intersect_query =
    Route
    |> where([r], r.departure_city == "Moscow")
    |> intersect(^base_query)
    |> select([r], map(r, [:arrival_city]))

  intersect_query
  |> subquery()
  |> order_by([u], u.arrival_city)
  |> select([u], u.arrival_city)
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 21:10:12.464 [debug] QUERY OK db=316.0ms queue=1.8ms idle=312.9ms
: SELECT s0."arrival_city" FROM (SELECT sr0."arrival_city" AS "arrival_city" FROM "routes" AS sr0 WHERE (sr0."departure_city" = 'Moscow') INTERSECT (SELECT r0."arrival_city" FROM "routes" AS r0 WHERE (r0."departure_city" = 'St. Petersburg'))) AS s0 ORDER BY s0."arrival_city" []
: >>> :
: ["Cheboksary", "Elista", "Kazan", "Khabarovsk", "Kirov", "Neryungri",
:  "Nizhnevartovsk", "Nizhniy Novgorod", "Noyabrsk", "Orenburg", "Sovetskiy",
:  "Tambow", "Tyumen", "Vorkuta", "Voronezh"]

Рассмотрим операцию *разности множеств строк* — ~EXCEPT~. Строка включается в
итоговое множество (выборку), если она присутствует в первом множестве
(выборке), но отсутствует во втором. Строки-дубликаты в результирующее множество
не включаются. Для их включения нужно использовать ~EXCEPT ALL~.

Вопрос: в какие города можно улететь из Санкт-Петербурга, но нельзя из Москвы?

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT arrival_city
    FROM routes
   WHERE departure_city = 'St. Petersburg'

  EXCEPT

  SELECT arrival_city
    FROM routes
   WHERE departure_city = 'Moscow'
   ORDER BY arrival_city;
#+END_SRC

#+RESULTS:
| arrival_city |
|--------------|
| Cherepovets  |
| Irkutsk      |
| Kaluga       |
| Moscow       |
| Yakutia      |
| Yakutsk      |
| Yaroslavl    |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  base_query =
    from r in Route,
      where: r.departure_city == "Moscow",
      select: map(r, [:arrival_city])

  except_query =
    from r in Route,
      where: r.departure_city == "St. Petersburg",
      except: ^base_query,
      select: map(r, [:arrival_city])

  from u in subquery(except_query),
    order_by: u.arrival_city,
    select: u.arrival_city

  # macro example
  base_query =
    Route
    |> where([r], r.departure_city == "Moscow")
    |> select([r], map(r, [:arrival_city]))

  except_query =
    Route
    |> where([r], r.departure_city == "St. Petersburg")
    |> except(^base_query)
    |> select([r], map(r, [:arrival_city]))

  except_query
  |> subquery()
  |> order_by([u], u.arrival_city)
  |> select([u], u.arrival_city)
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 21:10:12.791 [debug] QUERY OK db=324.5ms queue=1.2ms idle=631.4ms
: SELECT s0."arrival_city" FROM (SELECT sr0."arrival_city" AS "arrival_city" FROM "routes" AS sr0 WHERE (sr0."departure_city" = 'St. Petersburg') EXCEPT (SELECT r0."arrival_city" FROM "routes" AS r0 WHERE (r0."departure_city" = 'Moscow'))) AS s0 ORDER BY s0."arrival_city" []
:
: ["Cherepovets", "Irkutsk", "Kaluga", "Moscow", "Yakutia", "Yakutsk",
:  "Yaroslavl"]

Конечно, при выполнении этих операций можно соединять не только две таблицы, но
и большее их число. При этом нужно либо учитывать приоритеты выполнения
операций, либо использовать скобки. Согласно документации ~INTERSECT~ связывает
свои подзапросы сильнее, чем ~UNION~, а ~EXCEPT~ связывает свои подзапросы так
же сильно, как ~UNION~.
** Агрегирование и группировка
Для расчета среднего значения по столбцу используется функция ~avg~ (от слова
~average~).

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT avg(total_amount) FROM bookings;
#+END_SRC

#+RESULTS:
|                avg |
|--------------------|
| 79299.069731089332 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from b in Booking,
    select: avg(b.total_amount)

  # macro example
  Booking
  |> select([b], avg(b.total_amount))

  # shortcut example
  Repo.aggregate(Booking, :avg, :total_amount)
#+END_SRC

#+RESULTS:
: 21:12:16.830 [debug] QUERY OK source="bookings" db=93.9ms decode=0.5ms queue=0.4ms idle=1.3ms
: SELECT avg(b0."total_amount") FROM "bookings" AS b0 []
: >>> : #Decimal<79299.069731089332>

Для получения максимального значения по столбцу используется функция ~max~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT max(total_amount) FROM bookings;
#+END_SRC

#+RESULTS:
|        max |
|------------|
| 1308700.00 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from b in Booking,
    select: max(b.total_amount)

  # macro example
  Booking
  |> select([b], max(b.total_amount))

  # shortcut example
  Repo.aggregate(Booking, :max, :total_amount)
#+END_SRC

#+RESULTS:
: 21:12:16.930 [debug] QUERY OK source="bookings" db=94.8ms queue=0.6ms idle=105.7ms
: SELECT max(b0."total_amount") FROM "bookings" AS b0 [
: >>> : #Decimal<1308700.00>

Для получения минимального значения по столбцу используется функция ~min~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT min(total_amount) FROM bookings;
#+END_SRC

#+RESULTS:
|     min |
|---------|
| 3400.00 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from b in Booking,
    select: min(b.total_amount)

  # macro example
  Booking
  |> select([b], min(b.total_amount))

  # shortcut example
  Repo.aggregate(Booking, :min, :total_amount)
#+END_SRC

#+RESULTS:
: 21:12:17.025 [debug] QUERY OK source="bookings" db=93.2ms queue=0.6ms idle=201.6ms
: SELECT min(b0."total_amount") FROM "bookings" AS b0 []
: >>> : #Decimal<3400.00>

Первый будет таким: давайте подсчитаем, сколько маршрутов предусмотрено из
Москвы в другие города. При формировании запроса не будем учитывать частоту
рейсов в неделю, т.е. независимо от того, выполняется какой-то рейс один раз в
неделю или семь раз, он учитывается только однократно.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT arrival_city, count(*)
    FROM routes
   WHERE departure_city = 'Moscow'
   GROUP BY arrival_city
   ORDER BY count DESC;
#+END_SRC

#+RESULTS:
| arrival_city      | count |
|-------------------+-------|
| St. Petersburg    |    12 |
| Bryansk           |     9 |
| Ulyanovsk         |     5 |
| Petrozavodsk      |     4 |
| Yoshkar-Ola       |     4 |
| Penza             |     3 |
| Kemorovo          |     3 |
| Barnaul           |     3 |
| Kurgan            |     3 |
| Rostov            |     3 |
| Anadyr            |     3 |
| Gelendzhik        |     3 |
| Sovetskiy         |     3 |
| Stavropol         |     2 |
| Astrakhan         |     2 |
| Tambow            |     2 |
| Tomsk             |     2 |
| Makhachkala       |     2 |
| Beslan            |     2 |
| Murmansk          |     2 |
| Usinsk            |     2 |
| Kaliningrad       |     2 |
| Volgograd         |     2 |
| Vorkuta           |     2 |
| Naryan-Mar        |     2 |
| Yuzhno-Sakhalinsk |     2 |
| Nefteyugansk      |     2 |
| Bugulma           |     2 |
| Khanty-Mansiysk   |     2 |
| Nizhniy Novgorod  |     2 |
| Novosibirsk       |     2 |
| Novy Urengoy      |     2 |
| Noyabrsk          |     2 |
| Nyagan            |     2 |
| Omsk              |     2 |
| Kirov             |     2 |
| Cheboksary        |     2 |
| Pskov             |     2 |
| Elista            |     2 |
| Saransk           |     2 |
| Saratov           |     2 |
| Sochi             |     2 |
| Nizhnevartovsk    |     1 |
| Anapa             |     1 |
| Arkhangelsk       |     1 |
| Belgorod          |     1 |
| Beloyarsky        |     1 |
| Bratsk            |     1 |
| Chelyabinsk       |     1 |
| Gorno-Altaysk     |     1 |
| Grozny            |     1 |
| Izhevsk           |     1 |
| Kazan             |     1 |
| Khabarovsk        |     1 |
| Krasnodar         |     1 |
| Krasnoyarsk       |     1 |
| Kursk             |     1 |
| Lipetsk           |     1 |
| Magnetiogorsk     |     1 |
| Mineralnye Vody   |     1 |
| Mirnyj            |     1 |
| Nadym             |     1 |
| Nalchik           |     1 |
| Neryungri         |     1 |
| Abakan            |     1 |
| Norilsk           |     1 |
| Orenburg          |     1 |
| Orsk              |     1 |
| Perm              |     1 |
| Petropavlovsk     |     1 |
| Salekhard         |     1 |
| Samara            |     1 |
| Syktyvkar         |     1 |
| Tyumen            |     1 |
| Ufa               |     1 |
| Ulan-ude          |     1 |
| Uraj              |     1 |
| Vladivostok       |     1 |
| Voronezh          |     1 |
| Yekaterinburg     |     1 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from r in Route,
    where: r.departure_city == "Moscow",
    group_by: r.arrival_city,
    order_by: [desc: selected_as(:count)],
    select: map(r, [:arrival_city]),
    select_merge: %{count: selected_as(count(), :count)}

  # macro example
  Route
  |> where([r], r.departure_city == "Moscow")
  |> group_by([r], r.arrival_city)
  |> order_by([r], desc: selected_as(:count))
  |> select([r], map(r, [:arrival_city]))
  |> select_merge(%{count: selected_as(count(), :count)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 09:42:59.678 [debug] QUERY OK source="routes" db=117.0ms idle=1826.8ms
: SELECT r0."arrival_city", count(*) AS "count" FROM "routes" AS r0 WHERE (r0."departure_city" = 'Moscow') GROUP BY r0."arrival_city" ORDER BY "count" DESC []
: >>> :
: [
:   %{arrival_city: "St. Petersburg", count: 12},
:   %{arrival_city: "Bryansk", count: 9},
:   %{arrival_city: "Ulyanovsk", count: 5},
:   %{arrival_city: "Petrozavodsk", count: 4},
:   %{arrival_city: "Yoshkar-Ola", count: 4},
:   %{arrival_city: "Penza", count: 3},
:   %{arrival_city: "Kemorovo", count: 3},
:   %{arrival_city: "Barnaul", count: 3},
:   %{arrival_city: "Kurgan", count: 3},
:   %{arrival_city: "Rostov", count: 3},
:   %{arrival_city: "Anadyr", count: 3},
:   %{arrival_city: "Gelendzhik", count: 3},
:   %{arrival_city: "Sovetskiy", count: 3},
:   %{arrival_city: "Stavropol", count: 2},
:   %{arrival_city: "Astrakhan", count: 2},
:   %{arrival_city: "Tambow", count: 2},
:   %{arrival_city: "Tomsk", count: 2},
:   %{arrival_city: "Makhachkala", count: 2},
:   %{arrival_city: "Beslan", count: 2},
:   %{arrival_city: "Murmansk", count: 2},
:   %{arrival_city: "Usinsk", count: 2},
:   %{arrival_city: "Kaliningrad", count: 2},
:   %{arrival_city: "Volgograd", count: 2},
:   %{arrival_city: "Vorkuta", count: 2},
:   %{arrival_city: "Naryan-Mar", count: 2},
:   %{arrival_city: "Yuzhno-Sakhalinsk", count: 2},
:   %{arrival_city: "Nefteyugansk", count: 2},
:   %{arrival_city: "Bugulma", count: 2},
:   %{arrival_city: "Khanty-Mansiysk", count: 2},
:   %{arrival_city: "Nizhniy Novgorod", count: 2},
:   %{arrival_city: "Novosibirsk", count: 2},
:   %{arrival_city: "Novy Urengoy", count: 2},
:   %{arrival_city: "Noyabrsk", count: 2},
:   %{arrival_city: "Nyagan", count: 2},
:   %{arrival_city: "Omsk", count: 2},
:   %{arrival_city: "Kirov", count: 2},
:   %{arrival_city: "Cheboksary", count: 2},
:   %{arrival_city: "Pskov", count: 2},
:   %{arrival_city: "Elista", count: 2},
:   %{arrival_city: "Saransk", count: 2},
:   %{arrival_city: "Saratov", count: 2},
:   %{arrival_city: "Sochi", count: 2},
:   %{arrival_city: "Nizhnevartovsk", count: 1},
:   %{arrival_city: "Anapa", count: 1},
:   %{arrival_city: "Arkhangelsk", count: 1},
:   %{arrival_city: "Belgorod", count: 1},
:   %{arrival_city: "Beloyarsky", count: 1},
:   %{arrival_city: "Bratsk", count: 1},
:   %{arrival_city: "Chelyabinsk", ...},
:   %{...},
:   ...
: ]

В качестве второго примера рассмотрим ситуацию, когда руководству компании
потребовалась обобщенная информация по частоте выполнения рейсов, а именно:
сколько рейсов выполняется ежедневно, сколько рейсов — шесть дней в неделю, пять
и т.д.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT array_length(days_of_week, 1) AS days_per_week, count(*) AS num_routes
    FROM routes
   GROUP BY days_per_week
   ORDER BY 1 desc;
#+END_SRC

#+RESULTS:
| days_per_week | num_routes |
|---------------+------------|
|             7 |        482 |
|             3 |         54 |
|             2 |         89 |
|             1 |         85 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from r in Route,
    group_by: selected_as(:days_per_week),
    order_by: [desc: selected_as(:days_per_week)],
    select: %{
      days_per_week: selected_as(fragment("array_length(?, 1)", r.days_of_week), :days_per_week),
      num_routes: count()
    }

  # macro example
  Route
  |> group_by([r], selected_as(:days_per_week))
  |> order_by(desc: selected_as(:days_per_week))
  |> select([r], %{
    days_per_week: selected_as(fragment("array_length(?, 1)", r.days_of_week), :days_per_week),
    num_routes: count()
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 21:12:17.335 [debug] QUERY OK source="routes" db=152.1ms queue=1.1ms idle=452.4ms
: SELECT array_length(r0."days_of_week", 1) AS days_per_week, count(*) FROM "routes" AS r0 GROUP BY days_per_week ORDER BY 1 DESC []
: >>> :
: [
:   %{days_per_week: 7, num_routes: 482},
:   %{days_per_week: 3, num_routes: 54},
:   %{days_per_week: 2, num_routes: 89},
:   %{days_per_week: 1, num_routes: 85}
: ]

В этом запросе используется функция ~array_length~, возвращающая количество
элементов в указанном измерении массива. Поскольку массив одномерный, то вторым
параметром функции будет число 1 — первое измерение.

При выполнении выборок можно с помощью условий, заданных в предложении ~WHERE~,
сузить множество выбираемых строк. Аналогичная возможность существует и при
выполнении группировок: можно включить в результирующее множествоне все строки,
а лишь те, которые удовлетворяют некоторому условию. Это условие можно задать
впредложении ~HAVING~. Важно помнить, что предложение ~WHERE~ работает с
отдельными строками еще до выполнения группировки с помощью ~GROUP BY~, а
предложение ~HAVING~ — уже после выполнения группировки.

В качестве примера приведем такой запрос: определить, сколько существует
маршрутов из каждого города в другие города, и вывести названия городов, из
которыхв другие города существует не менее 15 маршрутов.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT departure_city, count(*)
    FROM routes
   GROUP BY departure_city
  HAVING count(*) >= 15
   ORDER BY count DESC;
#+END_SRC

#+RESULTS:
| departure_city | count |
|----------------+-------|
| Moscow         |   154 |
| St. Petersburg |    35 |
| Novosibirsk    |    19 |
| Yekaterinburg  |    15 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from r in Route,
    group_by: r.departure_city,
    having: count() >= 15,
    order_by: [desc: selected_as(:count)],
    select: map(r, [:departure_city]),
    select_merge: %{num_routes: selected_as(count(), :count)}

  # macro example
  Route
  |> group_by([r], r.departure_city)
  |> having(count() >= 15)
  |> order_by([r], desc: selected_as(:count))
  |> select([r], map(r, [:departure_city]))
  |> select_merge([], %{num_routes: selected_as(count(), :count)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 10:53:37.668 [debug] QUERY OK source="routes" db=89.7ms idle=1357.6ms
: SELECT r0."departure_city" FROM "routes" AS r0 GROUP BY r0."departure_city" HAVING (count(*) >= 15) ORDER BY count(*) DESC []
: >>> :
: [
:   %{departure_city: "Moscow"},
:   %{departure_city: "St. Petersburg"},
:   %{departure_city: "Novosibirsk"},
:   %{departure_city: "Yekaterinburg"}
: ]

В подавляющем большинстве городов только один аэропорт, но есть и такие города,
в которых более одного аэропорта.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT city, count(*)
    FROM airports
   GROUP BY city
  HAVING count(*) > 1;
#+END_SRC

#+RESULTS:
| city      | count |
|-----------+-------|
| Ulyanovsk |     2 |
| Moscow    |     3 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    group_by: a.city,
    having: count() > 1,
    select: map(a, [:city]),
    select_merge: %{num_airports: count()}

  # macro example
  Airport
  |> group_by([a], a.city)
  |> having(count() > 1)
  |> select([a], map(a, [:city]))
  |> select_merge(%{num_airports: count()})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 11:05:53.109 [debug] QUERY OK source="airports" db=0.3ms idle=1069.8ms
: SELECT a0."city", count(*) FROM "airports" AS a0 GROUP BY a0."city" HAVING (count(*) > 1) []
: >>> : [%{city: "Ulyanovsk", num_airports: 2}, %{city: "Moscow", num_airports: 3}]

Кроме обычных агрегатных функций существуют и так называемые *оконные функции*
(*window functions*). Эти функции предоставляют возможность производить
вычисления на множестве строк, логически связанных с текущей строкой, т.е.
имеющих то или иное отношение к ней.

При работе с оконными функциями используются концепции *раздела* (*partition*) и
*оконного кадра* (*window frame*).

Предположим, что руководство нашей компании хочет усовершенствовать тарифную
политику и с этой целью просит нас предоставить сведения о распределении
количества проданных билетов на некоторые рейсы во времени. Количество проданных
билетов должно выводиться в виде накопленного показателя, суммирование должно
производиться в пределах каждого календарного месяца.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT b.book_ref,
         b.book_date,
         extract('month' from b.book_date) AS month,
         extract('day' from b.book_date) AS day,
         count(*) OVER (
           PARTITION BY date_trunc('month', b.book_date)
           ORDER BY b.book_date
         ) AS count
    FROM ticket_flights tf
         JOIN tickets t
             ON tf.ticket_no = t.ticket_no
         JOIN bookings b
             ON t.book_ref = b.book_ref
   WHERE tf.flight_id = 2
   ORDER BY b.book_date
   LIMIT 13;
#+END_SRC

Таким образом, в нашем примере в качестве *раздела* (*partition*) будет
выступать множество строк, у которых даты продажи билета (т.е. даты
бронирования) относятся кодному и тому же месяцу. В результате в полученной
выборке, пример которой приведен ниже, будет сформировано два раздела.

#+RESULTS:
| book_ref | book_date                | month | day | count |
|----------+--------------------------+-------+-----+-------|
| BB5AB9   | 2017-05-08 01:19:00+02   |     5 |   8 |     1 |
| /06979C/ | *2017-05-12 12:57:00+02* |     5 |  12 |   *3* |
| /06979C/ | *2017-05-12 12:57:00+02* |     5 |  12 |   *3* |
| 9DC422   | 2017-05-14 02:42:00+02   |     5 |  14 |     4 |
| /3C0E7C/ | *2017-05-14 10:43:00+02* |     5 |  14 |   *6* |
| /3C0E7C/ | *2017-05-14 10:43:00+02* |     5 |  14 |   *6* |
| EC77FB   | 2017-05-15 04:42:00+02   |     5 |  15 |     7 |
| E0A9F8   | 2017-05-15 08:26:00+02   |     5 |  15 |     8 |
| EFA312   | 2017-05-15 12:40:00+02   |     5 |  15 |     9 |
| /759BF2/ | *2017-05-16 02:51:00+02* |     5 |  16 |  *11* |
| /759BF2/ | *2017-05-16 02:51:00+02* |     5 |  16 |  *11* |
| E03513   | 2017-05-16 06:31:00+02   |     5 |  16 |    12 |
| 37F9FF   | 2017-05-17 00:31:00+02   |     5 |  17 |    13 |

Понятие *оконного кадра* (*window frame*) является важным, поскольку многие
оконные функции работают не со всеми строками раздела, а только с теми, которые
образуют оконный кадр текущей строки. Если строки в разделе не упорядочены, то
оконным кадром текущей строки по умолчанию считается множество всех строк
раздела. Однако в том случае, когда строки в разделе упорядочены по какому-то
критерию, тогда в состав оконного кадра по умолчанию включаются строки, начиная
с первой строки раздела и заканчивая текущей строкой. Если же существуют строки,
имеющие такое же значение критерия сортировки, что и текущая строка, и
расположенные после нее, то они также включаются в состав оконного кадра текущей
строки.

#+BEGIN_SRC elixir :exports both :eval no
  extract = fn
    :month, from, field ->
      dynamic([{^from, q}], fragment("extract('month' FROM ?)", field(q, ^field)))

    :day, from, field ->
      dynamic([{^from, q}], fragment("extract('day' FROM ?)", field(q, ^field)))
  end

  # keyword example

  from tf in TicketFlights,
    join: t in assoc(tf, :ticket),
    join: b in assoc(t, :booking),
    as: :booking,
    where: tf.flight_id == 2,
    windows: [
      month: [
        partition_by: fragment("date_trunc('month', ?)", b.book_date),
        order_by: b.book_date
      ]
    ],
    limit: 13,
    select: map(b, [:book_ref, :book_date]),
    select_merge:
      ^%{
        month: extract.(:month, :booking, :book_date),
        day: extract.(:day, :booking, :book_date)
      },
    select_merge: %{
      count: over(count(), :month)
    }

  # macro example
  TicketFlights
  |> from(as: :ticket_flights)
  |> join(:inner, [ticket_flights: tf], t in assoc(tf, :ticket), as: :ticket)
  |> join(:inner, [ticket: t], b in assoc(t, :booking), as: :booking)
  |> where([ticket_flights: tf], tf.flight_id == 2)
  |> windows([ticket_flights: tf, booking: b],
    month: [
      partition_by: fragment("date_trunc('month', ?)", b.book_date),
      order_by: b.book_date
    ]
  )
  |> limit(13)
  |> select([booking: b], map(b, [:book_ref, :book_date]))
  |> select_merge(
    [booking: b],
    ^%{
      month: extract.(:month, :booking, :book_date),
      day: extract.(:day, :booking, :book_date)
    }
  )
  |> select_merge(%{
    count: over(count(), :month)
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 11:56:54.104 [debug] QUERY OK source="ticket_flights" db=98.3ms queue=0.3ms idle=1858.3ms
: SELECT b2."book_ref", b2."book_date", extract('day' FROM b2."book_date"), extract('month' FROM b2."book_date"), count(*) OVER "month" FROM "ticket_flights" AS t0 INNER JOIN "tickets" AS t1 ON t1."ticket_no" = t0."ticket_no" INNER JOIN "bookings" AS b2 ON b2."book_ref" = t1."book_ref" WHERE (t0."flight_id" = 2) WINDOW "month" AS (PARTITION BY date_trunc('month', b2."book_date") ORDER BY b2."book_date") LIMIT 13 []
: >>> :
: [
:   %{book_date: ~U[2017-05-07 23:19:00Z], book_ref: "BB5AB9", count: 1, day: Decimal.new("8"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-12 10:57:00Z], book_ref: "06979C", count: 3, day: Decimal.new("12"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-12 10:57:00Z], book_ref: "06979C", count: 3, day: Decimal.new("12"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-14 00:42:00Z], book_ref: "9DC422", count: 4, day: Decimal.new("14"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-14 08:43:00Z], book_ref: "3C0E7C", count: 6, day: Decimal.new("14"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-14 08:43:00Z], book_ref: "3C0E7C", count: 6, day: Decimal.new("14"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-15 02:42:00Z], book_ref: "EC77FB", count: 7, day: Decimal.new("15"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-15 06:26:00Z], book_ref: "E0A9F8", count: 8, day: Decimal.new("15"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-15 10:40:00Z], book_ref: "EFA312", count: 9, day: Decimal.new("15"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-16 00:51:00Z], book_ref: "759BF2", count: 11, day: Decimal.new("16"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-16 00:51:00Z], book_ref: "759BF2", count: 11, day: Decimal.new("16"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-16 04:31:00Z], book_ref: "E03513", count: 12, day: Decimal.new("16"), month: Decimal.new("5")},
:   %{book_date: ~U[2017-05-16 22:31:00Z], book_ref: "37F9FF", count: 13, day: Decimal.new("17"), month: Decimal.new("5")}
: ]

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  count(*) OVER (
    PARTITION BY date_trunc('month', b.book_date)
    ORDER BY b.book_date
  ) AS count
#+END_SRC

В этой конструкции обязательным является ключевое слово ~OVER~. Функция ~count~
— это обычная агрегатная функция, но если вслед за ней идет это ключевое слово,
то она становится оконной функцией. Предложение ~PARTITION BY~ задает правило
разбиения строк выборки на разделы. Предложение ~ORDER BY~ предписывает порядок
сортировки строк в разделах.

Обобщая приведенные объяснения, можно сказать, что раздел включает в себя все
строки выборки, имеющие в некотором смысле одинаковые свойства, например,
одинаковые значения определенных выражений, задаваемых с помощью предложения
~PARTITION BY~. Это могут быть выражения, построенные на основе одного или
нескольких столбцов таблицы (или таблиц, участвующих в соединении).

Оконный кадр состоит из подмножества строк данного раздела и привязан к текущей
строке. Для определения границ кадра важным является наличие предложения ~ORDER
BY~ при формировании раздела.

Оконные функции, в отличие от обычных агрегатных функций, не требуют группировки
строк, а работают на уровне отдельных (не сгруппированных) строк. Однако если в
запросе присутствуют предложения ~GROUP BY~ и ~HAVING~, тогда оконные функции
вызываются уже после них. В таком случае оконные функции будут работать со
строками, являющимися результатом группировки.

Рассмотрим еще один пример. Покажем, как с помощью оконной функции ~rank~ можно
проранжировать аэропорты в пределах каждого часового пояса на основе их
географической широты. Причем будем присваивать более высокий ранг тому
аэропорту, который находится севернее.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT airport_name,
         city,
         round(coordinates[1]::numeric, 2) AS ltd,
         timezone,
         rank() OVER (
           PARTITION BY timezone
           ORDER BY coordinates[1] DESC
         )
    FROM airports
   WHERE timezone IN ('Asia/Irkutsk', 'Asia/Krasnoyarsk')
   ORDER BY timezone, rank;
#+END_SRC

#+RESULTS:
| airport_name               | city          |   ltd | timezone         | rank |
|----------------------------+---------------+-------+------------------+------|
| Ust-Ilimsk Airport         | Ust Ilimsk    | 58.14 | Asia/Irkutsk     |    1 |
| Ust-Kut Airport            | Ust-Kut       | 56.86 | Asia/Irkutsk     |    2 |
| Bratsk Airport             | Bratsk        | 56.37 | Asia/Irkutsk     |    3 |
| Irkutsk Airport            | Irkutsk       | 52.27 | Asia/Irkutsk     |    4 |
| Ulan-Ude Airport (Mukhino) | Ulan-ude      | 51.81 | Asia/Irkutsk     |    5 |
| Norilsk-Alykel Airport     | Norilsk       | 69.31 | Asia/Krasnoyarsk |    1 |
| Strezhevoy Airport         | Strezhevoy    | 60.71 | Asia/Krasnoyarsk |    2 |
| Bogashevo Airport          | Tomsk         | 56.38 | Asia/Krasnoyarsk |    3 |
| Yemelyanovo Airport        | Krasnoyarsk   | 56.17 | Asia/Krasnoyarsk |    4 |
| Abakan Airport             | Abakan        | 53.74 | Asia/Krasnoyarsk |    5 |
| Barnaul Airport            | Barnaul       | 53.36 | Asia/Krasnoyarsk |    6 |
| Gorno-Altaysk Airport      | Gorno-Altaysk | 51.97 | Asia/Krasnoyarsk |    7 |
| Kyzyl Airport              | Kyzyl         | 51.67 | Asia/Krasnoyarsk |    8 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    where: a.timezone in ["Asia/Irkutsk", "Asia/Krasnoyarsk"],
    order_by: [a.timezone, selected_as(:rank)],
    windows: [
      timezone: [
        partition_by: a.timezone,
        order_by: [desc: fragment("?[1]", a.coordinates)]
      ]
    ],
    select: map(a, [:airport_name, :timezone]),
    select_merge: %{
      ltd: fragment("round(?[1]::numeric, 2)", a.coordinates),
      rank: selected_as(over(rank(), :timezone), :rank)
    }

  # macro example
  Airport
  |> where([a], a.timezone in ["Asia/Irkutsk", "Asia/Krasnoyarsk"])
  |> order_by([a], [a.timezone, selected_as(:rank)])
  |> windows([a],
    timezone: [
      partition_by: a.timezone,
      order_by: [desc: fragment("?[1]", a.coordinates)]
    ]
  )
  |> select([a], map(a, [:airport_name, :timezone]))
  |> select_merge([a], %{
    ltd: fragment("round(?[1]::numeric, 2)", a.coordinates),
    rank: selected_as(over(rank(), :timezone), :rank)
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 12:19:47.783 [debug] QUERY OK source="airports" db=0.3ms idle=1050.3ms
: SELECT a0."airport_name", a0."timezone", round(a0."coordinates"[1]::numeric, 2), rank() OVER "timezone" AS "rank" FROM "airports" AS a0 WHERE (a0."timezone" IN ('Asia/Irkutsk','Asia/Krasnoyarsk')) WINDOW "timezone" AS (PARTITION BY a0."timezone" ORDER BY a0."coordinates"[1] DESC) ORDER BY a0."timezone", "rank" []
: >>> :
: [
:   %{airport_name: "Ust-Ilimsk Airport", ltd: Decimal.new("58.14"), rank: 1, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Ust-Kut Airport", ltd: Decimal.new("56.86"), rank: 2, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Bratsk Airport", ltd: Decimal.new("56.37"), rank: 3, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Irkutsk Airport", ltd: Decimal.new("52.27"), rank: 4, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Ulan-Ude Airport (Mukhino)", ltd: Decimal.new("51.81"), rank: 5, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Norilsk-Alykel Airport", ltd: Decimal.new("69.31"), rank: 1, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Strezhevoy Airport", ltd: Decimal.new("60.71"), rank: 2, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Bogashevo Airport", ltd: Decimal.new("56.38"), rank: 3, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Yemelyanovo Airport", ltd: Decimal.new("56.17"), rank: 4, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Abakan Airport", ltd: Decimal.new("53.74"), rank: 5, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Barnaul Airport", ltd: Decimal.new("53.36"), rank: 6, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Gorno-Altaysk Airport", ltd: Decimal.new("51.97"), rank: 7, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Kyzyl Airport", ltd: Decimal.new("51.67"), rank: 8, timezone: "Asia/Krasnoyarsk"}
: ]

Усложним запрос — для каждого аэропорта будем вычислять разницу между его
географической широтой и широтой, на которой находится самый северный аэропортв
этом же часовом поясе. Поскольку в запросе используются три конструкции с
оконными функциями и при этом способ формирования разделов и порядок сортировки
строк в разделах один и тот же, то вводится предложение ~WINDOW~. Оно позволяет
создать определение раздела, а затем ссылаться на него при вызове оконных
функций. Самый северный аэропорт в каждом часовом поясе, т.е. самая первая
строка в каждом разделе, выбирается с помощью оконной функции ~first_value~.
Строго говоря, эта функция получает доступ к первой строке оконного кадра, а не
раздела. Однако когда используются правила формирования оконного кадра по
умолчанию, тогда его начало совпадает с началом раздела.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT airport_name,
         city,
         timezone,
         coordinates[1] AS ltd,
         first_value(coordinates[1])                  OVER tz AS first_in_timezone,
         coordinates[1] - first_value(coordinates[1]) OVER tz AS delta,
         rank()                                       OVER tz
    FROM airports
   WHERE timezone IN ('Asia/Irkutsk', 'Asia/Krasnoyarsk')
  WINDOW tz AS (PARTITION BY timezone ORDER BY coordinates[1] DESC)
   ORDER BY timezone, rank;
#+END_SRC

#+RESULTS:
| airport_name               | city          | timezone         |                lts | first_in_timezone |               delta | rank |
|----------------------------+---------------+------------------+--------------------+-------------------+---------------------+------|
| Ust-Ilimsk Airport         | Ust Ilimsk    | Asia/Irkutsk     |  58.13610076904297 | 58.13610076904297 |                   0 |    1 |
| Ust-Kut Airport            | Ust-Kut       | Asia/Irkutsk     |   56.8567008972168 | 58.13610076904297 | -1.2793998718261719 |    2 |
| Bratsk Airport             | Bratsk        | Asia/Irkutsk     | 56.370601654052734 | 58.13610076904297 | -1.7654991149902344 |    3 |
| Irkutsk Airport            | Irkutsk       | Asia/Irkutsk     |    52.268001556396 | 58.13610076904297 | -5.8680992126469675 |    4 |
| Ulan-Ude Airport (Mukhino) | Ulan-ude      | Asia/Irkutsk     |  51.80780029296875 | 58.13610076904297 |  -6.328300476074219 |    5 |
| Norilsk-Alykel Airport     | Norilsk       | Asia/Krasnoyarsk |  69.31109619140625 | 69.31109619140625 |                   0 |    1 |
| Strezhevoy Airport         | Strezhevoy    | Asia/Krasnoyarsk |       60.709400177 | 69.31109619140625 |   -8.60169601440625 |    2 |
| Bogashevo Airport          | Tomsk         | Asia/Krasnoyarsk |    56.380298614502 | 69.31109619140625 | -12.930797576904247 |    3 |
| Yemelyanovo Airport        | Krasnoyarsk   | Asia/Krasnoyarsk |    56.172901153564 | 69.31109619140625 | -13.138195037842252 |    4 |
| Abakan Airport             | Abakan        | Asia/Krasnoyarsk |   53.7400016784668 | 69.31109619140625 | -15.571094512939453 |    5 |
| Barnaul Airport            | Barnaul       | Asia/Krasnoyarsk | 53.363800048828125 | 69.31109619140625 | -15.947296142578125 |    6 |
| Gorno-Altaysk Airport      | Gorno-Altaysk | Asia/Krasnoyarsk |      51.9667015076 | 69.31109619140625 |  -17.34439468380625 |    7 |
| Kyzyl Airport              | Kyzyl         | Asia/Krasnoyarsk |  51.66939926147461 | 69.31109619140625 |  -17.64169692993164 |    8 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    where: a.timezone in ["Asia/Irkutsk", "Asia/Krasnoyarsk"],
    order_by: [a.timezone, selected_as(:rank)],
    windows: [
      tz: [
        partition_by: a.timezone,
        order_by: [desc: fragment("?[1]", a.coordinates)]
      ]
    ],
    select: map(a, [:airport_name, :city, :timezone]),
    select_merge: %{
      ltd: fragment("?[1]", a.coordinates),
      first_in_timezone: over(first_value(fragment("?[1]", a.coordinates)), :tz),
      delta:
        over(
          fragment("?[1] - ?", a.coordinates, first_value(fragment("?[1]", a.coordinates))),
          :tz
        ),
      rank: selected_as(over(rank(), :tz), :rank)
    }

  # macro example
  Airport
  |> where([a], a.timezone in ["Asia/Irkutsk", "Asia/Krasnoyarsk"])
  |> order_by([a], [a.timezone, selected_as(:rank)])
  |> windows([a],
    tz: [
      partition_by: a.timezone,
      order_by: [desc: fragment("?[1]", a.coordinates)]
    ]
  )
  |> select([a], map(a, [:airport_name, :city, :timezone]))
  |> select_merge([a], %{
    ltd: fragment("?[1]", a.coordinates),
    first_in_timezone: over(first_value(fragment("?[1]", a.coordinates)), :tz),
    delta:
      over(fragment("?[1] - ?", a.coordinates, first_value(fragment("?[1]", a.coordinates))), :tz),
    rank: selected_as(over(rank(), :tz), :rank)
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 12:26:48.564 [debug] QUERY OK source="airports" db=0.7ms idle=1940.9ms
: SELECT a0."airport_name", a0."city", a0."timezone", a0."coordinates"[1], first_value(a0."coordinates"[1]) OVER "tz", a0."coordinates"[1] - first_value(a0."coordinates"[1]) OVER "tz", rank() OVER "tz" AS "rank" FROM "airports" AS a0 WHERE (a0."timezone" IN ('Asia/Irkutsk','Asia/Krasnoyarsk')) WINDOW "tz" AS (PARTITION BY a0."timezone" ORDER BY a0."coordinates"[1] DESC) ORDER BY a0."timezone", "rank" []
: >>> :
: [
:   %{airport_name: "Ust-Ilimsk Airport", city: "Ust Ilimsk", delta: 0.0, first_in_timezone: 58.13610076904297, ltd: 58.13610076904297, rank: 1, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Ust-Kut Airport", city: "Ust-Kut", delta: -1.2793998718261719, first_in_timezone: 58.13610076904297, ltd: 56.8567008972168, rank: 2, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Bratsk Airport", city: "Bratsk", delta: -1.7654991149902344, first_in_timezone: 58.13610076904297, ltd: 56.370601654052734, rank: 3, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Irkutsk Airport", city: "Irkutsk", delta: -5.8680992126469675, first_in_timezone: 58.13610076904297, ltd: 52.268001556396, rank: 4, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Ulan-Ude Airport (Mukhino)", city: "Ulan-ude", delta: -6.328300476074219, first_in_timezone: 58.13610076904297, ltd: 51.80780029296875, rank: 5, timezone: "Asia/Irkutsk"},
:   %{airport_name: "Norilsk-Alykel Airport", city: "Norilsk", delta: 0.0, first_in_timezone: 69.31109619140625, ltd: 69.31109619140625, rank: 1, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Strezhevoy Airport", city: "Strezhevoy", delta: -8.60169601440625, first_in_timezone: 69.31109619140625, ltd: 60.709400177, rank: 2, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Bogashevo Airport", city: "Tomsk", delta: -12.930797576904247, first_in_timezone: 69.31109619140625, ltd: 56.380298614502, rank: 3, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Yemelyanovo Airport", city: "Krasnoyarsk", delta: -13.138195037842252, first_in_timezone: 69.31109619140625, ltd: 56.172901153564, rank: 4, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Abakan Airport", city: "Abakan", delta: -15.571094512939453, first_in_timezone: 69.31109619140625, ltd: 53.7400016784668, rank: 5, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Barnaul Airport", city: "Barnaul", delta: -15.947296142578125, first_in_timezone: 69.31109619140625, ltd: 53.363800048828125, rank: 6, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Gorno-Altaysk Airport", city: "Gorno-Altaysk", delta: -17.34439468380625, first_in_timezone: 69.31109619140625, ltd: 51.9667015076, rank: 7, timezone: "Asia/Krasnoyarsk"},
:   %{airport_name: "Kyzyl Airport", city: "Kyzyl", delta: -17.64169692993164, first_in_timezone: 69.31109619140625, ltd: 51.66939926147461, rank: 8, timezone: "Asia/Krasnoyarsk"}
: ]
** Подзапросы
Опишем, как в общем случае работает команда ~SELECT~. Согласно описанию этой
команды, приведенному в документации, дело, в несколько упрощенном виде, обстоит
так:
1. Сначала вычисляются все элементы, приведенные в списке после ключевого слова
   ~FROM~. Под такими элементами подразумеваются не только реальные таблицы, но
   также и виртуальные таблицы, создаваемые с помощью ключевого слова ~VALUES~.
   Если таблиц больше одной, то формируется декартово произведение из множеств
   их строк. Например, в случае двух таблиц будут сформированы попарные
   комбинации каждой строки из одной таблицы с каждой строкой из другой таблицы.
   При этом в комбинированных строках сохраняются все атрибуты из каждой
   исходной таблицы.
2. Если в команде присутствует условие ~WHERE~, то из полученного декартова
   произведения исключаются строки, которые этому условию не соответствуют.
   Таким образом, первоначальное множество строк, сформированное без всяких
   условий, сужается.
3. Если присутствует предложение ~GROUP BY~, то результирующие строки
   группируются на основе совпадения значений одного или нескольких атрибутов, а
   затем вычисляются значения агрегатных функций. Если присутствует предложение
   ~HAVING~, то оно отфильтровывает результирующие строки (группы), не
   удовлетворяющие критерию.
4. Ключевое слово ~SELECT~ присутствует всегда. Но в списке выражений, идущих
   после него, могут быть не только простые имена атрибутов, но и их комбинации,
   созданные с использованием арифметических и других операций, а также вызовы
   функций. Причем эти функции могут быть не только встроенные, но и созданные
   пользователем. В списке выражений не обязаны присутствовать все атрибуты,
   представленные в строках используемых таблиц. Например, атрибуты, на основе
   которых формируются условия в предложении ~WHERE~, могут отсутствовать в
   списке выражений после ключевого слова ~SELECT~. Предложение ~SELECT
   DISTINCT~ удаляет дубликаты строк.
5. Если присутствует предложение ~ORDER BY~, то результирующие строки
   сортируются на основе значений одного или нескольких атрибутов. По умолчанию
   сортировка производится по возрастанию значений.
6. Если присутствует предложение ~LIMIT~ или ~OFFSET~, то возвращается только
   подмножество строк из выборки.

Приведенная схема описывает работу команды ~SELECT~ на логическом уровне, а на
уровне реализации запросов в дело вступает планировщик, который и формирует план
выполнения запроса.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM bookings
   WHERE total_amount > (
     SELECT avg(total_amount) FROM bookings
   );
#+END_SRC

#+RESULTS:
|  count |
|--------|
| 703366 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  avg_total_query =
    from b in Booking,
      select: avg(b.total_amount)

  from b in Booking,
    where: b.total_amount > subquery(avg_total_query),
    select: count()

  # macro example
  avg_total_query = select(Booking, [b], avg(b.total_amount))

  Booking
  |> where([b], b.total_amount > subquery(avg_total_query))
  |> select([b], count())

  # shortcut example
  Booking
  |> where([b], b.total_amount > subquery(select(Booking, [b], avg(b.total_amount))))
  |> Repo.aggregate(:count)
#+END_SRC

#+RESULTS:
# 13:02:01.777 [debug] QUERY OK source="bookings" db=137.6ms idle=1653.1ms
# SELECT count(*) FROM "bookings" AS b0 WHERE (b0."total_amount" > (SELECT avg(sb0."total_amount") FROM "bookings" AS sb0)) []
# >>> : 703366

В приведенном запросе присутствует два предложения ~SELECT~, но при этом только
одно из них является главным в этом запросе, а другое представляет собой
*подзапрос*. Он заключается в круглые скобки и является частью более общего
запроса. Подзапросы могут присутствовать в предложениях ~SELECT~, ~FROM~,
~WHERE~ и ~HAVING~, а также в предложении ~WITH~.

В приведенном примере в предложении ~WHERE~ используется так называемый
*скалярный подзапрос*. Это означает, что в результате его выполнения
возвращается только одно скалярное значение (один столбец и одна строка), с
которым можно сравнивать другие скалярные значения.

Если подзапрос выдает множество скалярных значений (или даже только одно), можно
использовать такой *подзапрос в предикате IN*. Этот предикат позволяет
организовать проверку на предмет принадлежности какого-либо значения
определенному множеству значений.

В качестве примера давайте выясним, какие маршруты существуют между городами
часового пояса ~Asia/Krasnoyarsk~. Подзапрос будет выдавать список городов из
этого часового пояса, а в предложении ~WHERE~ главного запроса с помощью
предиката ~IN~ будет выполняться проверка на принадлежность города этому списку.
При этом подзапрос выполняется только один раз для всего внешнего запроса, а не
при обработке каждой строки из таблицы ~routes~ во внешнем запросе. Повторного
выполнения подзапроса не требуется, т.к. его результат не зависит от значений,
хранящихсяв таблице ~routes~. Такие подзапросы называются *некоррелированными*.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT flight_no,
         departure_city,
         arrival_city
    FROM routes
   WHERE departure_city IN (
       SELECT city
         FROM airports
        WHERE timezone ~ 'Krasnoyarsk'
     )
     AND arrival_city IN (
       SELECT city
         FROM airports
        WHERE timezone ~ 'Krasnoyarsk'
     );
#+END_SRC

#+RESULTS:
| flight_no | departure_city | arrival_city |
|-----------+----------------+--------------|
| PG0070    | Abakan         | Tomsk        |
| PG0071    | Tomsk          | Abakan       |
| PG0313    | Abakan         | Kyzyl        |
| PG0314    | Kyzyl          | Abakan       |
| PG0653    | Krasnoyarsk    | Barnaul      |
| PG0654    | Barnaul        | Krasnoyarsk  |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  cities_query =
    from a in Airport,
      where: fragment("? ~ 'Krasnoyarsk'", a.timezone),
      select: a.city

  from r in Route,
    where: r.departure_city in subquery(cities_query),
    where: r.arrival_city in subquery(cities_query),
    select: map(r, [:flight_no, :departure_city, :arrival_city])

  # macro example
  cities_query =
    Airport
    |> where([a], fragment("? ~ 'Krasnoyarsk'", a.timezone))
    |> select([a], a.city)

  Route
  |> where([r], r.departure_city in subquery(cities_query))
  |> where([r], r.arrival_city in subquery(cities_query))
  |> select([r], map(r, [:flight_no, :departure_city, :arrival_city]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 17:44:06.301 [debug] QUERY OK source="routes" db=151.0ms idle=1566.7ms
: SELECT r0."flight_no", r0."departure_city", r0."arrival_city" FROM "routes" AS r0 WHERE (r0."departure_city" IN (SELECT sa0."city" FROM "airports" AS sa0 WHERE (sa0."timezone" ~ 'Krasnoyarsk'))) AND (r0."arrival_city" IN (SELECT sa0."city" FROM "airports" AS sa0 WHERE (sa0."timezone" ~ 'Krasnoyarsk'))) []
: >>> :
: [
:   %{arrival_city: "Tomsk", departure_city: "Abakan", flight_no: "PG0070"},
:   %{arrival_city: "Abakan", departure_city: "Tomsk", flight_no: "PG0071"},
:   %{arrival_city: "Kyzyl", departure_city: "Abakan", flight_no: "PG0313"},
:   %{arrival_city: "Abakan", departure_city: "Kyzyl", flight_no: "PG0314"},
:   %{arrival_city: "Barnaul", departure_city: "Krasnoyarsk", flight_no: "PG0653"},
:   %{arrival_city: "Krasnoyarsk", departure_city: "Barnaul", flight_no: "PG0654"}
: ]

Можно сформировать множество значений для предиката ~IN~ с помощью скалярных
подзапросов. Если мы захотим найти самый западный и самый восточный аэропорты и
представить полученные сведения в наглядной форме, то запрос может быть таким:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT airport_name,
         city,
         coordinates[1] AS longitude
    FROM airports
   WHERE coordinates[1] IN (
     ( SELECT max(coordinates[1]) FROM airports ),
     ( SELECT min(coordinates[1]) FROM airports )
   );
#+END_SRC

#+RESULTS:
| airport_name           | city        |         longitude |
|------------------------+-------------+-------------------|
| Norilsk-Alykel Airport | Norilsk     | 69.31109619140625 |
| Uytash Airport         | Makhachkala | 42.81679916381836 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  from a in Airport,
    where: fragment("?[1]", a.coordinates) in [subquery(east_airport), subquery(west_airport)],
    select: map(a, [:airport_name, :city]),
    select_merge: %{longitude: fragment("?[1]", a.coordinates)}

  # macro example
  east_airport = select(Airport, max(fragment("?[1]", a.coordinates)))
  west_airport = select(Airport, min(fragment("?[1]", a.coordinates)))

  Airport
  |> where([a], fragment("?[1]", a.coordinates) in [subquery(east_airport), subquery(west_airport)])
  |> select([a], map(a, [:airport_name, :city]))
  |> select_merge([a], %{longitude: fragment("?[1]", a.coordinates)})
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 18:22:29.508 [debug] QUERY OK source="airports" db=0.6ms idle=1454.7ms
: SELECT a0."airport_name", a0."city", a0."coordinates"[1] FROM "airports" AS a0 WHERE (a0."coordinates"[1] IN ((SELECT max(sa0."coordinates"[1]) FROM "airports" AS sa0),(SELECT min(sa0."coordinates"[1]) FROM "airports" AS sa0))) []
: >>> :
: [
:   %{airport_name: "Norilsk-Alykel Airport", city: "Norilsk", longitude: 69.31109619140625},
:   %{airport_name: "Uytash Airport", city: "Makhachkala", longitude: 42.81679916381836}
: ]

Конечно, в случае, когда необходимо, наоборот, исключить какие-либо значения из
рассмотрения, можно использовать конструкцию ~NOT IN~.

Иногда возникают ситуации, когда от подзапроса требуется лишь установить сам
факт наличия или отсутствия строк в конкретной таблице, удовлетворяющих
определенному условию, а непосредственные значения атрибутов в этих строках
интереса не представляют. В подобных случаях используют предикат ~EXISTS~ (или
~NOT EXISTS~).

В качестве примера выясним, в какие города нет рейсов из Москвы.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  -- Обратите внимание на ключевое слово DISTINCT в запросе. Оно необходимо, т.к.
  -- кроме Москвы могут быть другие города, в которых есть более одного аэропорта.
  SELECT DISTINCT a.city
    FROM airports AS a
   WHERE NOT EXISTS (
       -- Поскольку от подзапроса в предикате EXISTS требуется только установить
       -- факт наличия или отсутствия строк, соответствующих критерию отбора, то в
       -- документации рекомендуется вместо списка столбцов (или символа «∗») в
       -- предложении SELECT делать так:
       SELECT 1
         FROM routes AS r
        WHERE r.departure_city = 'Moscow'
          AND r.arrival_city = a.city
     )
     AND a.city <> 'Moscow'
   ORDER BY city;
#+END_SRC

#+RESULTS:
| city               |
|--------------------|
| Blagoveschensk     |
| Cherepovets        |
| Chita              |
| Irkutsk            |
| Ivanovo            |
| Kaluga             |
| Kogalym            |
| Komsomolsk-on-Amur |
| Kyzyl              |
| Magadan            |
| Nizhnekamsk        |
| Novokuznetsk       |
| Strezhevoy         |
| Surgut             |
| Ukhta              |
| Ust Ilimsk         |
| Ust-Kut            |
| Yakutia            |
| Yakutsk            |
| Yaroslavl          |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  route_query =
    from r in Route,
      where: r.departure_city == "Moscow",
      where: r.arrival_city == parent_as(:airport).city,
      select: 1

    from a in Airport,
      as: :airport,
      where: not exists(route_query),
      where: a.city != "Moscow",
      order_by: a.city,
      select: map(a, [:city])

  # macro example
  route_query =
    Route
    |> where([r], r.departure_city == "Moscow")
    |> where([r], r.arrival_city == parent_as(:airport).city)
    |> select([r], 1)

  Airport
  |> from(as: :airport)
  |> where([a], not exists(route_query))
  |> where([a], a.city != "Moscow")
  |> order_by([a], a.city)
  |> select([a], map(a, [:city]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 08:58:35.940 [debug] QUERY OK source="airports" db=152.8ms idle=1081.2ms
: SELECT a0."city" FROM "airports" AS a0 WHERE (NOT (exists((SELECT 1 FROM "routes" AS sr0 WHERE (sr0."departure_city" = 'Moscow') AND (sr0."arrival_city" = a0."city"))))) AND (a0."city" != 'Moscow') ORDER BY a0."city" []
: >>> :
: [
:   %{city: "Blagoveschensk"},
:   %{city: "Cherepovets"},
:   %{city: "Chita"},
:   %{city: "Irkutsk"},
:   %{city: "Ivanovo"},
:   %{city: "Kaluga"},
:   %{city: "Kogalym"},
:   %{city: "Komsomolsk-on-Amur"},
:   %{city: "Kyzyl"},
:   %{city: "Magadan"},
:   %{city: "Nizhnekamsk"},
:   %{city: "Novokuznetsk"},
:   %{city: "Strezhevoy"},
:   %{city: "Surgut"},
:   %{city: "Ukhta"},
:   %{city: "Ust Ilimsk"},
:   %{city: "Ust-Kut"},
:   %{city: "Yakutia"},
:   %{city: "Yakutsk"},
:   %{city: "Yaroslavl"}
: ]

И еще одна важная деталь. В представленном запросе мы использовали так
называемый коррелированный (связанный) подзапрос. В подзапросах такого типа
присутствует ссылка (ссылки) на таблицу из внешнего запроса.

В теории это означает, что подзапрос выполняется не один раз для всего внешнего
запроса, а для каждой строки, обрабатываемой во внешнем запросе. Однако на
практике важную роль играет умение планировщика (это специальная подсистемав
СУБД) оптимизировать подобные запросы с тем, чтобы по возможности избегать
выполнения подзапроса для каждой строки из внешнего запроса.

Рассмотрим использование подзапросов в предложениях ~SELECT~, ~FROM~ и ~HAVING~.

Предположим, что для выработки ценовой политики авиакомпании необходимо знать,
как распределяются места разных классов в самолетах всех типов. Первый вариант
решения этой задачи основан на включении подзапросов в предложение ~SELECT~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT a.model,
         ( SELECT count(*)
             FROM seats AS s
            WHERE s.aircraft_code = a.aircraft_code
              AND s.fare_conditions = 'Business'
         ) AS business,
         ( SELECT count(*)
             FROM seats AS s
            WHERE s.aircraft_code = a.aircraft_code
              AND s.fare_conditions = 'Comfort'
         ) AS comfort,
         ( SELECT count(*)
             FROM seats AS s
            WHERE s.aircraft_code = a.aircraft_code
              AND s.fare_conditions = 'Economy'
         ) AS economy
    FROM aircrafts AS a
   ORDER BY 1;
#+END_SRC

#+RESULTS:
| model               | business | comfort | economy |
|---------------------+----------+---------+---------|
| Airbus A319-100     |       20 |       0 |      96 |
| Airbus A320-200     |       20 |       0 |     120 |
| Airbus A321-200     |       28 |       0 |     142 |
| Boeing 737-300      |       12 |       0 |     118 |
| Boeing 767-300      |       30 |       0 |     192 |
| Boeing 777-300      |       30 |      48 |     324 |
| Bombardier CRJ-200  |        0 |       0 |      50 |
| Cessna 208 Caravan  |        0 |       0 |      12 |
| Sukhoi Superjet-100 |       12 |       0 |      85 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  base_query =
    from s in Seat,
      where: s.aircraft_code == parent_as(:aircraft).aircraft_code,
      select: count()

  business_query =
    from s in base_query, where: s.fare_conditions == "Business"

  comfort_query =
    from s in base_query, where: s.fare_conditions == "Comfort"

  economy_query =
    from s in base_query, where: s.fare_conditions == "Economy"

  from a in Aircraft,
    as: :aircraft,
    order_by: a.model,
    select: map(a, [:model]),
    select_merge: %{
      business: subquery(business_query),
      comfort: subquery(comfort_query),
      economy: subquery(economy_query)
    }

  # macro example
  base_query =
    Seat
    |> where([s], s.aircraft_code == parent_as(:aircraft).aircraft_code)
    |> select([s], count())

  business_query = where(base_query, [s], s.fare_conditions == "Business")
  comfort_query = where(base_query, [s], s.fare_conditions == "Comfort")
  economy_query = where(base_query, [s], s.fare_conditions == "Economy")

  Aircraft
  |> from(as: :aircraft)
  |> order_by([a], a.model)
  |> select([a], map(a, [:model]))
  |> select_merge([a], %{
    business: subquery(business_query),
    comfort: subquery(comfort_query),
    economy: subquery(economy_query)
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 09:02:02.302 [debug] QUERY OK source="aircrafts" db=3.8ms idle=1607.5ms
: SELECT a0."model", (SELECT count(*) AS "result" FROM "seats" AS ss0 WHERE (ss0."aircraft_code" = a0."aircraft_code") AND (ss0."fare_conditions" = 'Business')), (SELECT count(*) AS "result" FROM "seats" AS ss0 WHERE (ss0."aircraft_code" = a0."aircraft_code") AND (ss0."fare_conditions" = 'Comfort')), (SELECT count(*) AS "result" FROM "seats" AS ss0 WHERE (ss0."aircraft_code" = a0."aircraft_code") AND (ss0."fare_conditions" = 'Economy')) FROM "aircrafts" AS a0 ORDER BY a0."model" []
: >>> :
: [
:   %{business: 20, comfort: 0, economy: 96, model: "Airbus A319-100"},
:   %{business: 20, comfort: 0, economy: 120, model: "Airbus A320-200"},
:   %{business: 28, comfort: 0, economy: 142, model: "Airbus A321-200"},
:   %{business: 12, comfort: 0, economy: 118, model: "Boeing 737-300"},
:   %{business: 30, comfort: 0, economy: 192, model: "Boeing 767-300"},
:   %{business: 30, comfort: 48, economy: 324, model: "Boeing 777-300"},
:   %{business: 0, comfort: 0, economy: 50, model: "Bombardier CRJ-200"},
:   %{business: 0, comfort: 0, economy: 12, model: "Cessna 208 Caravan"},
:   %{business: 12, comfort: 0, economy: 85, model: "Sukhoi Superjet-100"}
: ]

А в этом варианте решения задачи используется подзапрос в предложении ~FROM~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT s2.model,
         string_agg(
           s2.fare_conditions || ' (' || s2.num || ')',
           ', '
         )
    FROM (
      SELECT a.model,
             s.fare_conditions,
             count(*) AS num
        FROM aircrafts a
             JOIN seats s
                 ON a.aircraft_code = s.aircraft_code
       GROUP BY 1, 2
       ORDER BY 1, 2
      ) AS s2
     GROUP BY s2.model
   ORDER BY s2.model;
#+END_SRC

#+RESULTS:
| model               | string_agg                                 |
|---------------------+--------------------------------------------|
| Airbus A319-100     | Business (20), Economy (96)                |
| Airbus A320-200     | Business (20), Economy (120)               |
| Airbus A321-200     | Business (28), Economy (142)               |
| Boeing 737-300      | Business (12), Economy (118)               |
| Boeing 767-300      | Business (30), Economy (192)               |
| Boeing 777-300      | Business (30), Comfort (48), Economy (324) |
| Bombardier CRJ-200  | Economy (50)                               |
| Cessna 208 Caravan  | Economy (12)                               |
| Sukhoi Superjet-100 | Business (12), Economy (85)                |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  base_query =
    from a in Aircraft,
      join: s in assoc(a, :seats),
      group_by: [a.model, s.fare_conditions],
      order_by: [a.model, s.fare_conditions],
      select: map(a, [:model]),
      select_merge: map(s, [:fare_conditions]),
      select_merge: %{num: count()}

  from s in subquery(base_query),
    group_by: s.model,
    order_by: s.model,
    select: map(s, [:model]),
    select_merge: %{
      fare_conditions:
        fragment("string_agg(? || ' (' || ? || ')', ', ')", s.fare_conditions, s.num)
    }

  # macro example
  Aircraft
  |> join(:inner, [a], s in assoc(a, :seats))
  |> group_by([a, s], [a.model, s.fare_conditions])
  |> order_by([a, s], [a.model, s.fare_conditions])
  |> select([a], map(a, [:model]))
  |> select_merge([a, s], map(s, [:fare_conditions]))
  |> select_merge(%{num: count()})
  |> subquery()
  |> group_by([s], s.model)
  |> order_by([s], s.model)
  |> select([s], map(s, [:model]))
  |> select_merge([s], %{
    fare_conditions: fragment("string_agg(? || ' (' || ? || ')', ', ')", s.fare_conditions, s.num)
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 09:15:04.283 [debug] QUERY OK db=1.9ms idle=1880.4ms
: SELECT s0."model", string_agg(s0."fare_conditions" || ' (' || s0."num" || ')', ', ') FROM (SELECT sa0."model" AS "model", ss1."fare_conditions" AS "fare_conditions", count(*) AS "num" FROM "aircrafts" AS sa0 INNER JOIN "seats" AS ss1 ON ss1."aircraft_code" = sa0."aircraft_code" GROUP BY sa0."model", ss1."fare_conditions" ORDER BY sa0."model", ss1."fare_conditions") AS s0 GROUP BY s0."model" ORDER BY s0."model" []
: >>> :
: [
:   %{fare_conditions: "Business (20), Economy (96)", model: "Airbus A319-100"},
:   %{fare_conditions: "Business (20), Economy (120)", model: "Airbus A320-200"},
:   %{fare_conditions: "Business (28), Economy (142)", model: "Airbus A321-200"},
:   %{fare_conditions: "Business (12), Economy (118)", model: "Boeing 737-300"},
:   %{fare_conditions: "Business (30), Economy (192)", model: "Boeing 767-300"},
:   %{
:     fare_conditions: "Business (30), Comfort (48), Economy (324)",
:     model: "Boeing 777-300"
:   },
:   %{fare_conditions: "Economy (50)", model: "Bombardier CRJ-200"},
:   %{fare_conditions: "Economy (12)", model: "Cessna 208 Caravan"},
:   %{
:     fare_conditions: "Business (12), Economy (85)",
:     model: "Sukhoi Superjet-100"
:   }
: ]

В качестве еще одного примера использования подзапроса в предложении ~FROM~
решим такую задачу: получить перечень аэропортов в тех городах, в которых больше
одного аэропорта.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT aa.city,
         aa.airport_code,
         aa.airport_name
    FROM (
      SELECT city, count(*)
        FROM airports
       GROUP BY city
      HAVING count(*) > 1
    ) AS a
         JOIN airports AS aa
             ON a.city = aa.city
   ORDER BY aa.city, aa.airport_name;
#+END_SRC

#+RESULTS:
| city      | airport_code | airport_name                       |
|-----------+--------------+------------------------------------|
| Moscow    | DME          | Domodedovo International Airport   |
| Moscow    | SVO          | Sheremetyevo International Airport |
| Moscow    | VKO          | Vnukovo International Airport      |
| Ulyanovsk | ULV          | Ulyanovsk Baratayevka Airport      |
| Ulyanovsk | ULY          | Ulyanovsk East Airport             |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  base_query =
    from a in Airport,
      group_by: a.city,
      having: count() > 1,
      select: map(a, [:city]),
      select_merge: %{count: count()}

  from a in subquery(base_query),
    join: aa in Airport,
    on: a.city == aa.city,
    order_by: [aa.city, aa.airport_name],
    select: map(aa, [:city, :airport_code, :airport_name])

  # macro example
  Airport
  |> group_by([a], a.city)
  |> having([a], count() > 1)
  |> select([a], map(a, [:city]))
  |> select_merge(%{count: count()})
  |> subquery()
  |> join(:inner, [a], aa in Airport, on: a.city == aa.city)
  |> order_by([a, aa], [aa.city, aa.airport_name])
  |> select([a, aa], map(aa, [:city, :airport_code, :airport_name]))
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 09:18:35.533 [debug] QUERY OK db=0.7ms idle=1194.7ms
: SELECT a1."city", a1."airport_code", a1."airport_name" FROM (SELECT sa0."city" AS "city", count(*) AS "count" FROM "airports" AS sa0 GROUP BY sa0."city" HAVING (count(*) > 1)) AS s0 INNER JOIN "airports" AS a1 ON s0."city" = a1."city" ORDER BY a1."city", a1."airport_name" []
: >>> :
: [
:   %{airport_code: "DME", airport_name: "Domodedovo International Airport", city: "Moscow"},
:   %{airport_code: "SVO", airport_name: "Sheremetyevo International Airport", city: "Moscow"},
:   %{airport_code: "VKO", airport_name: "Vnukovo International Airport", city: "Moscow"},
:   %{airport_code: "ULV", airport_name: "Ulyanovsk Baratayevka Airport", city: "Ulyanovsk"},
:   %{airport_code: "ULY", airport_name: "Ulyanovsk East Airport", city: "Ulyanovsk"}
: ]

Для иллюстрации использования подзапросов в предложении ~HAVING~ решим такую
задачу: определить число маршрутов, исходящих из тех аэропортов, которые
расположены восточнее географической долготы 150◦.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT departure_airport_code,
         departure_city,
         count(*)
    FROM routes
   GROUP BY departure_airport_code, departure_city
  HAVING departure_airport_code IN (
    SELECT airport_code
      FROM airports
     WHERE coordinates[0] > 150
  )
   ORDER BY count DESC;
#+END_SRC

#+RESULTS:
| departure_airport_code | departure_city | count |
|------------------------+----------------+-------|
| DYR                    | Anadyr         |     4 |
| GDX                    | Magadan        |     3 |
| PKC                    | Petropavlovsk  |     1 |

#+BEGIN_SRC elixir :exports both :eval no
  TODO заимплементить
  # keyword example
  # macro example
#+END_SRC

#+RESULTS:

В сложных запросах могут использоваться вложенные подзапросы. Это означает, что
один подзапрос находится внутри другого. Давайте в качестве примера рассмотрим
такую ситуацию: руководство авиакомпании хочет выяснить степень заполнения
самолетов на всех рейсах, ведь отправлять полупустые самолеты не очень выгодно.
Таким образом, запрос должен не только выдавать число билетов, проданных
наданный рейс, и общее число мест в самолете, но должен также вычислять
отношение этих двух показателей.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT ts.flight_id,
         ts.flight_no,
         ts.scheduled_departure_local,
         ts.departure_city,
         ts.arrival_city,
         a.model,
         ts.fact_passengers,
         ts.total_seats,
         round(ts.fact_passengers::numeric / ts.total_seats::numeric, 2) AS fraction
    FROM ( SELECT f.flight_id,
                  f.flight_no,
                  f.scheduled_departure_local,
                  f.departure_city,
                  f.arrival_city,
                  f.aircraft_code,
                  count(tf.ticket_no) AS fact_passengers,
                  ( SELECT count(s.seat_no)
                      FROM seats s
                     WHERE s.aircraft_code = f.aircraft_code
                  ) AS total_seats
             FROM flights_v AS f
                    JOIN ticket_flights AS tf
                        ON f.flight_id = tf.flight_id
            WHERE f.status = 'Arrived'
            GROUP BY 1, 2, 3, 4, 5, 6
         ) AS ts
           JOIN aircrafts AS a ON ts.aircraft_code = a.aircraft_code
   ORDER BY ts.scheduled_departure_local
   LIMIT 10;
#+END_SRC

#+RESULTS:
| flight_id | flight_no | scheduled_departure_local | departure_city | arrival_city     | model               | fact_passengers | total_seats | fraction |
|-----------+-----------+---------------------------+----------------+------------------+---------------------+-----------------+-------------+----------|
|     61531 | PG0360    | 2016-08-15 09:00:00       | St. Petersburg | Orenburg         | Bombardier CRJ-200  |               6 |          50 |     0.12 |
|     40096 | PG0120    | 2016-08-15 09:00:00       | Moscow         | Mirnyj           | Boeing 737-300      |              35 |         130 |     0.27 |
|    182960 | PG0032    | 2016-08-15 09:00:00       | Penza          | Moscow           | Cessna 208 Caravan  |               2 |          12 |     0.17 |
|     46363 | PG0591    | 2016-08-15 09:00:00       | Moscow         | Tomsk            | Sukhoi Superjet-100 |              26 |          97 |     0.27 |
|     11346 | PG0239    | 2016-08-15 09:05:00       | Moscow         | Khanty-Mansiysk  | Sukhoi Superjet-100 |              60 |          97 |     0.62 |
|     23643 | PG0414    | 2016-08-15 09:05:00       | Moscow         | Murmansk         | Bombardier CRJ-200  |              12 |          50 |     0.24 |
|    200088 | PG0248    | 2016-08-15 09:05:00       | Sochi          | Nizhniy Novgorod | Bombardier CRJ-200  |               3 |          50 |     0.06 |
|    214043 | PG0550    | 2016-08-15 09:05:00       | Beslan         | Moscow           | Bombardier CRJ-200  |              10 |          50 |     0.20 |
|     60331 | PG0198    | 2016-08-15 09:10:00       | St. Petersburg | Irkutsk          | Airbus A321-200     |              20 |         170 |     0.12 |
|      9249 | PG0509    | 2016-08-15 09:15:00       | Moscow         | Elista           | Sukhoi Superjet-100 |              13 |          97 |     0.13 |

#+BEGIN_SRC elixir :exports both :eval no
  # keyword example
  seats_query =
    from s in Seat,
      where: s.aircraft_code == parent_as(:flight).aircraft_code,
      select: count(s.seat_no)

  tickets_query =
    from f in FlightExtended,
      as: :flight,
      join: tf in TicketFlights,
      on: f.flight_id == tf.flight_id,
      where: f.status == "Arrived",
      group_by: [
        f.flight_id,
        f.flight_no,
        f.scheduled_departure_local,
        f.departure_city,
        f.arrival_city,
        f.aircraft_code
      ],
      select:
        map(f, [
          :flight_id,
          :flight_no,
          :scheduled_departure_local,
          :departure_city,
          :arrival_city,
          :aircraft_code
        ]),
      select_merge: %{
        fact_passengers: selected_as(count(tf.ticket_no), :fact_passengers),
        total_seats: selected_as(subquery(seats_query), :total_seats)
      }

  from ts in subquery(tickets_query),
    join: a in Aircraft,
    on: ts.aircraft_code == a.aircraft_code,
    order_by: ts.scheduled_departure_local,
    limit: 10,
    select:
      map(ts, [
        :flight_id,
        :flight_no,
        :scheduled_departure_local,
        :departure_city,
        :arrival_city,
        :fact_passengers,
        :total_seats
      ]),
    select_merge: map(a, [:model]),
    select_merge: %{
      fraction:
        type(
          fragment("round(?::numeric / ?::numeric, 2)", ts.fact_passengers, ts.total_seats),
          :float
        )
    }

  # macro example
  seats_query =
    Seat
    |> where([s], s.aircraft_code == parent_as(:flight).aircraft_code)
    |> select([s], count(s.seat_no))

  tickets_query =
    FlightExtended
    |> from(as: :flight)
    |> join(:inner, [f], tf in TicketFlights, on: f.flight_id == tf.flight_id)
    |> where([f], f.status == "Arrived")
    |> group_by([f], [
      f.flight_id,
      f.flight_no,
      f.scheduled_departure_local,
      f.departure_city,
      f.arrival_city,
      f.aircraft_code
    ])
    |> select(
      [f],
      map(f, [
        :flight_id,
        :flight_no,
        :scheduled_departure_local,
        :departure_city,
        :arrival_city,
        :aircraft_code
      ])
    )
    |> select_merge(
      [f, tf],
      %{
        fact_passengers: selected_as(count(tf.ticket_no), :fact_passengers),
        total_seats: selected_as(subquery(seats_query), :total_seats)
      }
    )

  tickets_query
  |> subquery()
  |> join(:inner, [ts], a in Aircraft, on: ts.aircraft_code == a.aircraft_code)
  |> order_by([ts], ts.scheduled_departure_local)
  |> limit(10)
  |> select(
    [ts],
    map(ts, [
      :flight_id,
      :flight_no,
      :scheduled_departure_local,
      :departure_city,
      :arrival_city,
      :fact_passengers,
      :total_seats
    ])
  )
  |> select_merge([ts, a], map(a, [:model]))
  |> select_merge([ts], %{
    fraction:
      type(
        fragment("round(?::numeric / ?::numeric, 2)", ts.fact_passengers, ts.total_seats),
        :float
      )
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 12:00:35.090 [debug] QUERY OK db=7586.0ms idle=1199.8ms
: SELECT s0."flight_id", s0."flight_no", s0."scheduled_departure_local", s0."departure_city", s0."arrival_city", s0."fact_passengers", s0."total_seats", a1."model", round(s0."fact_passengers"::numeric / s0."total_seats"::numeric, 2) FROM (SELECT sf0."flight_id" AS "flight_id", sf0."flight_no" AS "flight_no", sf0."scheduled_departure_local" AS "scheduled_departure_local", sf0."departure_city" AS "departure_city", sf0."arrival_city" AS "arrival_city", sf0."aircraft_code" AS "aircraft_code", count(st1."ticket_no") AS "fact_passengers", (SELECT count(sss0."seat_no") AS "result" FROM "seats" AS sss0 WHERE (sss0."aircraft_code" = sf0."aircraft_code")) AS "total_seats" FROM "flights_v" AS sf0 INNER JOIN "ticket_flights" AS st1 ON sf0."flight_id" = st1."flight_id" WHERE (sf0."status" = 'Arrived') GROUP BY sf0."flight_id", sf0."flight_no", sf0."scheduled_departure_local", sf0."departure_city", sf0."arrival_city", sf0."aircraft_code") AS s0 INNER JOIN "aircrafts" AS a1 ON s0."aircraft_code" = a1."aircraft_code" ORDER BY s0."scheduled_departure_local" LIMIT 10 []
: >>> :
: [
:   %{arrival_city: "Orenburg", departure_city: "St. Petersburg", fact_passengers: 6, flight_id: 61531, flight_no: "PG0360", fraction: 0.12, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 50},
:   %{arrival_city: "Mirnyj", departure_city: "Moscow", fact_passengers: 35, flight_id: 40096, flight_no: "PG0120", fraction: 0.27, model: "Boeing 737-300", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 130},
:   %{arrival_city: "Moscow", departure_city: "Penza", fact_passengers: 2, flight_id: 182960, flight_no: "PG0032", fraction: 0.17, model: "Cessna 208 Caravan", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 12},
:   %{arrival_city: "Tomsk", departure_city: "Moscow", fact_passengers: 26, flight_id: 46363, flight_no: "PG0591", fraction: 0.27, model: "Sukhoi Superjet-100", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 97},
:   %{arrival_city: "Nizhniy Novgorod", departure_city: "Sochi", fact_passengers: 3, flight_id: 200088, flight_no: "PG0248", fraction: 0.06, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 50},
:   %{arrival_city: "Moscow", departure_city: "Beslan", fact_passengers: 10, flight_id: 214043, flight_no: "PG0550", fraction: 0.2, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 50},
:   %{arrival_city: "Khanty-Mansiysk", departure_city: "Moscow", fact_passengers: 60, flight_id: 11346, flight_no: "PG0239", fraction: 0.62, model: "Sukhoi Superjet-100", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 97},
:   %{arrival_city: "Murmansk", departure_city: "Moscow", fact_passengers: 12, flight_id: 23643, flight_no: "PG0414", fraction: 0.24, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 50},
:   %{arrival_city: "Irkutsk", departure_city: "St. Petersburg", fact_passengers: 20, flight_id: 60331, flight_no: "PG0198", fraction: 0.12, model: "Airbus A321-200", scheduled_departure_local: ~N[2016-08-15 09:10:00.000000], total_seats: 170},
:   %{arrival_city: "Ulyanovsk", departure_city: "Perm", fact_passengers: 31, flight_id: 97150, flight_no: "PG0683", fraction: 0.32, model: "Sukhoi Superjet-100", scheduled_departure_local: ~N[2016-08-15 09:15:00.000000], total_seats: 97}
: ]

Рассмотренный сложный запрос можно сделать более наглядным за счет выделения
подзапроса в отдельную конструкцию, которая называется *общее табличное
выражение* (*Common Table Expression* — *CTE*).

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  WITH ts AS (
    SELECT f.flight_id,
           f.flight_no,
           f.scheduled_departure_local,
           f.departure_city,
           f.arrival_city,
           f.aircraft_code,
           count(tf.ticket_no) AS fact_passengers,
           ( SELECT count(s.seat_no)
               FROM seats AS s
              WHERE s.aircraft_code = f.aircraft_code
           ) AS total_seats
      FROM flights_v AS f
             JOIN ticket_flights AS tf
                 ON f.flight_id = tf.flight_id
     WHERE f.status = 'Arrived'
     GROUP BY 1, 2, 3, 4, 5, 6
  )
  SELECT ts.flight_id,
         ts.flight_no,
         ts.scheduled_departure_local,
         ts.departure_city,
         ts.arrival_city,
         a.model,
         ts.fact_passengers,
         ts.total_seats,
         round(ts.fact_passengers::numeric / ts.total_seats::numeric, 2) AS fraction
    FROM ts
           JOIN aircrafts AS a
               ON a.aircraft_code = ts.aircraft_code
   ORDER BY ts.scheduled_departure_local
   LIMIT 10;
#+END_SRC

#+RESULTS:
| flight_id | flight_no | scheduled_departure_local | departure_city | arrival_city     | model               | fact_passengers | total_seats | fraction |
|-----------+-----------+---------------------------+----------------+------------------+---------------------+-----------------+-------------+----------|
|     61531 | PG0360    | 2016-08-15 09:00:00       | St. Petersburg | Orenburg         | Bombardier CRJ-200  |               6 |          50 |     0.12 |
|     40096 | PG0120    | 2016-08-15 09:00:00       | Moscow         | Mirnyj           | Boeing 737-300      |              35 |         130 |     0.27 |
|    182960 | PG0032    | 2016-08-15 09:00:00       | Penza          | Moscow           | Cessna 208 Caravan  |               2 |          12 |     0.17 |
|     46363 | PG0591    | 2016-08-15 09:00:00       | Moscow         | Tomsk            | Sukhoi Superjet-100 |              26 |          97 |     0.27 |
|     11346 | PG0239    | 2016-08-15 09:05:00       | Moscow         | Khanty-Mansiysk  | Sukhoi Superjet-100 |              60 |          97 |     0.62 |
|     23643 | PG0414    | 2016-08-15 09:05:00       | Moscow         | Murmansk         | Bombardier CRJ-200  |              12 |          50 |     0.24 |
|    200088 | PG0248    | 2016-08-15 09:05:00       | Sochi          | Nizhniy Novgorod | Bombardier CRJ-200  |               3 |          50 |     0.06 |
|    214043 | PG0550    | 2016-08-15 09:05:00       | Beslan         | Moscow           | Bombardier CRJ-200  |              10 |          50 |     0.20 |
|     60331 | PG0198    | 2016-08-15 09:10:00       | St. Petersburg | Irkutsk          | Airbus A321-200     |              20 |         170 |     0.12 |
|      9249 | PG0509    | 2016-08-15 09:15:00       | Moscow         | Elista           | Sukhoi Superjet-100 |              13 |          97 |     0.13 |

#+BEGIN_SRC elixir :exports both :eval no
  # macro example
  seats_query =
    Seat
    |> where([s], s.aircraft_code == parent_as(:flight).aircraft_code)
    |> select([s], count(s.seat_no))

  tickets_query =
    FlightExtended
    |> from(as: :flight)
    |> join(:inner, [f], tf in TicketFlights, on: f.flight_id == tf.flight_id)
    |> where([f], f.status == "Arrived")
    |> group_by([f], [
      f.flight_id,
      f.flight_no,
      f.scheduled_departure_local,
      f.departure_city,
      f.arrival_city,
      f.aircraft_code
    ])
    |> select(
      [f],
      map(f, [
        :flight_id,
        :flight_no,
        :scheduled_departure_local,
        :departure_city,
        :arrival_city,
        :aircraft_code
      ])
    )
    |> select_merge(
      [f, tf],
      %{
        fact_passengers: selected_as(count(tf.ticket_no), :fact_passengers),
        total_seats: selected_as(subquery(seats_query), :total_seats)
      }
    )

  "ts"
  |> with_cte("ts", as: ^tickets_query)
  |> join(:inner, [ts], a in Aircraft, on: ts.aircraft_code == a.aircraft_code)
  |> order_by([ts], ts.scheduled_departure_local)
  |> limit(10)
  |> select(
    [ts],
    map(ts, [
      :flight_id,
      :flight_no,
      :scheduled_departure_local,
      :departure_city,
      :arrival_city,
      :fact_passengers,
      :total_seats
    ])
  )
  |> select_merge([ts, a], map(a, [:model]))
  |> select_merge([ts], %{
    fraction:
      type(
        fragment("round(?::numeric / ?::numeric, 2)", ts.fact_passengers, ts.total_seats),
        :float
      )
  })
  |> Repo.all()
#+END_SRC

#+RESULTS:
: 13:02:37.783 [debug] QUERY OK source="ts" db=7641.3ms idle=1192.1ms
: WITH "ts" AS (SELECT sf0."flight_id" AS "flight_id", sf0."flight_no" AS "flight_no", sf0."scheduled_departure_local" AS "scheduled_departure_local", sf0."departure_city" AS "departure_city", sf0."arrival_city" AS "arrival_city", sf0."aircraft_code" AS "aircraft_code", count(st1."ticket_no") AS "fact_passengers", (SELECT count(sss0."seat_no") AS "result" FROM "seats" AS sss0 WHERE (sss0."aircraft_code" = sf0."aircraft_code")) AS "total_seats" FROM "flights_v" AS sf0 INNER JOIN "ticket_flights" AS st1 ON sf0."flight_id" = st1."flight_id" WHERE (sf0."status" = 'Arrived') GROUP BY sf0."flight_id", sf0."flight_no", sf0."scheduled_departure_local", sf0."departure_city", sf0."arrival_city", sf0."aircraft_code") SELECT t0."flight_id", t0."flight_no", t0."scheduled_departure_local", t0."departure_city", t0."arrival_city", t0."fact_passengers", t0."total_seats", a1."model", round(t0."fact_passengers"::numeric / t0."total_seats"::numeric, 2)::float FROM "ts" AS t0 INNER JOIN "aircrafts" AS a1 ON t0."aircraft_code" = a1."aircraft_code" ORDER BY t0."scheduled_departure_local" LIMIT 10 []
: >>> :
: [
:   %{arrival_city: "Orenburg", departure_city: "St. Petersburg", fact_passengers: 6, flight_id: 61531, flight_no: "PG0360", fraction: 0.12, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 50},
:   %{arrival_city: "Mirnyj", departure_city: "Moscow", fact_passengers: 35, flight_id: 40096, flight_no: "PG0120", fraction: 0.27, model: "Boeing 737-300", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 130},
:   %{arrival_city: "Moscow", departure_city: "Penza", fact_passengers: 2, flight_id: 182960, flight_no: "PG0032", fraction: 0.17, model: "Cessna 208 Caravan", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 12},
:   %{arrival_city: "Tomsk", departure_city: "Moscow", fact_passengers: 26, flight_id: 46363, flight_no: "PG0591", fraction: 0.27, model: "Sukhoi Superjet-100", scheduled_departure_local: ~N[2016-08-15 09:00:00.000000], total_seats: 97},
:   %{arrival_city: "Nizhniy Novgorod", departure_city: "Sochi", fact_passengers: 3, flight_id: 200088, flight_no: "PG0248", fraction: 0.06, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 50},
:   %{arrival_city: "Moscow", departure_city: "Beslan", fact_passengers: 10, flight_id: 214043, flight_no: "PG0550", fraction: 0.2, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 50},
:   %{arrival_city: "Khanty-Mansiysk", departure_city: "Moscow", fact_passengers: 60, flight_id: 11346, flight_no: "PG0239", fraction: 0.62, model: "Sukhoi Superjet-100", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 97},
:   %{arrival_city: "Murmansk", departure_city: "Moscow", fact_passengers: 12, flight_id: 23643, flight_no: "PG0414", fraction: 0.24, model: "Bombardier CRJ-200", scheduled_departure_local: ~N[2016-08-15 09:05:00.000000], total_seats: 50},
:   %{arrival_city: "Irkutsk", departure_city: "St. Petersburg", fact_passengers: 20, flight_id: 60331, flight_no: "PG0198", fraction: 0.12, model: "Airbus A321-200", scheduled_departure_local: ~N[2016-08-15 09:10:00.000000], total_seats: 170},
:   %{arrival_city: "Ulyanovsk", departure_city: "Perm", fact_passengers: 31, flight_id: 97150, flight_no: "PG0683", fraction: 0.32, model: "Sukhoi Superjet-100", scheduled_departure_local: ~N[2016-08-15 09:15:00.000000], total_seats: 97}
: ]

В этой главе мы уже решали задачу распределения сумм бронирований по диапазонам
с шагом в 100 тысяч рублей. Можно решить эту задачу более рациональным способом
с использованием конструкции ~WITH ... AS (...)~.

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  WITH RECURSIVE ranges (min_sum, max_sum) AS (
    VALUES (0, 100000)

    UNION ALL

    SELECT min_sum + 100000, max_sum + 100000
    FROM ranges
    WHERE max_sum < (SELECT max(total_amount) FROM bookings)
  )
  SELECT r.min_sum,
         r.max_sum,
         count(b.*)
    FROM bookings AS b
         RIGHT OUTER JOIN ranges AS r
             ON b.total_amount >= r.min_sum
                AND b.total_amount < r.max_sum
   GROUP BY r.min_sum, r.max_sum
   ORDER BY r.min_sum;
#+END_SRC

#+RESULTS:
| min_sum | max_sum |   count |
|---------+---------+---------|
|       0 |  100000 | 1589446 |
|  100000 |  200000 |  380085 |
|  200000 |  300000 |   95943 |
|  300000 |  400000 |   26883 |
|  400000 |  500000 |   10588 |
|  500000 |  600000 |    5474 |
|  600000 |  700000 |    1948 |
|  700000 |  800000 |     453 |
|  800000 |  900000 |     174 |
|  900000 | 1000000 |      90 |
| 1000000 | 1100000 |      19 |
| 1100000 | 1200000 |       4 |
| 1200000 | 1300000 |       2 |
| 1300000 | 1400000 |       1 |

#+BEGIN_SRC elixir :exports both :eval no
  # TODO заимплементить
  # keyword example
  # macro example
#+END_SRC

#+RESULTS:

В этом примере мы явно указали имена столбцов для временной таблицы ~ranges~ —
это ~min_sum~ и ~max_sum~. Рекурсивный алгоритм работает следующим образом:
- cначала выполняется предложение ~VALUES (0, 100000)~ и результат записывается
  во временную область памяти;
- затем к этой временной области памяти применяется запрос ~SELECT min_sum +
  100000, max_sum + 100000~ и в результате его выполнения формируется только
  одна строка, поскольку в исходном предложении ~VALUES~ была сформирована
  только одна строка и только одна строка была помещена во временную область
  памяти;
- вновь сформированная строка вместе с исходной строкой помещаются в другую
  временную область, в которой происходит накапливание результирующих строк;
- к той строке, которая была на предыдущем шаге сформирована с помощью команды
  ~SELECT~, опять применяется эта же команда и т.д.;
- работа завершится, когда перестанет выполняться условие ~max_sum < ( SELECT
  max(total_amount) FROM bookings )~.

Важную роль в этом процессе играет предложение ~UNION ALL~, благодаря которому
происходит объединение сформированных строк в единую таблицу. Поскольку в нашем
примере в рекурсивном алгоритме участвует только одна строка, то
строк-дубликатов не возникает, поэтому мы используем не ~UNION~, а ~UNION ALL~.
При использовании предложения ~UNION~ выполняется устранение строк-дубликатов,
но вданном случае необходимости в выполнении этой операции нет, следовательно,
целесообразно использовать именно ~UNION ALL~.
** Контрольные вопросы и задания
*** Вопрос 1
В документации сказано, что служебный символ «%» в шаблоне оператора ~LIKE~
соответствует любой последовательности символов, в том числе и пустой
последовательности, однако ничего не сказано насчет правил обработки пробелов.

В таблице ~tickets~ столбец ~passenger_name~ содержит имя и фамилию пассажира,
записанные заглавными латинскими буквами и разделенные одним пробелом. Выясните
правила обработки пробелов самостоятельно, выполнив следующие команды и сравнив
полученные результаты:

#+BEGIN_SRC sql :engine postgres :exports both :results value verbatim :eval no
  SELECT count(*) AS total   FROM tickets;
  SELECT count(*) AS "% %"   FROM tickets WHERE passenger_name LIKE '% %';
  SELECT count(*) AS "% % %" FROM tickets WHERE passenger_name LIKE '% % %';
  SELECT count(*) AS "% %%"  FROM tickets WHERE passenger_name LIKE '% %%';
#+END_SRC

*ОТВЕТ*:

#+RESULTS:
: total
: 2949857
: % %
: 2949857
: % % %
: 0
: % %%
: 2949857
*** Вопрос 2
Этот запрос выбирает из таблицы ~tickets~ всех пассажиров с именами, состоящими
из трех букв (в шаблоне присутствуют три символа «_»): src_sql[:exports
code]{SELECT passenger_name FROM tickets WHERE passenger_name LIKE '___ %';}

Предложите шаблон поиска в операторе ~LIKE~ для выбора из этой таблицы всех
пассажиров с фамилиями, состоящими из пяти букв.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :eval no
  SELECT passenger_name
    FROM tickets
   WHERE passenger_name LIKE '_____ %';
#+END_SRC
*** Вопрос 3
В разделе документации 9.7.2 «Регулярные выражения SIMILAR TO» рассматривается
оператор ~SIMILAR TO~. Он работает аналогично оператору ~LIKE~, но использует
шаблоны, соответствующие определению регулярных выражений, приведенному в
стандарте SQL. Регулярные выражения SQL представляют собой комбинацию синтаксиса
~LIKE~ с синтаксисом обычных регулярных выражений. Самостоятельно ознакомьтесь с
оператором ~SIMILAR TO~.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT 'abc' SIMILAR TO '%(b|d)%';
#+END_SRC

#+RESULTS:
| ?column? |
|----------|
| t        |
*** Вопрос 4
В разделе документации 9.2 «Функция и операторы сравнения» представлены
различные предикаты сравнения, кроме предиката ~BETWEEN~, рассмотренного в этой
главе. Самостоятельно ознакомьтесь с ними.

*ОТВЕТ*:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  WITH examples AS (
    SELECT NULL, 'Между (включая границы)'
     UNION ALL
    SELECT 2 BETWEEN 1 AND 3, '2 BETWEEN 1 AND 3 -> t'
     UNION ALL
    SELECT 2 BETWEEN 3 AND 1, '2 BETWEEN 3 AND 1 -> f'
     UNION ALL
    SELECT NULL, 'Не между (обратное к BETWEEN)'
     UNION ALL
    SELECT 2 NOT BETWEEN 1 AND 3, '2 NOT BETWEEN 1 AND 3 -> f'
     UNION ALL
    SELECT NULL, 'Между, после сортировки граничных значений'
     UNION ALL
    SELECT 2 BETWEEN SYMMETRIC 3 AND 1, '2 BETWEEN SYMMETRIC 3 AND 1 -> t'
     UNION ALL
    SELECT NULL, 'Не равно, при этом NULL воспринимается как обычное значение'
     UNION ALL
    SELECT 1 IS DISTINCT FROM NULL, '1 IS DISTINCT FROM NULL -> t (а не NULL)'
     UNION ALL
    SELECT NULL IS DISTINCT FROM NULL, 'NULL IS DISTINCT FROM NULL -> f (а не NULL)'
     UNION ALL
    SELECT NULL, 'Равно, при этом NULL воспринимается как обычно значение'
     UNION ALL
    SELECT 1 IS NOT DISTINCT FROM NULL, '1 IS NOT DISTINCT FROM NULL -> f (а не NULL)'
     UNION ALL
    SELECT NULL IS NOT DISTINCT FROM NULL, 'NULL IS NOT DISTINCT FROM NULL -> t (а не NULL)'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли значение эквивалентным NULL'
     UNION ALL
    SELECT 1.5 IS NULL, '1.5 IS NULL -> f'
     UNION ALL
    SELECT NULL, 'Проверяет, отличается ли значение от NULL'
     UNION ALL
    SELECT 'null' IS NOT NULL, '''null'' IS NOT NULL -> t'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли результат логического выражения значением true'
     UNION ALL
    SELECT true IS TRUE, 'true IS TRUE -> t'
     UNION ALL
    SELECT NULL::boolean IS TRUE, 'NULL::boolean IS TRUE -> f (а не NULL)'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли результат логического выражения значением false или неизвестным'
     UNION ALL
    SELECT true IS NOT TRUE, 'true IS NOT TRUE -> f'
     UNION ALL
    SELECT NULL::boolean IS NOT TRUE, 'NULL::boolean IS NOT TRUE -> t (а не NULL)'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли результат логического выражения значением false'
     UNION ALL
    SELECT true IS FALSE, 'true IS FALSE -> f'
     UNION ALL
    SELECT NULL::boolean IS FALSE, 'NULL::boolean IS FALSE -> f (а не NULL)'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли результат логического выражения значением true или неизвестным'
     UNION ALL
    SELECT true IS NOT FALSE, 'true IS NOT FALSE -> f'
     UNION ALL
    SELECT NULL::boolean IS NOT FALSE, 'NULL::boolean IS NOT FALSE -> t (а не NULL)'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли результат логического выражения неизвестным значением'
     UNION ALL
    SELECT true IS UNKNOWN, 'true IS UNKNOWN -> f'
     UNION ALL
    SELECT NULL::boolean IS UNKNOWN, 'NULL::boolean IS UNKNOWN -> t (а не NULL)'
     UNION ALL
    SELECT NULL, 'Проверяет, является ли результат логического выражения значением true или false'
     UNION ALL
    SELECT true IS NOT UNKNOWN, 'true IS NOT UNKNOWN -> t'
     UNION ALL
    SELECT NULL::boolean IS NOT UNKNOWN, 'NULL::boolean IS NOT UNKNOWN -> f (а не NULL)'
    )
  SELECT * FROM examples
#+END_SRC

#+RESULTS:
| ?column? | ?column?                                                                                 |
|----------+------------------------------------------------------------------------------------------|
|          | Между (включая границы)                                                                  |
| ~t~      | src_sql[:exports code]{2 BETWEEN 1 AND 3} -> ~t~                                         |
| ~f~      | src_sql[:exports code]{2 BETWEEN 3 AND 1} -> ~f~                                         |
|          | Не между (обратное к ~BETWEEN~)                                                          |
| ~f~      | src_sql[:exports code]{2 NOT BETWEEN 1 AND 3} -> ~f~                                     |
|          | Между, после сортировки граничных значений                                               |
| ~t~      | src_sql[:exports code]{2 BETWEEN SYMMETRIC 3 AND 1} -> ~t~                               |
|          | Не равно, при этом NULL воспринимается как обычное значение                              |
| ~t~      | src_sql[:exports code]{1 IS DISTINCT FROM NULL} -> ~t~ (а не ~NULL~)                     |
| ~f~      | src_sql[:exports code]{NULL IS DISTINCT FROM NULL} -> ~f~ (а не ~NULL~)                  |
|          | Равно, при этом NULL воспринимается как обычно значение                                  |
| ~f~      | src_sql[:exports code]{1 IS NOT DISTINCT FROM NULL} -> ~f~ (а не ~NULL~)                 |
| ~t~      | src_sql[:exports code]{NULL IS NOT DISTINCT FROM NULL} -> ~t~ (а не ~NULL~)              |
|          | Проверяет, является ли значение эквивалентным ~NULL~                                     |
| ~f~      | src_sql[:exports code]{1.5 IS NULL} -> ~f~                                               |
|          | Проверяет, отличается ли значение от ~NULL~                                              |
| ~t~      | src_sql[:exports code]{'null' IS NOT NULL} -> ~t~                                        |
|          | Проверяет, является ли результат логического выражения значением true                    |
| ~t~      | src_sql[:exports code]{true IS TRUE} -> ~t~                                              |
| ~f~      | src_sql[:exports code]{NULL::boolean IS TRUE} -> ~f~ (а не ~NULL~)                       |
|          | Проверяет, является ли результат логического выражения значением ~false~ или неизвестным |
| ~f~      | src_sql[:exports code]{true IS NOT TRUE} -> ~f~                                          |
| ~t~      | src_sql[:exports code]{NULL::boolean IS NOT TRUE} -> ~t~ (а не ~NULL~)                   |
|          | Проверяет, является ли результат логического выражения значением ~false~                 |
| ~f~      | src_sql[:exports code]{true IS FALSE} -> ~f~                                             |
| ~f~      | src_sql[:exports code]{NULL::boolean IS FALSE} -> ~f~ (а не ~NULL~)                      |
|          | Проверяет, является ли результат логического выражения значением ~true~ или неизвестным  |
| ~t~      | src_sql[:exports code]{true IS NOT FALSE} -> f                                           |
| ~t~      | src_sql[:exports code]{NULL::boolean IS NOT FALSE} -> t (а не ~NULL~)                    |
|          | Проверяет, является ли результат логического выражения неизвестным значением             |
| ~f~      | src_sql[:exports code]{true IS UNKNOWN} -> ~f~                                           |
| ~t~      | src_sql[:exports code]{NULL::boolean IS UNKNOWN} -> ~t~ (а не ~NULL~)                    |
|          | Проверяет, является ли результат логического выражения значением ~true~ или ~false~      |
| ~t~      | src_sql[:exports code]{true IS NOT UNKNOWN} -> ~t~                                       |
| ~f~      | src_sql[:exports code]{NULL::boolean IS NOT UNKNOWN} -> ~f~ (а не ~NULL~)                |
*** Вопрос 5
В разделе документации 9.17 «Условные выражения» представлены условные
выражения, которые поддерживаются в PostgreSQL. В тексте главы была рассмотрена
конструкция ~CASE~. Самостоятельно ознакомьтесь с функциями ~COALESCE~,
~NULLIF~, ~GREATEST~ и ~LEAST~.

*TODO* ответить на вопрос
*** Вопрос 6
Выясните, на каких маршрутах используются самолеты компании /Boeing/. В выборке
вместо кода модели должно выводиться ее наименование, например, вместо кода
/733/ должно быть /Boeing 737-300/. Указание: можно воспользоваться соединением
представления ~routes~ и таблицы ~aircrafts~.

*TODO* ответить на вопрос
*** Вопрос 7
Самые крупные самолеты в нашей авиакомпании — это Boeing 777-300. Выяснить,
между какими парами городов они летают, поможет запрос:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT DISTINCT departure_city,
                  arrival_city
    FROM routes r
         JOIN aircrafts a
             ON r.aircraft_code = a.aircraft_code
   WHERE a.model = 'Boeing 777-300'
   ORDER BY 1;
#+END_SRC

#+RESULTS:
| departure_city | arrival_city  |
|----------------+---------------|
| Moscow         | Novosibirsk   |
| Moscow         | Perm          |
| Moscow         | Sochi         |
| Moscow         | Yekaterinburg |
| Novosibirsk    | Moscow        |
| Perm           | Moscow        |
| Sochi          | Moscow        |
| Yekaterinburg  | Moscow        |

К сожалению, в этой выборке информация дублируется. Пары городов приведены по
два раза: для рейса «туда» и для рейса «обратно». Модифицируйте запростаким
образом, чтобы каждая пара городов была выведена только один раз.

*TODO* ответить на вопрос
*** Вопрос 8
В тексте главы мы рассматривали различные примеры использования левого и правого
внешних соединений: ~LEFT OUTER JOIN~ и ~RIGHT OUTER JOIN~. Напишите запрос, в
котором использовалось бы полное внешнее соединение — ~FULL OUTER JOIN~.

*TODO* ответить на вопрос
*** Вопрос 9
Для ответа на вопрос, сколько рейсов выполняется из Москвы в Санкт-Петербург,
можно написать совсем простой запрос:

#+BEGIN_SRC sql :engine postgres :exports both :eval no
  SELECT count(*)
    FROM routes
   WHERE departure_city = 'Moscow'
     AND arrival_city   = 'St. Petersburg';
#+END_SRC

#+RESULTS:
| count |
|-------|
|    12 |

А с помощью какого запроса можно получить результат в таком виде?

| departure_city | arrival_city   | count |
|----------------+----------------+-------|
| Moscow         | St. Petersburg | 12    |

*TODO* ответить на вопрос
* Схема базы
** Миграции
#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Repo.Migrations.AddsAircraftsTable do
    use Ecto.Migration

    def change do
      create table(:aircrafts, primary_key: false, comment: "Aircrafts") do
        add :aircraft_code, :char, size: 3, primary_key: true, comment: "Aircraft code, IATA"
        add :model, :text, null: false, comment: "Aircraft model"
        add :range, :integer, null: false, comment: "Maximal flying distance, km"
      end

      create constraint(:aircrafts, "aircrafts_range_check", check: "range > 0", comment: "range should be greater than 0")
    end
  end

  defmodule AirDB.Repo.Migrations.AddsAirportsTable do
    use Ecto.Migration

    def change do
      create table(:airports, primary_key: false, comment: "Airports") do
        add :airport_code, :char, size: 3, primary_key: true, comment: "Airport code"
        add :airport_name, :text, null: false, comment: "Airport name"
        add :city, :text, null: false, comment: "City"
        add :coordinates, :point, null: false, comment: "Airport coordinates (longitude and latitude)"
        add :timezone, :text, null: false, comment: "Airport time zone"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsBookingsTable do
    use Ecto.Migration

    def change do
      create table(:bookings, primary_key: false, comment: "Bookings") do
        add :book_ref, :char, size: 6, primary_key: true, comment: "Booking number"
        add :book_date, :timestamptz, null: false, comment: "Booking date"
        add :total_amount, :numeric, null: false, precision: 10, scale: 2, comment: "Total booking cost"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsFlightsTable do
    use Ecto.Migration

    def up do
      create table(:flights, primary_key: false, comment: "Flights") do
        add :flight_id, :integer, primary_key: true, comment: "Flight ID"
        add :flight_no, :char, size: 6, null: false, comment: "Flight number"
        add :scheduled_departure, :timestamptz, null: false, comment: "Scheduled departure time"
        add :scheduled_arrival, :timestamptz, null: false, comment: "Scheduled arrival time"

        add :departure_airport_code,
          references(:airports, column: :airport_code, type: :char),
          size: 3,
          null: false,
          comment: "Airport of departure"

        add :arrival_airport_code,
          references(:airports, column: :airport_code, type: :char),
          size: 3,
          null: false,
          comment: "Airport of arrival"

        add :status, :varchar, size: 20, null: false, comment: "Flight status"

        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char),
          size: 3,
          null: false,
          comment: "Aircraft code, IATA"

        add :actual_departure, :timestamptz, comment: "Actual departure time"
        add :actual_arrival, :timestamptz, comment: "Actual arrival time"
      end

      create constraint(
        :flights,
        "flights_arrival_time_check",
        check: "scheduled_arrival > scheduled_departure"
      )

      create constraint(
        :flights,
        "flights_actual_arrival_time_check",
        check: "actual_arrival IS NULL OR actual_departure IS NOT NULL AND actual_arrival IS NOT NULL AND actual_arrival > actual_departure"
      )

      create constraint(
        :flights,
        "flights_status_check",
        check: "status = ANY(ARRAY['On Time', 'Delayed', 'Departed', 'Arrived', 'Scheduled', 'Cancelled'])"
      )

      create unique_index(:flights, [:flight_no, :scheduled_departure])

      execute ~S"""
      ALTER TABLE flights
        ADD CONSTRAINT "flights_flight_no_scheduled_departure_index"
          UNIQUE USING INDEX "flights_flight_no_scheduled_departure_index"
      """
    end

    def down do
      drop table(:flights)
    end
  end

  defmodule AirDB.Repo.Migrations.AddsFlightsView do
    use Ecto.Migration

    def up do
      execute """
      CREATE VIEW flights_v AS
       SELECT f.flight_id,
              f.flight_no,
              f.scheduled_departure,
              timezone(dep.timezone, f.scheduled_departure) AS scheduled_departure_local,
              f.scheduled_arrival,
              timezone(arr.timezone, f.scheduled_arrival) AS scheduled_arrival_local,
              (f.scheduled_arrival - f.scheduled_departure) AS scheduled_duration,
              f.departure_airport_code,
              dep.airport_name AS departure_airport_name,
              dep.city AS departure_city,
              f.arrival_airport_code,
              arr.airport_name AS arrival_airport_name,
              arr.city AS arrival_city,
              f.status,
              f.aircraft_code,
              f.actual_departure,
              timezone(dep.timezone, f.actual_departure) AS actual_departure_local,
              f.actual_arrival,
              timezone(arr.timezone, f.actual_arrival) AS actual_arrival_local,
              (f.actual_arrival - f.actual_departure) AS actual_duration
         FROM flights f,
              airports dep,
              airports arr
        WHERE f.departure_airport_code = dep.airport_code
          AND f.arrival_airport_code = arr.airport_code
      """

      execute "COMMENT ON VIEW flights_v IS 'Flights (extended)'"
      execute "COMMENT ON COLUMN flights_v.flight_id IS 'Flight ID'"
      execute "COMMENT ON COLUMN flights_v.flight_no IS 'Flight number'"
      execute "COMMENT ON COLUMN flights_v.scheduled_departure IS 'Scheduled departure time'"
      execute "COMMENT ON COLUMN flights_v.scheduled_departure_local IS 'Scheduled departure time, local time at the point of departure'"
      execute "COMMENT ON COLUMN flights_v.scheduled_arrival IS 'Scheduled arrival time'"
      execute "COMMENT ON COLUMN flights_v.scheduled_arrival_local IS 'Scheduled arrival time, local time at the point of destionation'"
      execute "COMMENT ON COLUMN flights_v.scheduled_duration IS 'Scheduled flight duration'"
      execute "COMMENT ON COLUMN flights_v.departure_airport_code IS 'Departure airport code'"
      execute "COMMENT ON COLUMN flights_v.departure_airport_name IS 'Departure airport name'"
      execute "COMMENT ON COLUMN flights_v.departure_city IS 'City of departure'"
      execute "COMMENT ON COLUMN flights_v.arrival_airport_code IS 'Arrival airport code'"
      execute "COMMENT ON COLUMN flights_v.arrival_airport_name IS 'Arrival airport name'"
      execute "COMMENT ON COLUMN flights_v.arrival_city IS 'City of arrival'"
      execute "COMMENT ON COLUMN flights_v.status IS 'Flight status'"
      execute "COMMENT ON COLUMN flights_v.aircraft_code IS 'Aircraft code, IATA'"
      execute "COMMENT ON COLUMN flights_v.actual_departure IS 'Actual departure time'"
      execute "COMMENT ON COLUMN flights_v.actual_departure_local IS 'Actual departure time, local time at the point of departure'"
      execute "COMMENT ON COLUMN flights_v.actual_arrival IS 'Actual arrival time'"
      execute "COMMENT ON COLUMN flights_v.actual_arrival_local IS 'Actual arrival time, local time at the point of destination'"
      execute "COMMENT ON COLUMN flights_v.actual_duration IS 'Actual flight duration'"
    end

    def down do
      execute "DROP VIEW flights_v"
    end
  end

  defmodule AirDB.Repo.Migrations.AddsSeatsTable do
    use Ecto.Migration

    def change do
      create table(:seats, primary_key: false, comment: "Seats") do
        add :aircraft_code,
          references(:aircrafts, column: :aircraft_code, type: :char, on_delete: :delete_all),
          size: 3,
          primary_key: true,
          comment: "Aircraft code, IATA"

        add :seat_no, :varchar, size: 4, primary_key: true, comment: "Seat number"
        add :fare_conditions, :varchar, size: 10, null: false, comment: "Travel class"
      end

      create constraint(
        :seats,
        "seats_fare_conditions_check",
        check: "fare_conditions = ANY(ARRAY['Economy', 'Comfort', 'Business'])"
      )
    end
  end

  defmodule AirDB.Repo.Migrations.AddsTicketsTable do
    use Ecto.Migration

    def change do
      create table(:tickets, primary_key: false, comment: "Tickets") do
        add :ticket_no, :char, size: 13, primary_key: true, comment: "Ticket number"

        add :book_ref,
          references(:bookings, column: :book_ref, type: :char),
          size: 6,
          null: false,
          comment: "Booking number"

        add :passenger_id, :varchar, size: 20, null: false, comment: "Passenger ID"
        add :passenger_name, :text, null: false, comment: "Passenger name"
        add :contact_data, :jsonb, comment: "Passenger contact information"
      end
    end
  end

  defmodule AirDB.Repo.Migrations.AddsTicketFlightsTable do
    use Ecto.Migration

    def change do
      create table(:ticket_flights, primary_key: false, comment: "Flight segment") do
        add :ticket_no,
          references(:tickets, column: :ticket_no, type: :char),
          size: 13,
          primary_key: true,
          comment: "Ticket number"

        add :flight_id,
          references(:flights, column: :flight_id, type: :integer),
          primary_key: true,
          comment: "Flight ID"

        add :fare_conditions, :varchar, size: 10, null: false, comment: "Travel class"
        add :amount, :numeric, precision: 10, scale: 2, null: false, comment: "Travel cost"
      end

      create constraint(:ticket_flights, "ticket_flights_amount_check", check: "amount > 0")
      create constraint(
        :ticket_flights,
        "ticket_flights_fare_condition_check",
        check: "fare_conditions = ANY(ARRAY['Economy', 'Comfort', 'Business'])"
      )
    end
  end

  defmodule AirDB.Repo.Migrations.AddsBoardingPassesTable do
    use Ecto.Migration

    def up do
      create table(:boarding_passes, primary_key: false, comment: "Boarding passes") do
        add :ticket_no,
          references(:ticket_flights, column: :ticket_no, with: [flight_id: :flight_id], type: :char),
          size: 13,
          primary_key: true,
          comment: "Ticket number"

        add :flight_id, :integer, primary_key: true, comment: "Flight ID"
        add :boarding_no, :integer, null: false, comment: "Boarding pass number"
        add :seat_no, :varchar, size: 4, null: false, comment: "Seat number"
      end

      create unique_index(:boarding_passes, [:flight_id, :boarding_no])
      create unique_index(:boarding_passes, [:flight_id, :seat_no])

      execute ~S"""
      ALTER TABLE boarding_passes
        ADD CONSTRAINT "boarding_passes_flight_id_boarding_no_index"
          UNIQUE USING INDEX "boarding_passes_flight_id_boarding_no_index"
      """

      execute ~S"""
      ALTER TABLE boarding_passes
        ADD CONSTRAINT "boarding_passes_flight_id_seat_no_index"
          UNIQUE USING INDEX "boarding_passes_flight_id_seat_no_index"
      """
    end

    def down do
      drop table(:boarding_passes)
    end
  end

  defmodule AirDB.Repo.Migrations.AddsRoutesView do
    use Ecto.Migration

    def up do
      execute """
      CREATE VIEW routes AS
      WITH f3 AS (
              SELECT f2.flight_no,
                  f2.departure_airport_code,
                  f2.arrival_airport_code,
                  f2.aircraft_code,
                  f2.duration,
                  array_agg(f2.days_of_week) AS days_of_week
                FROM ( SELECT f1.flight_no,
                          f1.departure_airport_code,
                          f1.arrival_airport_code,
                          f1.aircraft_code,
                          f1.duration,
                          f1.days_of_week
                        FROM ( SELECT flights.flight_no,
                                  flights.departure_airport_code,
                                  flights.arrival_airport_code,
                                  flights.aircraft_code,
                                  (flights.scheduled_arrival - flights.scheduled_departure) AS duration,
                                  (to_char(flights.scheduled_departure, 'ID'::text))::integer AS days_of_week
                                FROM flights) f1
                        GROUP BY f1.flight_no, f1.departure_airport_code, f1.arrival_airport_code, f1.aircraft_code, f1.duration, f1.days_of_week
                        ORDER BY f1.flight_no, f1.departure_airport_code, f1.arrival_airport_code, f1.aircraft_code, f1.duration, f1.days_of_week) f2
                GROUP BY f2.flight_no, f2.departure_airport_code, f2.arrival_airport_code, f2.aircraft_code, f2.duration
              )
      SELECT f3.flight_no,
          f3.departure_airport_code,
          dep.airport_name AS departure_airport_name,
          dep.city AS departure_city,
          f3.arrival_airport_code,
          arr.airport_name AS arrival_airport_name,
          arr.city AS arrival_city,
          f3.aircraft_code,
          f3.duration,
          f3.days_of_week
        FROM f3,
          airports dep,
          airports arr
        WHERE ((f3.departure_airport_code = dep.airport_code) AND (f3.arrival_airport_code = arr.airport_code))
      """

      execute "COMMENT ON VIEW routes IS 'Routes'"
      execute "COMMENT ON COLUMN routes.flight_no IS 'Flight number'"
      execute "COMMENT ON COLUMN routes.departure_airport_code IS 'Code of airport of departure'"
      execute "COMMENT ON COLUMN routes.departure_airport_name IS 'Name of airport of departure'"
      execute "COMMENT ON COLUMN routes.departure_city IS 'City of departure'"
      execute "COMMENT ON COLUMN routes.arrival_airport_code IS 'Code of airport of arrival'"
      execute "COMMENT ON COLUMN routes.arrival_airport_name IS 'Name of airport of arrival'"
      execute "COMMENT ON COLUMN routes.arrival_city IS 'City of arrival'"
      execute "COMMENT ON COLUMN routes.aircraft_code IS 'Aircraft code, IATA'"
      execute "COMMENT ON COLUMN routes.duration IS 'Scheduled duration of flight'"
      execute "COMMENT ON COLUMN routes.days_of_week IS 'Days of week on which flights are scheduled'"
    end

    def down do
      execute "DROP VIEW routes"
    end
  end
#+END_SRC
** Схемы
#+BEGIN_SRC elixir :eval no
  defmodule AirDB.Aircraft do
    use Ecto.Schema

    import Ecto.Changeset

    alias AirDB.Seat
    alias AirDB.Route

    @primary_key false
    schema "aircrafts" do
      field :aircraft_code, :string, primary_key: true
      field :model, :string
      field :range, :integer

      has_many :seats, Seat,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        on_replace: :mark_as_invalid

      has_many :routes, Route,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        on_replace: :mark_as_invalid
    end

    @doc false
    def changeset(aircraft, params \\ %{}) do
      aircraft
      |> cast(params, [:aircraft_code, :model, :range])
      |> cast_assoc(:seats, with: &Seat.changeset/2)
      |> validate_required([:aircraft_code, :model, :range])
      |> validate_length(:aircraft_code, is: 3, count: :bytes)
      |> unique_constraint(:aircraft_code, name: :aircrafts_pkey)
      |> check_constraint(:range, name: :aircrafts_range_check, message: "should be greater than 0")
    end
  end

  defmodule AirDB.Airport do
    use Ecto.Schema
    import Ecto.Changeset

    @primary_key false
    schema "airports" do
      field :airport_code, :string, primary_key: true
      field :airport_name, :string
      field :city, :string
      field :coordinates, AirDB.Ecto.Point
      field :timezone, :string
    end

    @doc false
    def changeset(airport, params \\ %{}) do
      airport
      |> cast(params, [:airport_code, :airport_name, :city, :coordinates, :timezone])
      |> validate_required([:airport_code, :airport_name, :city, :coordinates, :timezone])
      |> validate_length(:airport_code, is: 3, count: :bytes)
      |> unique_constraint(:airport_code, name: :airports_pkey)
    end
  end

  defmodule AirDB.BoardingPass do
    use Ecto.Schema

    import Ecto.Changeset

    alias AirDB.Flight
    alias AirDB.Ticket

    @primary_key false
    schema "boarding_passes" do
      belongs_to :ticket, Ticket,
        primary_key: true,
        foreign_key: :ticket_no,
        references: :ticket_no,
        type: :string

      belongs_to :flight, Flight,
        primary_key: true,
        foreign_key: :flight_id,
        references: :flight_id,
        type: :integer

      field :boarding_no, :integer
      field :seat_no, :string
    end

    @doc false
    def changeset(boarding_pass, params \\ %{}) do
      boarding_pass
      |> cast(params, [:ticket_no, :flight_id, :boarding_no, :seat_no])
      |> validate_required([:ticket_no, :flight_id, :boarding_no, :seat_no])
      |> unique_constraint([:ticket_no, :flight_id], name: :boarding_passes_pkey)
      |> unique_constraint([:flight_id, :boarding_no],
        message: "boarding no has already been taken"
      )
      |> unique_constraint([:flight_id, :seat_no], message: "seat no has already been taken")
      |> foreign_key_constraint(:ticket_no,
        name: :boarding_passes_ticket_no_fkey,
        message: "ticket_flights does not exist"
      )
      |> validate_length(:ticket_no, is: 13, count: :bytes)
      |> validate_length(:seat_no, min: 2, max: 4, count: :bytes)
    end
  end

  defmodule AirDB.Booking do
    use Ecto.Schema
    import Ecto.Changeset

    @primary_key false
    schema "bookings" do
      field :book_ref, :string, primary_key: true
      field :book_date, :utc_datetime
      field :total_amount, :decimal
    end

    @doc false
    def changeset(booking, params \\ %{}) do
      booking
      |> cast(params, [:book_ref, :book_date, :total_amount])
      |> validate_required([:book_ref, :book_date, :total_amount])
      |> validate_length(:book_ref, is: 6, count: :bytes)
      |> unique_constraint(:book_ref, name: :bookings_pkey)
    end
  end

  defmodule AirDB.Flight do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Airport
    alias AirDB.Aircraft

    @primary_key false
    schema "flights" do
      field :flight_id, :integer, primary_key: true
      field :flight_no, :string

      field :scheduled_departure, :utc_datetime
      field :scheduled_arrival, :utc_datetime

      field :status, :string

      field :actual_departure, :utc_datetime
      field :actual_arrival, :utc_datetime

      belongs_to :departure_airport, Airport,
        foreign_key: :departure_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :arrival_airport, Airport,
        foreign_key: :arrival_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :aircraft, Aircraft,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string
    end

    @doc false
    def changeset(flight, params \\ %{}) do
      flight
      |> cast(params, [
        :flight_id,
        :flight_no,
        :scheduled_departure,
        :scheduled_arrival,
        :departure_airport_code,
        :arrival_airport_code,
        :status,
        :aircraft_code,
        :actual_departure,
        :actual_arrival
      ])
      |> cast_assoc(:departure_airport, with: &Airport.changeset/2)
      |> cast_assoc(:arrival_airport, with: &Airport.changeset/2)
      |> cast_assoc(:aircraft, with: &Aircraft.changeset/2)
      |> validate_required([
        :flight_id,
        :flight_no,
        :scheduled_departure,
        :scheduled_arrival,
        :status
      ])
      |> validate_length(:flight_no, is: 6, count: :bytes)
      |> validate_length(:departure_airport_code, is: 3, count: :bytes)
      |> validate_length(:arrival_airport_code, is: 3, count: :bytes)
      |> validate_length(:aircraft_code, is: 3, count: :bytes)
      |> validate_inclusion(:status, [
        "On Time",
        "Delayed",
        "Departed",
        "Arrived",
        "Scheduled",
        "Cancelled"
      ])
      |> check_constraint(:status, name: :flights_status_check)
      |> check_constraint(:scheduled_arrival, name: :flights_arrival_time_check)
      |> check_constraint(:actual_arrival, name: :flights_actual_arrival_time_check)
      |> unique_constraint(:flight_id, name: :flights_pkey)
      |> unique_constraint([:flight_no, :scheduled_departure])
      |> foreign_key_constraint(:departure_airport_code)
      |> foreign_key_constraint(:arrival_airport_code)
      |> foreign_key_constraint(:aircraft_code)
    end
  end

  defmodule AirDB.FlightExtended do
    use Ecto.Schema

    @primary_key false
    schema "flights_v" do
      field :flight_id, :integer
      field :flight_no, :string
      field :scheduled_departure, :utc_datetime
      field :scheduled_departure_local, :naive_datetime
      field :scheduled_arrival, :utc_datetime
      field :scheduled_arrival_local, :naive_datetime
      # interval
      field :scheduled_duration, :binary
      field :departure_airport_name, :string
      field :departure_city, :string
      field :arrival_airport_name, :string
      field :arrival_city, :string
      field :status, :string
      field :actual_departure, :utc_datetime
      field :actual_departure_local, :naive_datetime
      field :actual_arrival, :utc_datetime
      field :actual_arrival_local, :naive_datetime
      # interval
      field :actual_duration, :binary

      belongs_to :departure_airport, Airport,
        foreign_key: :departure_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :arrival_airport, Airport,
        foreign_key: :arrival_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :aircraft, Aircraft,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string
    end
  end

  defmodule AirDB.Route do
    use Ecto.Schema

    @primary_key false
    schema "routes" do
      field :flight_no, :string
      field :departure_airport_name, :string
      field :departure_city, :string
      field :arrival_airport_name, :string
      field :arrival_city, :string
      field :duration, :binary
      field :days_of_week, {:array, :integer}

      belongs_to :aircraft, AirDB.Aircraft,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string

      belongs_to :departure_airport, AirDB.Airport,
        foreign_key: :departure_airport_code,
        references: :airport_code,
        type: :string

      belongs_to :arrival_airport, AirDB.Airport,
        foreign_key: :arrival_airport_code,
        references: :airport_code,
        type: :string
    end
  end

  defmodule AirDB.Seat do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Aircraft

    @primary_key false
    schema "seats" do
      belongs_to :aircraft, Aircraft,
        primary_key: true,
        foreign_key: :aircraft_code,
        references: :aircraft_code,
        type: :string

      field :seat_no, :string, primary_key: true
      field :fare_conditions, :string
    end

    @doc false
    def changeset(seat, params \\ %{}) do
      seat
      |> cast(params, [:aircraft_code, :seat_no, :fare_conditions])
      |> cast_assoc(:aircraft, with: &Aircraft.changeset/2)
      |> validate_required([:seat_no, :fare_conditions])
      |> validate_length(:aircraft_code, is: 3, count: :bytes)
      |> validate_length(:seat_no, min: 2, max: 4, count: :bytes)
      |> foreign_key_constraint(:aircraft_code)
      |> unique_constraint([:aircraft_code, :seat_no], name: :seats_pkey)
      |> validate_inclusion(:fare_conditions, ["Economy", "Comfort", "Business"])
      |> check_constraint(:fare_conditions, name: :seats_fare_conditions_check)
    end
  end

  defmodule AirDB.Ticket do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Booking

    @primary_key false
    schema "tickets" do
      field :ticket_no, :string, primary_key: true
      field :passenger_id, :string
      field :passenger_name, :string
      field :contact_data, :map

      belongs_to :booking, Booking,
        foreign_key: :book_ref,
        references: :book_ref,
        type: :string
    end

    @doc false
    def changeset(ticket, params \\ %{}) do
      ticket
      |> cast(params, [
        :ticket_no,
        :book_ref,
        :passenger_id,
        :passenger_name,
        :contact_data
      ])
      |> cast_assoc(:booking, with: &Booking.changeset/2)
      |> validate_required([
        :ticket_no,
        :passenger_id,
        :passenger_name,
        :contact_data
      ])
      |> validate_length(:ticket_no, is: 13, count: :bytes)
      |> validate_length(:book_ref, is: 6, count: :bytes)
      |> validate_length(:passenger_id, min: 11, max: 20, count: :bytes)
      |> unique_constraint(:ticket_no, name: :tickets_pkey)
      |> foreign_key_constraint(:book_ref)
    end
  end

  defmodule AirDB.TicketFlights do
    use Ecto.Schema
    import Ecto.Changeset
    alias AirDB.Ticket
    alias AirDB.Flight

    @primary_key false
    schema "ticket_flights" do
      field :fare_conditions, :string
      field :amount, :decimal

      belongs_to :ticket, Ticket,
        primary_key: true,
        foreign_key: :ticket_no,
        references: :ticket_no,
        type: :string

      belongs_to :flight, Flight,
        primary_key: true,
        foreign_key: :flight_id,
        references: :flight_id,
        type: :integer
    end

    @doc false
    def changeset(ticket_flight, params \\ %{}) do
      ticket_flight
      |> cast(params, [
        :ticket_no,
        :flight_id,
        :fare_conditions,
        :amount
      ])
      |> cast_assoc(:ticket, with: &Ticket.changeset/2)
      |> cast_assoc(:flight, with: &Flight.changeset/2)
      |> validate_required([:fare_conditions, :amount])
      |> validate_length(:ticket_no, is: 13, count: :bytes)
      |> unique_constraint([:ticket_no, :flight_id], name: :ticket_flights_pkey)
      |> foreign_key_constraint(:ticket_no)
      |> foreign_key_constraint(:flight_id)
      |> check_constraint(:amount, name: :ticket_flights_amount_check)
      |> check_constraint(:fare_conditions, name: :ticket_flights_fare_condition_check)
      |> validate_inclusion(:fare_conditions, ["Economy", "Comfort", "Business"])
    end
  end
#+END_SRC
#+END_SRC
